From 0b3b9bdf5a116657534c2457d61bc7d6849c837a Mon Sep 17 00:00:00 2001
From: Neil Hexstia <wangyz@farsight>
Date: Thu, 28 Jan 2016 16:09:32 +0800
Subject: [PATCH 1/2] Initial commit  o base on init diractory


diff --git a/Android.mk b/Android.mk
new file mode 100755
index 0000000..179aec6
--- /dev/null
+++ b/Android.mk
@@ -0,0 +1,84 @@
+# Copyright 2005 The Android Open Source Project
+
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+	builtins.c \
+	init.c \
+	devices.c \
+	property_service.c \
+	util.c \
+	parser.c \
+	keychords.c \
+	signal_handler.c \
+	init_parser.c \
+	ueventd.c \
+	ueventd_parser.c \
+	watchdogd.c
+
+LOCAL_CFLAGS    += -Wno-unused-parameter
+
+ifeq ($(strip $(INIT_BOOTCHART)),true)
+LOCAL_SRC_FILES += bootchart.c
+LOCAL_CFLAGS    += -DBOOTCHART=1
+endif
+
+ifneq (,$(filter user userdebug eng,$(TARGET_BUILD_VARIANT)))
+LOCAL_CFLAGS += -DALLOW_LOCAL_PROP_OVERRIDE=1 -DALLOW_DISABLE_SELINUX=1
+endif
+
+# Enable ueventd logging
+ifneq ($(TARGET_USE_BOOSTUP_OPZ), false)
+LOCAL_SRC_FILES += boostup.c
+LOCAL_CFLAGS    += -DAW_BOOSTUP_ENABLE
+ifeq ($(TARGET_BOARD_PLATFORM), kylin)
+LOCAL_CFLAGS   += -DSUN9IW1P1
+endif
+ifeq ($(TARGET_BOARD_PLATFORM), astar)
+LOCAL_CFLAGS   += -DSUN8IW5P1
+endif
+ifeq ($(TARGET_BOARD_PLATFORM), octopus)
+LOCAL_CFLAGS   += -DSUN8IW6P1
+endif
+endif
+#LOCAL_CFLAGS += -DLOG_UEVENTS=1
+
+LOCAL_MODULE:= init
+
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
+LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
+
+LOCAL_STATIC_LIBRARIES := \
+	libfs_mgr \
+	liblogwrap \
+	libcutils \
+	liblog \
+	libc \
+	libselinux \
+	libmincrypt \
+	libext4_utils_static
+
+LOCAL_ADDITIONAL_DEPENDENCIES += $(LOCAL_PATH)/Android.mk
+
+include $(BUILD_EXECUTABLE)
+
+# Make a symlink from /sbin/ueventd and /sbin/watchdogd to /init
+SYMLINKS := \
+	$(TARGET_ROOT_OUT)/sbin/ueventd \
+	$(TARGET_ROOT_OUT)/sbin/watchdogd
+
+$(SYMLINKS): INIT_BINARY := $(LOCAL_MODULE)
+$(SYMLINKS): $(LOCAL_INSTALLED_MODULE) $(LOCAL_PATH)/Android.mk
+	@echo "Symlink: $@ -> ../$(INIT_BINARY)"
+	@mkdir -p $(dir $@)
+	@rm -rf $@
+	$(hide) ln -sf ../$(INIT_BINARY) $@
+
+ALL_DEFAULT_INSTALLED_MODULES += $(SYMLINKS)
+
+# We need this so that the installed files could be picked up based on the
+# local module name
+ALL_MODULES.$(LOCAL_MODULE).INSTALLED := \
+    $(ALL_MODULES.$(LOCAL_MODULE).INSTALLED) $(SYMLINKS)
diff --git a/MODULE_LICENSE_APACHE2 b/MODULE_LICENSE_APACHE2
new file mode 100644
index 0000000..e69de29
diff --git a/NOTICE b/NOTICE
new file mode 100644
index 0000000..c5b1efa
--- /dev/null
+++ b/NOTICE
@@ -0,0 +1,190 @@
+
+   Copyright (c) 2005-2008, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/README.BOOTCHART b/README.BOOTCHART
new file mode 100644
index 0000000..70cf2c3
--- /dev/null
+++ b/README.BOOTCHART
@@ -0,0 +1,52 @@
+This version of init contains code to perform "bootcharting", i.e. generating log
+files that can be later processed by the tools provided by www.bootchart.org.
+
+To activate it, you need to define build 'init' with the INIT_BOOTCHART environment
+variable defined to 'true', for example:
+
+    touch system/init/init.c
+    m INIT_BOOTCHART=true
+
+On the emulator, use the new -bootchart <timeout> option to boot with bootcharting
+activated for <timeout> seconds.
+
+Otherwise, flash your device, and start it. Then create a file on the /data partition
+with a command like the following:
+
+  adb shell 'echo $TIMEOUT > /data/bootchart-start'
+
+Where the value of $TIMEOUT corresponds to the wanted bootcharted period in seconds;
+for example, to bootchart for 2 minutes, do:
+
+  adb shell 'echo 120 > /data/bootchart-start'
+
+Reboot your device, bootcharting will begin and stop after the period you gave.
+You can also stop the bootcharting at any moment by doing the following:
+
+  adb shell 'echo 1 > /data/bootchart-stop'
+
+Note that /data/bootchart-stop is deleted automatically by init at the end of the
+bootcharting. This is not the case of /data/bootchart-start, so don't forget to delete it
+when you're done collecting data:
+
+  adb shell rm /data/bootchart-start
+
+The log files are placed in /data/bootchart/. you must run the script tools/grab-bootchart.sh
+which will use ADB to retrieve them and create a bootchart.tgz file that can be used with
+the bootchart parser/renderer, or even uploaded directly to the form located at:
+
+  http://www.bootchart.org/download.html
+
+NOTE: the bootchart.org webform doesn't seem to work at the moment, you can generate an
+      image on your machine by doing the following:
+
+         1/ download the sources from www.bootchart.org
+         2/ unpack them
+         3/ in the source directory, type 'ant' to build the bootchart program
+         4/ type 'java -jar bootchart.jar /path/to/bootchart.tgz
+
+technical note:
+
+this implementation of bootcharting does use the 'bootchartd' script provided by
+www.bootchart.org, but a C re-implementation that is directly compiled into our init
+program.
diff --git a/boostup.c b/boostup.c
new file mode 100755
index 0000000..aca873b
--- /dev/null
+++ b/boostup.c
@@ -0,0 +1,378 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <dirent.h>
+#include <limits.h>
+#include <errno.h>
+
+#include <cutils/misc.h>
+#include <cutils/sockets.h>
+#include <cutils/multiuser.h>
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/mman.h>
+#include <private/android_filesystem_config.h>
+
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+
+#include "log.h"
+
+#define AW_BOOST_UP_DRAM "/sys/class/devfreq/sunxi-ddrfreq/dsm/scene"
+#define AW_BOOST_UP_CPUS "/sys/devices/platform/sunxi-budget-cooling/roomage"
+#define AW_BOOST_UP_TASK "/dev/cpuctl/tasks"
+#define AW_BOOST_UP_GPU  "/sys/devices/platform/pvrsrvkm/dvfs/android"
+
+#ifdef SUN9IW1P1
+#define AW_BOOST_UP_CPUS_PERF       "1200000 1 1608000 2 1200000 4 1608000 4 0"
+#define AW_BOOST_UP_CPUS_NORMAL     "0       0       0 0 1200000 4 1608000 4 0"
+#define AW_BOOST_UP_CPUS_VIDEO      "0       0       0 0 1200000 4 1608000 4 0"
+#elif defined SUN8IW5P1
+#define AW_BOOST_UP_CPUS_PERF       "1008000 4 0 0 1200000 4 0 0 0"
+#define AW_BOOST_UP_CPUS_NORMAL     "0 0 0 0 1200000 4 0 0 0"
+#define AW_BOOST_UP_CPUS_VIDEO      "0 0 0 0 1200000 4 0 0 2"
+#elif  defined SUN8IW6P1
+#define AW_BOOST_UP_CPUS_PERF       "1608000 4 1608000 0 2016000 4 2016000 4 0"
+#define AW_BOOST_UP_CPUS_NORMAL     "0 0 0 0 2016000 4 2016000 4 0"
+#define AW_BOOST_UP_CPUS_VIDEO      "0 0 0 0 2016000 4 2016000 4 0"
+#endif
+
+/* dram scene value defined */
+#define AW_BOOST_UP_DRAM_DEFAULT        "0"
+#define AW_BOOST_UP_DRAM_HOME           "1"
+#define AW_BOOST_UP_DRAM_LOCALVIDEO     "2"
+#define AW_BOOST_UP_DRAM_BGMUSIC        "3"
+#define AW_BOOST_UP_DRAM_4KLOCALVIDEO   "4"
+
+/* gpu scene value defined */
+#define AW_BOOST_UP_GPU_DEFAULT         "4\n"
+#define AW_BOOST_UP_GPU_HOME            "4\n"
+#define AW_BOOST_UP_GPU_LOCALVIDEO      "4\n"
+#define AW_BOOST_UP_GPU_BGMUSIC         "4\n"
+#define AW_BOOST_UP_GPU_4KLOCALVIDEO    "4\n"
+#define AW_BOOST_UP_GPU_PERF            "8\n"
+
+static int boost_up_dram_fd = -1;
+static int boost_up_cpus_fd = -1;
+static int boost_up_task_fd = -1;
+static int boost_up_gpu_fd = -1;
+static bool BOOST_UP_DEBUG = true;
+static int runmode = 0xa7;
+
+/*
+   struct scene_desc {
+   int scene_id;
+   int scene_fd;
+   char data[0];
+   };
+   */
+
+/*
+ * benchmark list order by index
+ *
+ * 1.com.antutu.ABenchMark
+ * 2.com.qihoo360.mobilesafe.opti
+ * 3.com.qihoo360.mobilesafe.bench
+ * 4.com.glbenchmark.glbenchmark27
+ * 5.com.glbenchmark.glbenchmark30
+ * 6.com.ludashi.benchmark
+ * 7.com.rightware.tdmm2v10jni.free
+ * 8.com.futuremark.dmandroid.application
+ * 9.com.greenecomputing.linpack
+ * 10.com.tactel.electopia
+ * 11.eu.chainfire.cfbench
+ * 12.com.quicinc.vellamo
+ * 13.com.aurorasoftworks.quadrant.ui.advanced
+ * 14.com.thread.jpct.bench
+ * 15.se.nena.nenamark2
+ * 16.com.epicgames.EpicCitadel
+ * 17.com.ixia.ixchariot
+ * 18.com.magicandroidapps.iperf
+ * 19.com.qqfriends.com.music
+ * 20.com.powervr.Cat
+ * 21.com.antutu.AbenchMark5
+ * 22.
+ * 23.
+ * 24.
+ */
+
+#ifdef SUN9IW1P1
+const char *roomage_a7[] = {
+    "912000 2 1296000 2 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "1200000 1 1608000 4 1200000 4 1800000 4 1",
+    "912000 4 1296000 4 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 3 1200000 4 1800000 4 1",
+    "1200000 1 1608000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "912000 1 1296000 0 1200000 4 1800000 4 1",
+    "1200000 1 1608000 1 1200000 4 1800000 4 1",
+    "1200000 1 1608000 1 1200000 4 1800000 4 1",
+    "1200000 1 1608000 1 1200000 4 1800000 4 1",
+    "1200000 1 1608000 1 1200000 4 1800000 4 1",
+    "1200000 1 1608000 1 1200000 4 1800000 4 1",
+    "1200000 1 1608000 1 1200000 4 1800000 4 1",
+    "1200000 1 1608000 1 1200000 4 1800000 4 1",
+};
+
+const char *roomage_a15[] = {
+    "0 0 1296000 2 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1608000 4 1200000 4 1800000 4 1",
+    "0 0 1296000 4 1200000 4 1800000 4 0",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1296000 4 1200000 4 1800000 4 1",
+    "0 0 1608000 4 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1296000 1 1200000 4 1800000 4 1",
+    "0 0 1608000 1 1200000 4 1800000 4 1",
+    "1200000 4 600000 1 1200000 4 1800000 4 0",
+    "1200000 4 600000 1 1200000 4 1800000 4 0",
+    "0 0 1296000 2 1200000 4 1800000 4 1",
+    "0 0 0 0 1200000 4 1800000 4 1",
+    "0 0 1296000 2 1200000 4 1800000 4 1",
+    "0 0 1296000 2 1200000 4 1800000 4 1",
+};
+#elif defined SUN8IW5P1
+const char *roomage_a7[] = {
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1200000 4 0 0 1",
+    "1008000 4 0 0 1200000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+    "1008000 4 0 0 1344000 4 0 0 1",
+};
+#elif defined SUN8IW6P1
+const char *roomage_a7[] = {
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1800000 1 1800000 0 2016000 4 2016000 4 0",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+    "1008000 1 1008000 0 2016000 4 2016000 4 1",
+};
+#endif
+
+int aw_init_boostup(int mode)
+{
+    if ((boost_up_dram_fd = open(AW_BOOST_UP_DRAM, O_RDWR)) < 0)
+        ERROR("cann't open %s!", AW_BOOST_UP_DRAM);
+
+    if ((boost_up_cpus_fd = open(AW_BOOST_UP_CPUS, O_RDWR)) < 0)
+        ERROR("cann't open %s!", AW_BOOST_UP_CPUS);
+
+    if ((boost_up_task_fd = open(AW_BOOST_UP_TASK, O_RDWR)) < 0)
+        ERROR("cann't open %s!", AW_BOOST_UP_TASK);
+
+    if ((boost_up_gpu_fd = open(AW_BOOST_UP_GPU, O_RDWR)) < 0)
+        ERROR("cann't open %s!", AW_BOOST_UP_GPU);
+
+    runmode = mode;
+    return 0;
+}
+
+static int aw_get_para(const char *value, int *pid, unsigned int *index)
+{
+    //value like: mode_xxx,pid,index
+    char buf[32];
+    int mPid = 0;
+    unsigned int mIndex = 0;
+    sscanf(value, "%s %d %d", buf, &mPid, &mIndex);
+    *pid = mPid;
+    *index = mIndex;
+    return 0;
+}
+
+/**
+ * mode_activity
+ * mode_rotation
+ * mode_extreme
+ * mode_bgmusic
+ * mode_home
+ * mode_localvideo
+ * mode_4klocalvideo
+ * mode_normal
+ * mode_debug
+ */
+int aw_boost_up_perf(const char *name, const char *value)
+{
+    int ret = 0;
+
+    if (!strncmp(name, "sys.boost_up_perf.mode", strlen("sys.boost_up_perf.mode"))) {
+        int pid = 0;
+        unsigned int index = 0;
+        aw_get_para(value, &pid, &index);
+
+        if (BOOST_UP_DEBUG)
+            ERROR("aw_boost_up_perf to set name:%s, value:%s, pid:%d, index:%d\n", name, value, pid,index);
+
+        if (!strncmp(value, "mode_", strlen("mode_"))) {
+            switch(value[5]) {
+                //cpu mode_activyty
+                case 'a':
+                    //cpu mode_rotation
+                case 'r':
+                    if (boost_up_cpus_fd > 0)
+                        ret = write(boost_up_cpus_fd, AW_BOOST_UP_CPUS_PERF, strlen(AW_BOOST_UP_CPUS_PERF));
+                    if (boost_up_dram_fd > 0)
+                        ret = write(boost_up_dram_fd, AW_BOOST_UP_DRAM_DEFAULT, strlen(AW_BOOST_UP_DRAM_DEFAULT));
+                    if (boost_up_gpu_fd > 0) {
+                        ret = write(boost_up_gpu_fd, AW_BOOST_UP_GPU_DEFAULT, strlen(AW_BOOST_UP_GPU_DEFAULT));
+                    }
+                    break;
+                    //cpu mode_extreme
+                case 'e':
+#ifdef SUN9IW1P1
+                    if (0xa15 == runmode) {
+                        if (index <= 0 || index > sizeof(roomage_a15)/sizeof(*roomage_a15))
+                            index = 1;
+                        if(boost_up_cpus_fd > 0)
+                            ret = write(boost_up_cpus_fd, roomage_a15[index-1], strlen(roomage_a15[index-1]));
+                    } else {
+#endif
+                        if (index <= 0 || (index > sizeof(roomage_a7) / sizeof(*roomage_a7)))
+                            index = 1;
+                        if (boost_up_cpus_fd > 0)
+                            ret = write(boost_up_cpus_fd, roomage_a7[index-1], strlen(roomage_a7[index-1]));
+#ifdef SUN9IW1P1
+                    }
+#endif
+                    if (boost_up_task_fd > 0 && pid > 0) {
+                        char buf[8];
+                        sprintf(buf, "%d", pid);
+                        write(boost_up_task_fd, buf, strlen(buf));
+                    }
+                    if (boost_up_dram_fd > 0)
+                        ret = write(boost_up_dram_fd, AW_BOOST_UP_DRAM_DEFAULT, strlen(AW_BOOST_UP_DRAM_DEFAULT));
+                    if (boost_up_gpu_fd > 0 && roomage_a7[index-1][strlen(roomage_a7[index-1])-1] == '1') {
+                        ret = write(boost_up_gpu_fd, AW_BOOST_UP_GPU_PERF, strlen(AW_BOOST_UP_GPU_PERF));
+                    }
+
+                    break;
+                    //dram mode_bgmusic
+                case 'b':
+                    if (boost_up_cpus_fd > 0)
+                        ret = write(boost_up_cpus_fd, AW_BOOST_UP_CPUS_NORMAL, strlen(AW_BOOST_UP_CPUS_NORMAL));
+                    if (boost_up_dram_fd > 0)
+                        ret = write(boost_up_dram_fd, AW_BOOST_UP_DRAM_BGMUSIC, strlen(AW_BOOST_UP_DRAM_BGMUSIC));
+                    if (boost_up_gpu_fd > 0) {
+                        ret = write(boost_up_gpu_fd, AW_BOOST_UP_GPU_BGMUSIC, strlen(AW_BOOST_UP_GPU_BGMUSIC));
+                    }
+
+                    break;
+                    //dram mode_home
+                case 'h':
+                    if (boost_up_cpus_fd > 0)
+                        ret = write(boost_up_cpus_fd, AW_BOOST_UP_CPUS_NORMAL, strlen(AW_BOOST_UP_CPUS_NORMAL));
+                    if (boost_up_dram_fd > 0)
+                        ret = write(boost_up_dram_fd, AW_BOOST_UP_DRAM_HOME, strlen(AW_BOOST_UP_DRAM_HOME));
+                    if (boost_up_gpu_fd > 0) {
+                        ret = write(boost_up_gpu_fd, AW_BOOST_UP_GPU_HOME, strlen(AW_BOOST_UP_GPU_HOME));
+                    }
+                    break;
+                    //dram mode_localvideo
+                case 'l':
+                    if (boost_up_cpus_fd > 0)
+                        ret = write(boost_up_cpus_fd, AW_BOOST_UP_CPUS_VIDEO, strlen(AW_BOOST_UP_CPUS_VIDEO));
+                    /*
+                    if (boost_up_dram_fd > 0)
+                        ret = write(boost_up_dram_fd, AW_BOOST_UP_DRAM_LOCALVIDEO, strlen(AW_BOOST_UP_DRAM_LOCALVIDEO));
+                    if (boost_up_gpu_fd > 0 && roomage_a7[index-1][strlen(roomage_a7[index-1])-1] == '1') {
+                        temp = AW_BOOST_UP_GPU_LOCALVIDEO;
+                        ret = write(boost_up_gpu_fd, AW_BOOST_UP_GPU_LOCALVIDEO, strlen(AW_BOOST_UP_GPU_LOCALVIDEO));
+                    }
+                    */
+                    break;
+                case '4':
+                    if(boost_up_cpus_fd > 0){
+                        ret = write(boost_up_cpus_fd, AW_BOOST_UP_CPUS_VIDEO, strlen(AW_BOOST_UP_CPUS_VIDEO));
+                    }
+                    /*
+                    if (boost_up_dram_fd > 0)
+                       ret = write(boost_up_dram_fd, AW_BOOST_UP_DRAM_4KLOCALVIDEO, strlen(AW_BOOST_UP_DRAM_4KLOCALVIDEO));
+                    if (boost_up_gpu_fd > 0 && roomage_a7[index-1][strlen(roomage_a7[index-1])-1] == '1') {
+                        ret = write(boost_up_gpu_fd, AW_BOOST_UP_GPU_LOCALVIDEO, strlen(AW_BOOST_UP_GPU_LOCALVIDEO));
+                    }
+                       */
+                    break;
+                    //cpu mode_normal
+                case 'n':
+                    if (boost_up_cpus_fd > 0)
+                        ret = write(boost_up_cpus_fd, AW_BOOST_UP_CPUS_NORMAL, strlen(AW_BOOST_UP_CPUS_NORMAL));
+                    //dram mode_default
+                    if (boost_up_dram_fd > 0)
+                        ret = write(boost_up_dram_fd, AW_BOOST_UP_DRAM_DEFAULT, strlen(AW_BOOST_UP_DRAM_DEFAULT));
+
+                    if (boost_up_gpu_fd > 0) {
+                        ret = write(boost_up_gpu_fd, AW_BOOST_UP_GPU_DEFAULT, strlen(AW_BOOST_UP_GPU_DEFAULT));
+                    }
+
+                    break;
+                case 'd':
+                    BOOST_UP_DEBUG = true;
+                    break;
+                default:
+                    ERROR("aw_boost_perf set invalid value:%s\n", value);
+                    break;
+            }
+        }
+        if (BOOST_UP_DEBUG)
+            ERROR("aw_boost_perf ret:%d, dram_fd:%d, cpus_fd:%d, task_fd:%d, gpu_fd:%d\n", ret, boost_up_dram_fd, boost_up_cpus_fd, boost_up_task_fd, boost_up_gpu_fd);
+    }
+
+    return 0;
+}
diff --git a/bootchart.c b/bootchart.c
new file mode 100644
index 0000000..f72fcaa
--- /dev/null
+++ b/bootchart.c
@@ -0,0 +1,378 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* this code is used to generate a boot sequence profile that can be used
+ * with the 'bootchart' graphics generation tool. see www.bootchart.org
+ * note that unlike the original bootchartd, this is not a Bash script but
+ * some C code that is run right from the init script.
+ */
+
+#include <stdio.h>
+#include <time.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include "bootchart.h"
+
+#define VERSION         "0.8"
+#define SAMPLE_PERIOD   0.2
+#define LOG_ROOT        "/data/bootchart"
+#define LOG_STAT        LOG_ROOT"/proc_stat.log"
+#define LOG_PROCS       LOG_ROOT"/proc_ps.log"
+#define LOG_DISK        LOG_ROOT"/proc_diskstats.log"
+#define LOG_HEADER      LOG_ROOT"/header"
+#define LOG_ACCT        LOG_ROOT"/kernel_pacct"
+
+#define LOG_STARTFILE   "/data/bootchart-start"
+#define LOG_STOPFILE    "/data/bootchart-stop"
+
+static int
+unix_read(int  fd, void*  buff, int  len)
+{
+    int  ret;
+    do { ret = read(fd, buff, len); } while (ret < 0 && errno == EINTR);
+    return ret;
+}
+
+static int
+unix_write(int  fd, const void*  buff, int  len)
+{
+    int  ret;
+    do { ret = write(fd, buff, len); } while (ret < 0 && errno == EINTR);
+    return ret;
+}
+
+static int
+proc_read(const char*  filename, char* buff, size_t  buffsize)
+{
+    int  len = 0;
+    int  fd  = open(filename, O_RDONLY);
+    if (fd >= 0) {
+        len = unix_read(fd, buff, buffsize-1);
+        close(fd);
+    }
+    buff[len > 0 ? len : 0] = 0;
+    return len;
+}
+
+#define FILE_BUFF_SIZE    65536
+
+typedef struct {
+    int   count;
+    int   fd;
+    char  data[FILE_BUFF_SIZE];
+} FileBuffRec, *FileBuff;
+
+static void
+file_buff_open( FileBuff  buff, const char*  path )
+{
+    buff->count = 0;
+    buff->fd    = open(path, O_WRONLY|O_CREAT|O_TRUNC, 0755);
+}
+
+static void
+file_buff_write( FileBuff  buff, const void*  src, int  len )
+{
+    while (len > 0) {
+        int  avail = sizeof(buff->data) - buff->count;
+        if (avail > len)
+            avail = len;
+
+        memcpy( buff->data + buff->count, src, avail );
+        len -= avail;
+        src  = (char*)src + avail;
+
+        buff->count += avail;
+        if (buff->count == FILE_BUFF_SIZE) {
+            unix_write( buff->fd, buff->data, buff->count );
+            buff->count = 0;
+        }
+    }
+}
+
+static void
+file_buff_done( FileBuff  buff )
+{
+    if (buff->count > 0) {
+        unix_write( buff->fd, buff->data, buff->count );
+        buff->count = 0;
+    }
+}
+
+static void
+log_header(void)
+{
+    FILE*      out;
+    char       cmdline[1024];
+    char       uname[128];
+    char       cpuinfo[128];
+    char*      cpu;
+    char       date[32];
+    time_t     now_t = time(NULL);
+    struct tm  now = *localtime(&now_t);
+    strftime(date, sizeof(date), "%x %X", &now);
+
+    out = fopen( LOG_HEADER, "w" );
+    if (out == NULL)
+        return;
+
+    proc_read("/proc/cmdline", cmdline, sizeof(cmdline));
+    proc_read("/proc/version", uname, sizeof(uname));
+    proc_read("/proc/cpuinfo", cpuinfo, sizeof(cpuinfo));
+
+    cpu = strchr( cpuinfo, ':' );
+    if (cpu) {
+        char*  p = strchr(cpu, '\n');
+        cpu += 2;
+        if (p)
+            *p = 0;
+    }
+
+    fprintf(out, "version = %s\n", VERSION);
+    fprintf(out, "title = Boot chart for Android ( %s )\n", date);
+    fprintf(out, "system.uname = %s\n", uname);
+    fprintf(out, "system.release = 0.0\n");
+    fprintf(out, "system.cpu = %s\n", cpu);
+    fprintf(out, "system.kernel.options = %s\n", cmdline);
+    fclose(out);
+}
+
+static void
+close_on_exec(int  fd)
+{
+    fcntl(fd, F_SETFD, FD_CLOEXEC);
+}
+
+static void
+open_log_file(int*  plogfd, const char*  logfile)
+{
+    int    logfd = *plogfd;
+
+    /* create log file if needed */
+    if (logfd < 0) 
+    {
+        logfd = open(logfile,O_WRONLY|O_CREAT|O_TRUNC,0755);
+        if (logfd < 0) {
+            *plogfd = -2;
+            return;
+        }
+        close_on_exec(logfd);
+        *plogfd = logfd;
+    }
+}
+
+static void
+do_log_uptime(FileBuff  log)
+{
+    char  buff[65];
+    int   fd, ret, len;
+
+    fd = open("/proc/uptime",O_RDONLY);
+    if (fd >= 0) {
+        int  ret;
+        ret = unix_read(fd, buff, 64);
+        close(fd);
+        buff[64] = 0;
+        if (ret >= 0) {
+            long long  jiffies = 100LL*strtod(buff,NULL);
+            int        len;
+            snprintf(buff,sizeof(buff),"%lld\n",jiffies);
+            len = strlen(buff);
+            file_buff_write(log, buff, len);
+        }
+    }
+}
+
+static void
+do_log_ln(FileBuff  log)
+{
+    file_buff_write(log, "\n", 1);
+}
+
+
+static void
+do_log_file(FileBuff  log, const char*  procfile)
+{
+    char   buff[1024];
+    int    fd;
+
+    do_log_uptime(log);
+
+    /* append file content */
+    fd = open(procfile,O_RDONLY);
+    if (fd >= 0) {
+        close_on_exec(fd);
+        for (;;) {
+            int  ret;
+            ret = unix_read(fd, buff, sizeof(buff));
+            if (ret <= 0)
+                break;
+
+            file_buff_write(log, buff, ret);
+            if (ret < (int)sizeof(buff))
+                break;
+        }
+        close(fd);
+    }
+
+    do_log_ln(log);
+}
+
+static void
+do_log_procs(FileBuff  log)
+{
+    DIR*  dir = opendir("/proc");
+    struct dirent*  entry;
+
+    do_log_uptime(log);
+
+    while ((entry = readdir(dir)) != NULL) {
+        /* only match numeric values */
+        char*  end;
+        int    pid = strtol( entry->d_name, &end, 10);
+        if (end != NULL && end > entry->d_name && *end == 0) {
+            char  filename[32];
+            char  buff[1024];
+            char  cmdline[1024];
+            int   len;
+            int   fd;
+
+            /* read command line and extract program name */
+            snprintf(filename,sizeof(filename),"/proc/%d/cmdline",pid);
+            proc_read(filename, cmdline, sizeof(cmdline));
+
+            /* read process stat line */
+            snprintf(filename,sizeof(filename),"/proc/%d/stat",pid);
+            fd = open(filename,O_RDONLY);
+            if (fd >= 0) {
+               len = unix_read(fd, buff, sizeof(buff)-1);
+               close(fd);
+               if (len > 0) {
+                    int  len2 = strlen(cmdline);
+                    if (len2 > 0) {
+                        /* we want to substitute the process name with its real name */
+                        const char*  p1;
+                        const char*  p2;
+                        buff[len] = 0;
+                        p1 = strchr(buff, '(');
+                        p2 = strchr(p1, ')');
+                        file_buff_write(log, buff, p1+1-buff);
+                        file_buff_write(log, cmdline, strlen(cmdline));
+                        file_buff_write(log, p2, strlen(p2));
+                    } else {
+                        /* no substitution */
+                        file_buff_write(log,buff,len);
+                    }
+               }
+            }
+        }
+    }
+    closedir(dir);
+    do_log_ln(log);
+}
+
+static FileBuffRec  log_stat[1];
+static FileBuffRec  log_procs[1];
+static FileBuffRec  log_disks[1];
+
+/* called to setup bootcharting */
+int   bootchart_init( void )
+{
+    int  ret;
+    char buff[4];
+    int  timeout = 0, count = 0;
+
+    buff[0] = 0;
+    proc_read( LOG_STARTFILE, buff, sizeof(buff) );
+    if (buff[0] != 0) {
+        timeout = atoi(buff);
+    }
+    else {
+        /* when running with emulator, androidboot.bootchart=<timeout>
+         * might be passed by as kernel parameters to specify the bootchart
+         * timeout. this is useful when using -wipe-data since the /data
+         * partition is fresh
+         */
+        char  cmdline[1024];
+        char* s;
+#define  KERNEL_OPTION  "androidboot.bootchart="
+        proc_read( "/proc/cmdline", cmdline, sizeof(cmdline) );
+        s = strstr(cmdline, KERNEL_OPTION);
+        if (s) {
+            s      += sizeof(KERNEL_OPTION)-1;
+            timeout = atoi(s);
+        }
+    }
+    if (timeout == 0)
+        return 0;
+
+    if (timeout > BOOTCHART_MAX_TIME_SEC)
+        timeout = BOOTCHART_MAX_TIME_SEC;
+
+    count = (timeout*1000 + BOOTCHART_POLLING_MS-1)/BOOTCHART_POLLING_MS;
+
+    do {ret=mkdir(LOG_ROOT,0755);}while (ret < 0 && errno == EINTR);
+
+    file_buff_open(log_stat,  LOG_STAT);
+    file_buff_open(log_procs, LOG_PROCS);
+    file_buff_open(log_disks, LOG_DISK);
+
+    /* create kernel process accounting file */
+    {
+        int  fd = open( LOG_ACCT, O_WRONLY|O_CREAT|O_TRUNC,0644);
+        if (fd >= 0) {
+            close(fd);
+            acct( LOG_ACCT );
+        }
+    }
+
+    log_header();
+    return count;
+}
+
+/* called each time you want to perform a bootchart sampling op */
+int  bootchart_step( void )
+{
+    do_log_file(log_stat,   "/proc/stat");
+    do_log_file(log_disks,  "/proc/diskstats");
+    do_log_procs(log_procs);
+
+    /* we stop when /data/bootchart-stop contains 1 */
+    {
+        char  buff[2];
+        if (proc_read(LOG_STOPFILE,buff,sizeof(buff)) > 0 && buff[0] == '1') {
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+void  bootchart_finish( void )
+{
+    unlink( LOG_STOPFILE );
+    file_buff_done(log_stat);
+    file_buff_done(log_disks);
+    file_buff_done(log_procs);
+    acct(NULL);
+}
diff --git a/bootchart.h b/bootchart.h
new file mode 100644
index 0000000..39d2d4f
--- /dev/null
+++ b/bootchart.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _BOOTCHART_H
+#define _BOOTCHART_H
+
+#ifndef BOOTCHART
+# define  BOOTCHART  0
+#endif
+
+#if BOOTCHART
+
+extern int   bootchart_init(void);
+extern int   bootchart_step(void);
+extern void  bootchart_finish(void);
+
+# define BOOTCHART_POLLING_MS   200   /* polling period in ms */
+# define BOOTCHART_DEFAULT_TIME_SEC    (2*60)  /* default polling time in seconds */
+# define BOOTCHART_MAX_TIME_SEC        (10*60) /* max polling time in seconds */
+
+#endif /* BOOTCHART */
+
+#endif /* _BOOTCHART_H */
diff --git a/builtins.c b/builtins.c
new file mode 100644
index 0000000..ceff228
--- /dev/null
+++ b/builtins.c
@@ -0,0 +1,1013 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <linux/kd.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <linux/if.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+#include <sys/mount.h>
+#include <sys/resource.h>
+#include <sys/wait.h>
+#include <linux/loop.h>
+#include <cutils/partition_utils.h>
+#include <cutils/android_reboot.h>
+#include <fs_mgr.h>
+
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+
+#include "init.h"
+#include "keywords.h"
+#include "property_service.h"
+#include "devices.h"
+#include "init_parser.h"
+#include "util.h"
+#include "log.h"
+
+#include <private/android_filesystem_config.h>
+
+int add_environment(const char *name, const char *value);
+
+extern int init_module(void *, unsigned long, const char *);
+
+static int write_file(const char *path, const char *value)
+{
+    int fd, ret, len;
+
+    fd = open(path, O_WRONLY|O_CREAT|O_NOFOLLOW, 0600);
+
+    if (fd < 0)
+        return -errno;
+
+    len = strlen(value);
+
+    do {
+        ret = write(fd, value, len);
+    } while (ret < 0 && errno == EINTR);
+
+    close(fd);
+    if (ret < 0) {
+        return -errno;
+    } else {
+        return 0;
+    }
+}
+
+static int _open(const char *path)
+{
+    int fd;
+
+    fd = open(path, O_RDONLY | O_NOFOLLOW);
+    if (fd < 0)
+        fd = open(path, O_WRONLY | O_NOFOLLOW);
+
+    return fd;
+}
+
+static int _chown(const char *path, unsigned int uid, unsigned int gid)
+{
+    int fd;
+    int ret;
+
+    fd = _open(path);
+    if (fd < 0) {
+        return -1;
+    }
+
+    ret = fchown(fd, uid, gid);
+    if (ret < 0) {
+        int errno_copy = errno;
+        close(fd);
+        errno = errno_copy;
+        return -1;
+    }
+
+    close(fd);
+
+    return 0;
+}
+
+static int _chmod(const char *path, mode_t mode)
+{
+    int fd;
+    int ret;
+
+    fd = _open(path);
+    if (fd < 0) {
+        return -1;
+    }
+
+    ret = fchmod(fd, mode);
+    if (ret < 0) {
+        int errno_copy = errno;
+        close(fd);
+        errno = errno_copy;
+        return -1;
+    }
+
+    close(fd);
+
+    return 0;
+}
+
+static int insmod(const char *filename, char *options)
+{
+    void *module;
+    unsigned size;
+    int ret;
+
+    module = read_file(filename, &size);
+    if (!module)
+        return -1;
+
+    ret = init_module(module, size, options);
+
+    free(module);
+
+    return ret;
+}
+
+static int setkey(struct kbentry *kbe)
+{
+    int fd, ret;
+
+    fd = open("/dev/tty0", O_RDWR | O_SYNC);
+    if (fd < 0)
+        return -1;
+
+    ret = ioctl(fd, KDSKBENT, kbe);
+
+    close(fd);
+    return ret;
+}
+
+static int __ifupdown(const char *interface, int up)
+{
+    struct ifreq ifr;
+    int s, ret;
+
+    strlcpy(ifr.ifr_name, interface, IFNAMSIZ);
+
+    s = socket(AF_INET, SOCK_DGRAM, 0);
+    if (s < 0)
+        return -1;
+
+    ret = ioctl(s, SIOCGIFFLAGS, &ifr);
+    if (ret < 0) {
+        goto done;
+    }
+
+    if (up)
+        ifr.ifr_flags |= IFF_UP;
+    else
+        ifr.ifr_flags &= ~IFF_UP;
+
+    ret = ioctl(s, SIOCSIFFLAGS, &ifr);
+    
+done:
+    close(s);
+    return ret;
+}
+
+static void service_start_if_not_disabled(struct service *svc)
+{
+    if (!(svc->flags & SVC_DISABLED)) {
+        service_start(svc, NULL);
+    } else {
+        svc->flags |= SVC_DISABLED_START;
+    }
+}
+
+int do_chdir(int nargs, char **args)
+{
+    chdir(args[1]);
+    return 0;
+}
+
+int do_chroot(int nargs, char **args)
+{
+    chroot(args[1]);
+    return 0;
+}
+
+int do_class_start(int nargs, char **args)
+{
+        /* Starting a class does not start services
+         * which are explicitly disabled.  They must
+         * be started individually.
+         */
+    service_for_each_class(args[1], service_start_if_not_disabled);
+    return 0;
+}
+
+int do_class_stop(int nargs, char **args)
+{
+    service_for_each_class(args[1], service_stop);
+    return 0;
+}
+
+int do_class_reset(int nargs, char **args)
+{
+    service_for_each_class(args[1], service_reset);
+    return 0;
+}
+
+int do_domainname(int nargs, char **args)
+{
+    return write_file("/proc/sys/kernel/domainname", args[1]);
+}
+
+int do_enable(int nargs, char **args)
+{
+    struct service *svc;
+    svc = service_find_by_name(args[1]);
+    if (svc) {
+        svc->flags &= ~(SVC_DISABLED | SVC_RC_DISABLED);
+        if (svc->flags & SVC_DISABLED_START) {
+            service_start(svc, NULL);
+        }
+    } else {
+        return -1;
+    }
+    return 0;
+}
+
+/* exec <path> <arg1> <arg2> ... */
+#define MAX_PARAMETERS 64
+int do_exec(int nargs, char **args)
+{
+    pid_t pid;
+    int status, i, j;
+    char *par[MAX_PARAMETERS];
+
+    if (nargs > MAX_PARAMETERS) {
+        return -1;
+    }
+
+    for(i=0, j=1; i<(nargs-1) ;i++,j++) {
+        par[i] = args[j];
+    }
+
+    par[i] = (char*)0;
+    pid = fork();
+    if (!pid)
+    {
+        char tmp[32];
+        int fd, sz;
+        get_property_workspace(&fd, &sz);
+        sprintf(tmp, "%d,%d", dup(fd), sz);
+        setenv("ANDROID_PROPERTY_WORKSPACE", tmp, 1);
+        execve(par[0],par,environ);
+        exit(0);
+    } else {
+        waitpid(pid, &status, 0);
+        if (WEXITSTATUS(status) != 0) {
+            ERROR("exec: pid %1d exited with return code %d: %s", (int)pid, WEXITSTATUS(status), strerror(status));
+        }
+    }
+
+    return 0;
+}
+
+int do_export(int nargs, char **args)
+{
+    return add_environment(args[1], args[2]);
+}
+
+int do_format_userdata(int nargs, char **args)
+{
+ERROR("-----------rogge---------------do_format_userdata");
+    const char * devicePath = args[1];
+    char bootsector[512];
+    int fd;
+    pid_t child;
+    int status;
+
+    property_set("ro.udisk.label", args[2]);
+    fd = open(devicePath, O_RDONLY);
+    if (fd <= 0) {
+        ERROR("open device error: %s", strerror(errno));
+        return 1;
+    }
+    memset(bootsector, 0, 512);
+    read(fd, bootsector, 512);
+    close(fd);
+    if ((bootsector[510]==0x55) && (bootsector[511]==0xaa)) {
+        ERROR("dont need format %s", devicePath);
+        return 1;
+    } else {
+ERROR("-----------rogge---------------start format");
+        INFO("start format %s", devicePath);
+        child = fork();
+        if (child == 0) {
+            INFO("fork to format %s", devicePath);
+            execl("/system/bin/logwrapper", "/system/bin/logwrapper", "/system/bin/newfs_msdos",
+                    "-F", "32", "-O", "android", "-c", "8", "-L", args[2], args[1], NULL);
+            exit(-1);
+        }
+        INFO("wait for format %s", devicePath);
+        while (waitpid(-1, &status, 0) != child);
+        INFO("format %s ok", devicePath);
+        return 1;
+    }
+}
+
+int do_hostname(int nargs, char **args)
+{
+    return write_file("/proc/sys/kernel/hostname", args[1]);
+}
+
+int do_ifup(int nargs, char **args)
+{
+    return __ifupdown(args[1], 1);
+}
+
+
+static int do_insmod_inner(int nargs, char **args, int opt_len)
+{
+    char options[opt_len + 1];
+    int i;
+
+    options[0] = '\0';
+    if (nargs > 2) {
+        strcpy(options, args[2]);
+        for (i = 3; i < nargs; ++i) {
+            strcat(options, " ");
+            strcat(options, args[i]);
+        }
+    }
+
+    return insmod(args[1], options);
+}
+
+int do_insmod(int nargs, char **args)
+{
+    int i;
+    int size = 0;
+
+    if (nargs > 2) {
+        for (i = 2; i < nargs; ++i)
+            size += strlen(args[i]) + 1;
+    }
+
+    return do_insmod_inner(nargs, args, size);
+}
+
+int do_mkdir(int nargs, char **args)
+{
+    mode_t mode = 0755;
+    int ret;
+
+    /* mkdir <path> [mode] [owner] [group] */
+
+    if (nargs >= 3) {
+        mode = strtoul(args[2], 0, 8);
+    }
+
+    ret = make_dir(args[1], mode);
+    /* chmod in case the directory already exists */
+    if (ret == -1 && errno == EEXIST) {
+        ret = _chmod(args[1], mode);
+    }
+    if (ret == -1) {
+        return -errno;
+    }
+
+    if (nargs >= 4) {
+        uid_t uid = decode_uid(args[3]);
+        gid_t gid = -1;
+
+        if (nargs == 5) {
+            gid = decode_uid(args[4]);
+        }
+
+        if (_chown(args[1], uid, gid) < 0) {
+            return -errno;
+        }
+
+        /* chown may have cleared S_ISUID and S_ISGID, chmod again */
+        if (mode & (S_ISUID | S_ISGID)) {
+            ret = _chmod(args[1], mode);
+            if (ret == -1) {
+                return -errno;
+            }
+        }
+    }
+
+    return 0;
+}
+
+static struct {
+    const char *name;
+    unsigned flag;
+} mount_flags[] = {
+    { "noatime",    MS_NOATIME },
+    { "noexec",     MS_NOEXEC },
+    { "nosuid",     MS_NOSUID },
+    { "nodev",      MS_NODEV },
+    { "nodiratime", MS_NODIRATIME },
+    { "ro",         MS_RDONLY },
+    { "rw",         0 },
+    { "remount",    MS_REMOUNT },
+    { "bind",       MS_BIND },
+    { "rec",        MS_REC },
+    { "unbindable", MS_UNBINDABLE },
+    { "private",    MS_PRIVATE },
+    { "slave",      MS_SLAVE },
+    { "shared",     MS_SHARED },
+    { "defaults",   0 },
+    { 0,            0 },
+};
+
+#define DATA_MNT_POINT "/data"
+
+/* mount <type> <device> <path> <flags ...> <options> */
+int do_mount(int nargs, char **args)
+{
+    char tmp[64];
+    char *source, *target, *system;
+    char *options = NULL;
+    unsigned flags = 0;
+    int n, i;
+    int wait = 0;
+
+    for (n = 4; n < nargs; n++) {
+        for (i = 0; mount_flags[i].name; i++) {
+            if (!strcmp(args[n], mount_flags[i].name)) {
+                flags |= mount_flags[i].flag;
+                break;
+            }
+        }
+
+        if (!mount_flags[i].name) {
+            if (!strcmp(args[n], "wait"))
+                wait = 1;
+            /* if our last argument isn't a flag, wolf it up as an option string */
+            else if (n + 1 == nargs)
+                options = args[n];
+        }
+    }
+
+    system = args[1];
+    source = args[2];
+    target = args[3];
+
+    if (!strncmp(source, "mtd@", 4)) {
+        n = mtd_name_to_number(source + 4);
+        if (n < 0) {
+            return -1;
+        }
+
+        sprintf(tmp, "/dev/block/mtdblock%d", n);
+
+        if (wait)
+            wait_for_file(tmp, COMMAND_RETRY_TIMEOUT);
+        if (mount(tmp, target, system, flags, options) < 0) {
+            return -1;
+        }
+
+        goto exit_success;
+    } else if (!strncmp(source, "loop@", 5)) {
+        int mode, loop, fd;
+        struct loop_info info;
+
+        mode = (flags & MS_RDONLY) ? O_RDONLY : O_RDWR;
+        fd = open(source + 5, mode);
+        if (fd < 0) {
+            return -1;
+        }
+
+        for (n = 0; ; n++) {
+            sprintf(tmp, "/dev/block/loop%d", n);
+            loop = open(tmp, mode);
+            if (loop < 0) {
+                return -1;
+            }
+
+            /* if it is a blank loop device */
+            if (ioctl(loop, LOOP_GET_STATUS, &info) < 0 && errno == ENXIO) {
+                /* if it becomes our loop device */
+                if (ioctl(loop, LOOP_SET_FD, fd) >= 0) {
+                    close(fd);
+
+                    if (mount(tmp, target, system, flags, options) < 0) {
+                        ioctl(loop, LOOP_CLR_FD, 0);
+                        close(loop);
+                        return -1;
+                    }
+
+                    close(loop);
+                    goto exit_success;
+                }
+            }
+
+            close(loop);
+        }
+
+        close(fd);
+        ERROR("out of loopback devices");
+        return -1;
+    } else {
+        if (wait)
+            wait_for_file(source, COMMAND_RETRY_TIMEOUT);
+        if (mount(source, target, system, flags, options) < 0) {
+            return -1;
+        }
+
+    }
+
+exit_success:
+    return 0;
+
+}
+
+static int wipe_data_via_recovery()
+{
+    mkdir("/cache/recovery", 0700);
+    int fd = open("/cache/recovery/command", O_RDWR|O_CREAT|O_TRUNC, 0600);
+    if (fd >= 0) {
+        write(fd, "--wipe_data\n", strlen("--wipe_data\n") + 1);
+        write(fd, "--reason=wipe_data_via_recovery\n", strlen("--reason=wipe_data_via_recovery\n") + 1);
+        close(fd);
+    } else {
+        ERROR("could not open /cache/recovery/command\n");
+        return -1;
+    }
+    android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
+    while (1) { pause(); }  // never reached
+}
+
+
+/*
+ * This function might request a reboot, in which case it will
+ * not return.
+ */
+int do_mount_all(int nargs, char **args)
+{
+    pid_t pid;
+    int ret = -1;
+    int child_ret = -1;
+    int status;
+    const char *prop;
+    struct fstab *fstab;
+
+    if (nargs != 2) {
+        return -1;
+    }
+
+    /*
+     * Call fs_mgr_mount_all() to mount all filesystems.  We fork(2) and
+     * do the call in the child to provide protection to the main init
+     * process if anything goes wrong (crash or memory leak), and wait for
+     * the child to finish in the parent.
+     */
+    pid = fork();
+    if (pid > 0) {
+        /* Parent.  Wait for the child to return */
+        int wp_ret = TEMP_FAILURE_RETRY(waitpid(pid, &status, 0));
+        if (wp_ret < 0) {
+            /* Unexpected error code. We will continue anyway. */
+            NOTICE("waitpid failed rc=%d, errno=%d\n", wp_ret, errno);
+        }
+
+        if (WIFEXITED(status)) {
+            ret = WEXITSTATUS(status);
+        } else {
+            ret = -1;
+        }
+    } else if (pid == 0) {
+        /* child, call fs_mgr_mount_all() */
+        klog_set_level(6);  /* So we can see what fs_mgr_mount_all() does */
+        fstab = fs_mgr_read_fstab(args[1]);
+        child_ret = fs_mgr_mount_all(fstab);
+        fs_mgr_free_fstab(fstab);
+        if (child_ret == -1) {
+            ERROR("fs_mgr_mount_all returned an error\n");
+        }
+        _exit(child_ret);
+    } else {
+        /* fork failed, return an error */
+        return -1;
+    }
+
+    if (ret == FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION) {
+        property_set("vold.decrypt", "trigger_encryption");
+    } else if (ret == FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED) {
+        property_set("ro.crypto.state", "encrypted");
+        property_set("vold.decrypt", "trigger_default_encryption");
+    } else if (ret == FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) {
+        property_set("ro.crypto.state", "unencrypted");
+        /* If fs_mgr determined this is an unencrypted device, then trigger
+         * that action.
+         */
+        action_for_each_trigger("nonencrypted", action_add_queue_tail);
+    } else if (ret == FS_MGR_MNTALL_DEV_NEEDS_RECOVERY) {
+        /* Setup a wipe via recovery, and reboot into recovery */
+        ERROR("fs_mgr_mount_all suggested recovery, so wiping data via recovery.\n");
+        ret = wipe_data_via_recovery();
+        /* If reboot worked, there is no return. */
+    } else if (ret > 0) {
+        ERROR("fs_mgr_mount_all returned unexpected error %d\n", ret);
+    }
+    /* else ... < 0: error */
+
+    return ret;
+}
+
+int do_swapon_all(int nargs, char **args)
+{
+    struct fstab *fstab;
+    int ret;
+
+    fstab = fs_mgr_read_fstab(args[1]);
+    ret = fs_mgr_swapon_all(fstab);
+    fs_mgr_free_fstab(fstab);
+
+    return ret;
+}
+
+int do_setcon(int nargs, char **args) {
+    if (is_selinux_enabled() <= 0)
+        return 0;
+    if (setcon(args[1]) < 0) {
+        return -errno;
+    }
+    return 0;
+}
+
+int do_setenforce(int nargs, char **args) {
+    if (is_selinux_enabled() <= 0)
+        return 0;
+    if (security_setenforce(atoi(args[1])) < 0) {
+        return -errno;
+    }
+    return 0;
+}
+
+int do_setkey(int nargs, char **args)
+{
+    struct kbentry kbe;
+    kbe.kb_table = strtoul(args[1], 0, 0);
+    kbe.kb_index = strtoul(args[2], 0, 0);
+    kbe.kb_value = strtoul(args[3], 0, 0);
+    return setkey(&kbe);
+}
+
+int do_setprop(int nargs, char **args)
+{
+    const char *name = args[1];
+    const char *value = args[2];
+    char prop_val[PROP_VALUE_MAX];
+    int ret;
+
+    ret = expand_props(prop_val, value, sizeof(prop_val));
+    if (ret) {
+        ERROR("cannot expand '%s' while assigning to '%s'\n", value, name);
+        return -EINVAL;
+    }
+    property_set(name, prop_val);
+    return 0;
+}
+
+int do_setrlimit(int nargs, char **args)
+{
+    struct rlimit limit;
+    int resource;
+    resource = atoi(args[1]);
+    limit.rlim_cur = atoi(args[2]);
+    limit.rlim_max = atoi(args[3]);
+    return setrlimit(resource, &limit);
+}
+
+int do_start(int nargs, char **args)
+{
+    struct service *svc;
+    svc = service_find_by_name(args[1]);
+    if (svc) {
+        service_start(svc, NULL);
+    }
+    return 0;
+}
+
+int do_stop(int nargs, char **args)
+{
+    struct service *svc;
+    svc = service_find_by_name(args[1]);
+    if (svc) {
+        service_stop(svc);
+    }
+    return 0;
+}
+
+int do_restart(int nargs, char **args)
+{
+    struct service *svc;
+    svc = service_find_by_name(args[1]);
+    if (svc) {
+        service_restart(svc);
+    }
+    return 0;
+}
+
+int do_powerctl(int nargs, char **args)
+{
+    char command[PROP_VALUE_MAX];
+    int res;
+    int len = 0;
+    int cmd = 0;
+    char *reboot_target;
+
+    res = expand_props(command, args[1], sizeof(command));
+    if (res) {
+        ERROR("powerctl: cannot expand '%s'\n", args[1]);
+        return -EINVAL;
+    }
+
+    if (strncmp(command, "shutdown", 8) == 0) {
+        cmd = ANDROID_RB_POWEROFF;
+        len = 8;
+    } else if (strncmp(command, "reboot", 6) == 0) {
+        cmd = ANDROID_RB_RESTART2;
+        len = 6;
+    } else {
+        ERROR("powerctl: unrecognized command '%s'\n", command);
+        return -EINVAL;
+    }
+
+    if (command[len] == ',') {
+        reboot_target = &command[len + 1];
+    } else if (command[len] == '\0') {
+        reboot_target = "";
+    } else {
+        ERROR("powerctl: unrecognized reboot target '%s'\n", &command[len]);
+        return -EINVAL;
+    }
+
+    return android_reboot(cmd, 0, reboot_target);
+}
+
+int do_trigger(int nargs, char **args)
+{
+    action_for_each_trigger(args[1], action_add_queue_tail);
+    return 0;
+}
+
+int do_symlink(int nargs, char **args)
+{
+    return symlink(args[1], args[2]);
+}
+
+int do_rm(int nargs, char **args)
+{
+    return unlink(args[1]);
+}
+
+int do_rmdir(int nargs, char **args)
+{
+    return rmdir(args[1]);
+}
+
+int do_sysclktz(int nargs, char **args)
+{
+    struct timezone tz;
+
+    if (nargs != 2)
+        return -1;
+
+    memset(&tz, 0, sizeof(tz));
+    tz.tz_minuteswest = atoi(args[1]);   
+    if (settimeofday(NULL, &tz))
+        return -1;
+    return 0;
+}
+
+int do_write(int nargs, char **args)
+{
+    const char *path = args[1];
+    const char *value = args[2];
+    char prop_val[PROP_VALUE_MAX];
+    int ret;
+
+    ret = expand_props(prop_val, value, sizeof(prop_val));
+    if (ret) {
+        ERROR("cannot expand '%s' while writing to '%s'\n", value, path);
+        return -EINVAL;
+    }
+    return write_file(path, prop_val);
+}
+
+int do_copy(int nargs, char **args)
+{
+    char *buffer = NULL;
+    int rc = 0;
+    int fd1 = -1, fd2 = -1;
+    struct stat info;
+    int brtw, brtr;
+    char *p;
+
+    if (nargs != 3)
+        return -1;
+
+    if (stat(args[1], &info) < 0) 
+        return -1;
+
+    if ((fd1 = open(args[1], O_RDONLY)) < 0) 
+        goto out_err;
+
+    if ((fd2 = open(args[2], O_WRONLY|O_CREAT|O_TRUNC, 0660)) < 0)
+        goto out_err;
+
+    if (!(buffer = malloc(info.st_size)))
+        goto out_err;
+
+    p = buffer;
+    brtr = info.st_size;
+    while(brtr) {
+        rc = read(fd1, p, brtr);
+        if (rc < 0)
+            goto out_err;
+        if (rc == 0)
+            break;
+        p += rc;
+        brtr -= rc;
+    }
+
+    p = buffer;
+    brtw = info.st_size;
+    while(brtw) {
+        rc = write(fd2, p, brtw);
+        if (rc < 0)
+            goto out_err;
+        if (rc == 0)
+            break;
+        p += rc;
+        brtw -= rc;
+    }
+
+    rc = 0;
+    goto out;
+out_err:
+    rc = -1;
+out:
+    if (buffer)
+        free(buffer);
+    if (fd1 >= 0)
+        close(fd1);
+    if (fd2 >= 0)
+        close(fd2);
+    return rc;
+}
+
+int do_chown(int nargs, char **args) {
+    /* GID is optional. */
+    if (nargs == 3) {
+        if (_chown(args[2], decode_uid(args[1]), -1) < 0)
+            return -errno;
+    } else if (nargs == 4) {
+        if (_chown(args[3], decode_uid(args[1]), decode_uid(args[2])) < 0)
+            return -errno;
+    } else {
+        return -1;
+    }
+    return 0;
+}
+
+static mode_t get_mode(const char *s) {
+    mode_t mode = 0;
+    while (*s) {
+        if (*s >= '0' && *s <= '7') {
+            mode = (mode<<3) | (*s-'0');
+        } else {
+            return -1;
+        }
+        s++;
+    }
+    return mode;
+}
+
+int do_chmod(int nargs, char **args) {
+    mode_t mode = get_mode(args[1]);
+    if (_chmod(args[2], mode) < 0) {
+        return -errno;
+    }
+    return 0;
+}
+
+int do_restorecon(int nargs, char **args) {
+    int i;
+    int ret = 0;
+
+    for (i = 1; i < nargs; i++) {
+        if (restorecon(args[i]) < 0)
+            ret = -errno;
+    }
+    return ret;
+}
+
+int do_restorecon_recursive(int nargs, char **args) {
+    int i;
+    int ret = 0;
+
+    for (i = 1; i < nargs; i++) {
+        if (restorecon_recursive(args[i]) < 0)
+            ret = -errno;
+    }
+    return ret;
+}
+
+int do_setsebool(int nargs, char **args) {
+    const char *name = args[1];
+    const char *value = args[2];
+    SELboolean b;
+    int ret;
+
+    if (is_selinux_enabled() <= 0)
+        return 0;
+
+    b.name = name;
+    if (!strcmp(value, "1") || !strcasecmp(value, "true") || !strcasecmp(value, "on"))
+        b.value = 1;
+    else if (!strcmp(value, "0") || !strcasecmp(value, "false") || !strcasecmp(value, "off"))
+        b.value = 0;
+    else {
+        ERROR("setsebool: invalid value %s\n", value);
+        return -EINVAL;
+    }
+
+    if (security_set_boolean_list(1, &b, 0) < 0) {
+        ret = -errno;
+        ERROR("setsebool: could not set %s to %s\n", name, value);
+        return ret;
+    }
+
+    return 0;
+}
+
+int do_loglevel(int nargs, char **args) {
+    int log_level;
+    char log_level_str[PROP_VALUE_MAX] = "";
+    if (nargs != 2) {
+        ERROR("loglevel: missing argument\n");
+        return -EINVAL;
+    }
+
+    if (expand_props(log_level_str, args[1], sizeof(log_level_str))) {
+        ERROR("loglevel: cannot expand '%s'\n", args[1]);
+        return -EINVAL;
+    }
+    log_level = atoi(log_level_str);
+    if (log_level < KLOG_ERROR_LEVEL || log_level > KLOG_DEBUG_LEVEL) {
+        ERROR("loglevel: invalid log level'%d'\n", log_level);
+        return -EINVAL;
+    }
+    klog_set_level(log_level);
+    return 0;
+}
+
+int do_load_persist_props(int nargs, char **args) {
+    if (nargs == 1) {
+        load_persist_props();
+        return 0;
+    }
+    return -1;
+}
+
+int do_load_all_props(int nargs, char **args) {
+    if (nargs == 1) {
+        load_all_props();
+        return 0;
+    }
+    return -1;
+}
+
+int do_wait(int nargs, char **args)
+{
+    if (nargs == 2) {
+        return wait_for_file(args[1], COMMAND_RETRY_TIMEOUT);
+    } else if (nargs == 3) {
+        return wait_for_file(args[1], atoi(args[2]));
+    } else
+        return -1;
+}
diff --git a/devices.c b/devices.c
new file mode 100644
index 0000000..1012fee
--- /dev/null
+++ b/devices.c
@@ -0,0 +1,1063 @@
+/*
+ * Copyright (C) 2007-2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fnmatch.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <fcntl.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <linux/netlink.h>
+
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+#include <selinux/android.h>
+#include <selinux/avc.h>
+
+#include <private/android_filesystem_config.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+
+#include <cutils/list.h>
+#include <cutils/uevent.h>
+
+#include "devices.h"
+#include "ueventd_parser.h"
+#include "util.h"
+#include "log.h"
+
+#define UNUSED __attribute__((__unused__))
+
+#define SYSFS_PREFIX    "/sys"
+#define FIRMWARE_DIR1   "/etc/firmware"
+#define FIRMWARE_DIR2   "/vendor/firmware"
+#define FIRMWARE_DIR3   "/firmware/image"
+
+extern struct selabel_handle *sehandle;
+
+static int device_fd = -1;
+
+struct uevent {
+    const char *action;
+    const char *path;
+    const char *subsystem;
+    const char *firmware;
+    const char *partition_name;
+    const char *device_name;
+    int partition_num;
+    int major;
+    int minor;
+};
+
+struct perms_ {
+    char *name;
+    char *attr;
+    mode_t perm;
+    unsigned int uid;
+    unsigned int gid;
+    unsigned short prefix;
+    unsigned short wildcard;
+};
+
+struct perm_node {
+    struct perms_ dp;
+    struct listnode plist;
+};
+
+struct platform_node {
+    char *name;
+    char *path;
+    int path_len;
+    struct listnode list;
+};
+
+static list_declare(sys_perms);
+static list_declare(dev_perms);
+static list_declare(platform_names);
+
+int add_dev_perms(const char *name, const char *attr,
+                  mode_t perm, unsigned int uid, unsigned int gid,
+                  unsigned short prefix,
+                  unsigned short wildcard) {
+    struct perm_node *node = calloc(1, sizeof(*node));
+    if (!node)
+        return -ENOMEM;
+
+    node->dp.name = strdup(name);
+    if (!node->dp.name)
+        return -ENOMEM;
+
+    if (attr) {
+        node->dp.attr = strdup(attr);
+        if (!node->dp.attr)
+            return -ENOMEM;
+    }
+
+    node->dp.perm = perm;
+    node->dp.uid = uid;
+    node->dp.gid = gid;
+    node->dp.prefix = prefix;
+    node->dp.wildcard = wildcard;
+
+    if (attr)
+        list_add_tail(&sys_perms, &node->plist);
+    else
+        list_add_tail(&dev_perms, &node->plist);
+
+    return 0;
+}
+
+void fixup_sys_perms(const char *upath)
+{
+    char buf[512];
+    struct listnode *node;
+    struct perms_ *dp;
+
+    /* upaths omit the "/sys" that paths in this list
+     * contain, so we add 4 when comparing...
+     */
+    list_for_each(node, &sys_perms) {
+        dp = &(node_to_item(node, struct perm_node, plist))->dp;
+        if (dp->prefix) {
+            if (strncmp(upath, dp->name + 4, strlen(dp->name + 4)))
+                continue;
+        } else if (dp->wildcard) {
+            if (fnmatch(dp->name + 4, upath, FNM_PATHNAME) != 0)
+                continue;
+        } else {
+            if (strcmp(upath, dp->name + 4))
+                continue;
+        }
+
+        if ((strlen(upath) + strlen(dp->attr) + 6) > sizeof(buf))
+            break;
+
+        sprintf(buf,"/sys%s/%s", upath, dp->attr);
+        INFO("fixup %s %d %d 0%o\n", buf, dp->uid, dp->gid, dp->perm);
+        chown(buf, dp->uid, dp->gid);
+        chmod(buf, dp->perm);
+    }
+
+    // Now fixup SELinux file labels
+    int len = snprintf(buf, sizeof(buf), "/sys%s", upath);
+    if ((len < 0) || ((size_t) len >= sizeof(buf))) {
+        // Overflow
+        return;
+    }
+    if (access(buf, F_OK) == 0) {
+        INFO("restorecon_recursive: %s\n", buf);
+        restorecon_recursive(buf);
+    }
+}
+
+static bool perm_path_matches(const char *path, struct perms_ *dp)
+{
+    if (dp->prefix) {
+        if (strncmp(path, dp->name, strlen(dp->name)) == 0)
+            return true;
+    } else if (dp->wildcard) {
+        if (fnmatch(dp->name, path, FNM_PATHNAME) == 0)
+            return true;
+    } else {
+        if (strcmp(path, dp->name) == 0)
+            return true;
+    }
+
+    return false;
+}
+
+static mode_t get_device_perm(const char *path, const char **links,
+                unsigned *uid, unsigned *gid)
+{
+    mode_t perm;
+    struct listnode *node;
+    struct perm_node *perm_node;
+    struct perms_ *dp;
+
+    /* search the perms list in reverse so that ueventd.$hardware can
+     * override ueventd.rc
+     */
+    list_for_each_reverse(node, &dev_perms) {
+        bool match = false;
+
+        perm_node = node_to_item(node, struct perm_node, plist);
+        dp = &perm_node->dp;
+
+        if (perm_path_matches(path, dp)) {
+            match = true;
+        } else {
+            if (links) {
+                int i;
+                for (i = 0; links[i]; i++) {
+                    if (perm_path_matches(links[i], dp)) {
+                        match = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (match) {
+            *uid = dp->uid;
+            *gid = dp->gid;
+            return dp->perm;
+        }
+    }
+    /* Default if nothing found. */
+    *uid = 0;
+    *gid = 0;
+    return 0600;
+}
+
+static void make_device(const char *path,
+                        const char *upath UNUSED,
+                        int block, int major, int minor,
+                        const char **links)
+{
+    unsigned uid;
+    unsigned gid;
+    mode_t mode;
+    dev_t dev;
+    char *secontext = NULL;
+
+    mode = get_device_perm(path, links, &uid, &gid) | (block ? S_IFBLK : S_IFCHR);
+
+    if (sehandle) {
+        selabel_lookup_best_match(sehandle, &secontext, path, links, mode);
+        setfscreatecon(secontext);
+    }
+
+    dev = makedev(major, minor);
+    /* Temporarily change egid to avoid race condition setting the gid of the
+     * device node. Unforunately changing the euid would prevent creation of
+     * some device nodes, so the uid has to be set with chown() and is still
+     * racy. Fixing the gid race at least fixed the issue with system_server
+     * opening dynamic input devices under the AID_INPUT gid. */
+    setegid(gid);
+    mknod(path, mode, dev);
+    chown(path, uid, -1);
+    setegid(AID_ROOT);
+
+    if (secontext) {
+        freecon(secontext);
+        setfscreatecon(NULL);
+    }
+}
+
+static void add_platform_device(const char *path)
+{
+    int path_len = strlen(path);
+    struct listnode *node;
+    struct platform_node *bus;
+    const char *name = path;
+
+    if (!strncmp(path, "/devices/", 9)) {
+        name += 9;
+        if (!strncmp(name, "platform/", 9))
+            name += 9;
+    }
+
+    list_for_each_reverse(node, &platform_names) {
+        bus = node_to_item(node, struct platform_node, list);
+        if ((bus->path_len < path_len) &&
+                (path[bus->path_len] == '/') &&
+                !strncmp(path, bus->path, bus->path_len))
+            /* subdevice of an existing platform, ignore it */
+            return;
+    }
+
+    INFO("adding platform device %s (%s)\n", name, path);
+
+    bus = calloc(1, sizeof(struct platform_node));
+    bus->path = strdup(path);
+    bus->path_len = path_len;
+    bus->name = bus->path + (name - path);
+    list_add_tail(&platform_names, &bus->list);
+}
+
+/*
+ * given a path that may start with a platform device, find the length of the
+ * platform device prefix.  If it doesn't start with a platform device, return
+ * 0.
+ */
+static struct platform_node *find_platform_device(const char *path)
+{
+    int path_len = strlen(path);
+    struct listnode *node;
+    struct platform_node *bus;
+
+    list_for_each_reverse(node, &platform_names) {
+        bus = node_to_item(node, struct platform_node, list);
+        if ((bus->path_len < path_len) &&
+                (path[bus->path_len] == '/') &&
+                !strncmp(path, bus->path, bus->path_len))
+            return bus;
+    }
+
+    return NULL;
+}
+
+static void remove_platform_device(const char *path)
+{
+    struct listnode *node;
+    struct platform_node *bus;
+
+    list_for_each_reverse(node, &platform_names) {
+        bus = node_to_item(node, struct platform_node, list);
+        if (!strcmp(path, bus->path)) {
+            INFO("removing platform device %s\n", bus->name);
+            free(bus->path);
+            list_remove(node);
+            free(bus);
+            return;
+        }
+    }
+}
+
+/* Given a path that may start with a PCI device, populate the supplied buffer
+ * with the PCI domain/bus number and the peripheral ID and return 0.
+ * If it doesn't start with a PCI device, or there is some error, return -1 */
+static int find_pci_device_prefix(const char *path, char *buf, ssize_t buf_sz)
+{
+    const char *start, *end;
+
+    if (strncmp(path, "/devices/pci", 12))
+        return -1;
+
+    /* Beginning of the prefix is the initial "pci" after "/devices/" */
+    start = path + 9;
+
+    /* End of the prefix is two path '/' later, capturing the domain/bus number
+     * and the peripheral ID. Example: pci0000:00/0000:00:1f.2 */
+    end = strchr(start, '/');
+    if (!end)
+        return -1;
+    end = strchr(end + 1, '/');
+    if (!end)
+        return -1;
+
+    /* Make sure we have enough room for the string plus null terminator */
+    if (end - start + 1 > buf_sz)
+        return -1;
+
+    strncpy(buf, start, end - start);
+    buf[end - start] = '\0';
+    return 0;
+}
+
+#if LOG_UEVENTS
+
+static inline suseconds_t get_usecs(void)
+{
+    struct timeval tv;
+    gettimeofday(&tv, 0);
+    return tv.tv_sec * (suseconds_t) 1000000 + tv.tv_usec;
+}
+
+#define log_event_print(x...) INFO(x)
+
+#else
+
+#define log_event_print(fmt, args...)   do { } while (0)
+#define get_usecs()                     0
+
+#endif
+
+static void parse_event(const char *msg, struct uevent *uevent)
+{
+    uevent->action = "";
+    uevent->path = "";
+    uevent->subsystem = "";
+    uevent->firmware = "";
+    uevent->major = -1;
+    uevent->minor = -1;
+    uevent->partition_name = NULL;
+    uevent->partition_num = -1;
+    uevent->device_name = NULL;
+
+        /* currently ignoring SEQNUM */
+    while(*msg) {
+        if(!strncmp(msg, "ACTION=", 7)) {
+            msg += 7;
+            uevent->action = msg;
+        } else if(!strncmp(msg, "DEVPATH=", 8)) {
+            msg += 8;
+            uevent->path = msg;
+        } else if(!strncmp(msg, "SUBSYSTEM=", 10)) {
+            msg += 10;
+            uevent->subsystem = msg;
+        } else if(!strncmp(msg, "FIRMWARE=", 9)) {
+            msg += 9;
+            uevent->firmware = msg;
+        } else if(!strncmp(msg, "MAJOR=", 6)) {
+            msg += 6;
+            uevent->major = atoi(msg);
+        } else if(!strncmp(msg, "MINOR=", 6)) {
+            msg += 6;
+            uevent->minor = atoi(msg);
+        } else if(!strncmp(msg, "PARTN=", 6)) {
+            msg += 6;
+            uevent->partition_num = atoi(msg);
+        } else if(!strncmp(msg, "PARTNAME=", 9)) {
+            msg += 9;
+            uevent->partition_name = msg;
+        } else if(!strncmp(msg, "DEVNAME=", 8)) {
+            msg += 8;
+            uevent->device_name = msg;
+        }
+
+        /* advance to after the next \0 */
+        while(*msg++)
+            ;
+    }
+
+    log_event_print("event { '%s', '%s', '%s', '%s', %d, %d }\n",
+                    uevent->action, uevent->path, uevent->subsystem,
+                    uevent->firmware, uevent->major, uevent->minor);
+}
+
+static char **get_character_device_symlinks(struct uevent *uevent)
+{
+    const char *parent;
+    char *slash;
+    char **links;
+    int link_num = 0;
+    int width;
+    struct platform_node *pdev;
+
+    pdev = find_platform_device(uevent->path);
+    if (!pdev)
+        return NULL;
+
+    links = malloc(sizeof(char *) * 2);
+    if (!links)
+        return NULL;
+    memset(links, 0, sizeof(char *) * 2);
+
+    /* skip "/devices/platform/<driver>" */
+    parent = strchr(uevent->path + pdev->path_len, '/');
+    if (!*parent)
+        goto err;
+
+    if (!strncmp(parent, "/usb", 4)) {
+        /* skip root hub name and device. use device interface */
+        while (*++parent && *parent != '/');
+        if (*parent)
+            while (*++parent && *parent != '/');
+        if (!*parent)
+            goto err;
+        slash = strchr(++parent, '/');
+        if (!slash)
+            goto err;
+        width = slash - parent;
+        if (width <= 0)
+            goto err;
+
+        if (asprintf(&links[link_num], "/dev/usb/%s%.*s", uevent->subsystem, width, parent) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+        mkdir("/dev/usb", 0755);
+    }
+    else {
+        goto err;
+    }
+
+    return links;
+err:
+    free(links);
+    return NULL;
+}
+
+static char **get_block_device_symlinks(struct uevent *uevent)
+{
+    const char *device;
+    struct platform_node *pdev;
+    char *slash;
+    const char *type;
+    int width;
+    char buf[256];
+    char link_path[256];
+    int fd;
+    int link_num = 0;
+    int ret;
+    char *p;
+    unsigned int size;
+    struct stat info;
+
+    pdev = find_platform_device(uevent->path);
+    if (pdev) {
+        device = pdev->name;
+        type = "platform";
+    } else if (!find_pci_device_prefix(uevent->path, buf, sizeof(buf))) {
+        device = buf;
+        type = "pci";
+    } else {
+        return NULL;
+    }
+
+    char **links = malloc(sizeof(char *) * 4);
+    if (!links)
+        return NULL;
+    memset(links, 0, sizeof(char *) * 4);
+
+    INFO("found %s device %s\n", type, device);
+
+    snprintf(link_path, sizeof(link_path), "/dev/block/%s/%s", type, device);
+
+    if (uevent->partition_name) {
+        p = strdup(uevent->partition_name);
+        sanitize(p);
+        if (strcmp(uevent->partition_name, p))
+            NOTICE("Linking partition '%s' as '%s'\n", uevent->partition_name, p);
+        if (asprintf(&links[link_num], "%s/by-name/%s", link_path, p) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+        free(p);
+    }
+
+    if (uevent->partition_num >= 0) {
+        if (asprintf(&links[link_num], "%s/by-num/p%d", link_path, uevent->partition_num) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+    }
+
+    slash = strrchr(uevent->path, '/');
+    if (asprintf(&links[link_num], "%s/%s", link_path, slash + 1) > 0)
+        link_num++;
+    else
+        links[link_num] = NULL;
+
+    return links;
+}
+
+static void handle_device(const char *action, const char *devpath,
+        const char *path, int block, int major, int minor, char **links)
+{
+    int i;
+
+    if(!strcmp(action, "add")) {
+        make_device(devpath, path, block, major, minor, (const char **)links);
+        if (links) {
+            for (i = 0; links[i]; i++)
+                make_link(devpath, links[i]);
+        }
+    }
+
+    if(!strcmp(action, "remove")) {
+        if (links) {
+            for (i = 0; links[i]; i++)
+                remove_link(devpath, links[i]);
+        }
+        unlink(devpath);
+    }
+
+    if (links) {
+        for (i = 0; links[i]; i++)
+            free(links[i]);
+        free(links);
+    }
+}
+
+static void handle_platform_device_event(struct uevent *uevent)
+{
+    const char *path = uevent->path;
+
+    if (!strcmp(uevent->action, "add"))
+        add_platform_device(path);
+    else if (!strcmp(uevent->action, "remove"))
+        remove_platform_device(path);
+}
+
+static const char *parse_device_name(struct uevent *uevent, unsigned int len)
+{
+    const char *name;
+
+    /* if it's not a /dev device, nothing else to do */
+    if((uevent->major < 0) || (uevent->minor < 0))
+        return NULL;
+
+    /* do we have a name? */
+    name = strrchr(uevent->path, '/');
+    if(!name)
+        return NULL;
+    name++;
+
+    /* too-long names would overrun our buffer */
+    if(strlen(name) > len) {
+        ERROR("DEVPATH=%s exceeds %u-character limit on filename; ignoring event\n",
+                name, len);
+        return NULL;
+    }
+
+    return name;
+}
+
+static void handle_block_device_event(struct uevent *uevent)
+{
+    const char *base = "/dev/block/";
+    const char *name;
+    char devpath[96];
+    char **links = NULL;
+
+    name = parse_device_name(uevent, 64);
+    if (!name)
+        return;
+
+    snprintf(devpath, sizeof(devpath), "%s%s", base, name);
+    make_dir(base, 0755);
+
+    if (!strncmp(uevent->path, "/devices/", 9))
+        links = get_block_device_symlinks(uevent);
+
+    handle_device(uevent->action, devpath, uevent->path, 1,
+            uevent->major, uevent->minor, links);
+}
+
+#define DEVPATH_LEN 96
+
+static bool assemble_devpath(char *devpath, const char *dirname,
+        const char *devname)
+{
+    int s = snprintf(devpath, DEVPATH_LEN, "%s/%s", dirname, devname);
+    if (s < 0) {
+        ERROR("failed to assemble device path (%s); ignoring event\n",
+                strerror(errno));
+        return false;
+    } else if (s >= DEVPATH_LEN) {
+        ERROR("%s/%s exceeds %u-character limit on path; ignoring event\n",
+                dirname, devname, DEVPATH_LEN);
+        return false;
+    }
+    return true;
+}
+
+static void mkdir_recursive_for_devpath(const char *devpath)
+{
+    char dir[DEVPATH_LEN];
+    char *slash;
+
+    strcpy(dir, devpath);
+    slash = strrchr(dir, '/');
+    *slash = '\0';
+    mkdir_recursive(dir, 0755);
+}
+
+static inline void __attribute__((__deprecated__)) kernel_logger()
+{
+    INFO("kernel logger is deprecated\n");
+}
+
+static void handle_generic_device_event(struct uevent *uevent)
+{
+    char *base;
+    const char *name;
+    char devpath[DEVPATH_LEN] = {0};
+    char **links = NULL;
+
+    name = parse_device_name(uevent, 64);
+    if (!name)
+        return;
+
+    struct ueventd_subsystem *subsystem =
+            ueventd_subsystem_find_by_name(uevent->subsystem);
+
+    if (subsystem) {
+        const char *devname;
+
+        switch (subsystem->devname_src) {
+        case DEVNAME_UEVENT_DEVNAME:
+            devname = uevent->device_name;
+            break;
+
+        case DEVNAME_UEVENT_DEVPATH:
+            devname = name;
+            break;
+
+        default:
+            ERROR("%s subsystem's devpath option is not set; ignoring event\n",
+                    uevent->subsystem);
+            return;
+        }
+
+        if (!assemble_devpath(devpath, subsystem->dirname, devname))
+            return;
+        mkdir_recursive_for_devpath(devpath);
+    } else if (!strncmp(uevent->subsystem, "usb", 3)) {
+         if (!strcmp(uevent->subsystem, "usb")) {
+            if (uevent->device_name) {
+                if (!assemble_devpath(devpath, "/dev", uevent->device_name))
+                    return;
+                mkdir_recursive_for_devpath(devpath);
+             }
+             else {
+                 /* This imitates the file system that would be created
+                  * if we were using devfs instead.
+                  * Minors are broken up into groups of 128, starting at "001"
+                  */
+                 int bus_id = uevent->minor / 128 + 1;
+                 int device_id = uevent->minor % 128 + 1;
+                 /* build directories */
+                 make_dir("/dev/bus", 0755);
+                 make_dir("/dev/bus/usb", 0755);
+                 snprintf(devpath, sizeof(devpath), "/dev/bus/usb/%03d", bus_id);
+                 make_dir(devpath, 0755);
+                 snprintf(devpath, sizeof(devpath), "/dev/bus/usb/%03d/%03d", bus_id, device_id);
+             }
+         } else {
+             /* ignore other USB events */
+             return;
+         }
+     } else if (!strncmp(uevent->subsystem, "graphics", 8)) {
+         base = "/dev/graphics/";
+         make_dir(base, 0755);
+     } else if (!strncmp(uevent->subsystem, "drm", 3)) {
+         base = "/dev/dri/";
+         make_dir(base, 0755);
+     } else if (!strncmp(uevent->subsystem, "oncrpc", 6)) {
+         base = "/dev/oncrpc/";
+         make_dir(base, 0755);
+     } else if (!strncmp(uevent->subsystem, "adsp", 4)) {
+         base = "/dev/adsp/";
+         make_dir(base, 0755);
+     } else if (!strncmp(uevent->subsystem, "msm_camera", 10)) {
+         base = "/dev/msm_camera/";
+         make_dir(base, 0755);
+     } else if(!strncmp(uevent->subsystem, "input", 5)) {
+         base = "/dev/input/";
+         make_dir(base, 0755);
+     } else if(!strncmp(uevent->subsystem, "mtd", 3)) {
+         base = "/dev/mtd/";
+         make_dir(base, 0755);
+     } else if(!strncmp(uevent->subsystem, "sound", 5)) {
+         base = "/dev/snd/";
+         make_dir(base, 0755);
+     } else if(!strncmp(uevent->subsystem, "misc", 4) &&
+                 !strncmp(name, "log_", 4)) {
+         kernel_logger();
+         base = "/dev/log/";
+         make_dir(base, 0755);
+         name += 4;
+     } else
+         base = "/dev/";
+     links = get_character_device_symlinks(uevent);
+
+     if (!devpath[0])
+         snprintf(devpath, sizeof(devpath), "%s%s", base, name);
+
+     handle_device(uevent->action, devpath, uevent->path, 0,
+             uevent->major, uevent->minor, links);
+}
+
+static void handle_device_event(struct uevent *uevent)
+{
+    if (!strcmp(uevent->action,"add") || !strcmp(uevent->action, "change") || !strcmp(uevent->action, "online"))
+        fixup_sys_perms(uevent->path);
+
+    if (!strncmp(uevent->subsystem, "block", 5)) {
+        handle_block_device_event(uevent);
+    } else if (!strncmp(uevent->subsystem, "platform", 8)) {
+        handle_platform_device_event(uevent);
+    } else {
+        handle_generic_device_event(uevent);
+    }
+}
+
+static int load_firmware(int fw_fd, int loading_fd, int data_fd)
+{
+    struct stat st;
+    long len_to_copy;
+    int ret = 0;
+
+    if(fstat(fw_fd, &st) < 0)
+        return -1;
+    len_to_copy = st.st_size;
+
+    write(loading_fd, "1", 1);  /* start transfer */
+
+    while (len_to_copy > 0) {
+        char buf[PAGE_SIZE];
+        ssize_t nr;
+
+        nr = read(fw_fd, buf, sizeof(buf));
+        if(!nr)
+            break;
+        if(nr < 0) {
+            ret = -1;
+            break;
+        }
+
+        len_to_copy -= nr;
+        while (nr > 0) {
+            ssize_t nw = 0;
+
+            nw = write(data_fd, buf + nw, nr);
+            if(nw <= 0) {
+                ret = -1;
+                goto out;
+            }
+            nr -= nw;
+        }
+    }
+
+out:
+    if(!ret)
+        write(loading_fd, "0", 1);  /* successful end of transfer */
+    else
+        write(loading_fd, "-1", 2); /* abort transfer */
+
+    return ret;
+}
+
+static int is_booting(void)
+{
+    return access("/dev/.booting", F_OK) == 0;
+}
+
+static void process_firmware_event(struct uevent *uevent)
+{
+    char *root, *loading, *data, *file1 = NULL, *file2 = NULL, *file3 = NULL;
+    int l, loading_fd, data_fd, fw_fd;
+    int booting = is_booting();
+
+    INFO("firmware: loading '%s' for '%s'\n",
+         uevent->firmware, uevent->path);
+
+    l = asprintf(&root, SYSFS_PREFIX"%s/", uevent->path);
+    if (l == -1)
+        return;
+
+    l = asprintf(&loading, "%sloading", root);
+    if (l == -1)
+        goto root_free_out;
+
+    l = asprintf(&data, "%sdata", root);
+    if (l == -1)
+        goto loading_free_out;
+
+    l = asprintf(&file1, FIRMWARE_DIR1"/%s", uevent->firmware);
+    if (l == -1)
+        goto data_free_out;
+
+    l = asprintf(&file2, FIRMWARE_DIR2"/%s", uevent->firmware);
+    if (l == -1)
+        goto data_free_out;
+
+    l = asprintf(&file3, FIRMWARE_DIR3"/%s", uevent->firmware);
+    if (l == -1)
+        goto data_free_out;
+
+    loading_fd = open(loading, O_WRONLY);
+    if(loading_fd < 0)
+        goto file_free_out;
+
+    data_fd = open(data, O_WRONLY);
+    if(data_fd < 0)
+        goto loading_close_out;
+
+try_loading_again:
+    fw_fd = open(file1, O_RDONLY);
+    if(fw_fd < 0) {
+        fw_fd = open(file2, O_RDONLY);
+        if (fw_fd < 0) {
+            fw_fd = open(file3, O_RDONLY);
+            if (fw_fd < 0) {
+                if (booting) {
+                        /* If we're not fully booted, we may be missing
+                         * filesystems needed for firmware, wait and retry.
+                         */
+                    usleep(100000);
+                    booting = is_booting();
+                    goto try_loading_again;
+                }
+                INFO("firmware: could not open '%s' %d\n", uevent->firmware, errno);
+                write(loading_fd, "-1", 2);
+                goto data_close_out;
+            }
+        }
+    }
+
+    if(!load_firmware(fw_fd, loading_fd, data_fd))
+        INFO("firmware: copy success { '%s', '%s' }\n", root, uevent->firmware);
+    else
+        INFO("firmware: copy failure { '%s', '%s' }\n", root, uevent->firmware);
+
+    close(fw_fd);
+data_close_out:
+    close(data_fd);
+loading_close_out:
+    close(loading_fd);
+file_free_out:
+    free(file1);
+    free(file2);
+    free(file3);
+data_free_out:
+    free(data);
+loading_free_out:
+    free(loading);
+root_free_out:
+    free(root);
+}
+
+static void handle_firmware_event(struct uevent *uevent)
+{
+    pid_t pid;
+    int ret;
+
+    if(strcmp(uevent->subsystem, "firmware"))
+        return;
+
+    if(strcmp(uevent->action, "add"))
+        return;
+
+    /* we fork, to avoid making large memory allocations in init proper */
+    pid = fork();
+    if (!pid) {
+        process_firmware_event(uevent);
+        exit(EXIT_SUCCESS);
+    }
+}
+
+#define UEVENT_MSG_LEN  2048
+void handle_device_fd()
+{
+    char msg[UEVENT_MSG_LEN+2];
+    int n;
+    while ((n = uevent_kernel_multicast_recv(device_fd, msg, UEVENT_MSG_LEN)) > 0) {
+        if(n >= UEVENT_MSG_LEN)   /* overflow -- discard */
+            continue;
+
+        msg[n] = '\0';
+        msg[n+1] = '\0';
+
+        struct uevent uevent;
+        parse_event(msg, &uevent);
+
+        if (sehandle && selinux_status_updated() > 0) {
+            struct selabel_handle *sehandle2;
+            sehandle2 = selinux_android_file_context_handle();
+            if (sehandle2) {
+                selabel_close(sehandle);
+                sehandle = sehandle2;
+            }
+        }
+
+        handle_device_event(&uevent);
+        handle_firmware_event(&uevent);
+    }
+}
+
+/* Coldboot walks parts of the /sys tree and pokes the uevent files
+** to cause the kernel to regenerate device add events that happened
+** before init's device manager was started
+**
+** We drain any pending events from the netlink socket every time
+** we poke another uevent file to make sure we don't overrun the
+** socket's buffer.  
+*/
+
+static void do_coldboot(DIR *d)
+{
+    struct dirent *de;
+    int dfd, fd;
+
+    dfd = dirfd(d);
+
+    fd = openat(dfd, "uevent", O_WRONLY);
+    if(fd >= 0) {
+        write(fd, "add\n", 4);
+        close(fd);
+        handle_device_fd();
+    }
+
+    while((de = readdir(d))) {
+        DIR *d2;
+
+        if(de->d_type != DT_DIR || de->d_name[0] == '.')
+            continue;
+
+        fd = openat(dfd, de->d_name, O_RDONLY | O_DIRECTORY);
+        if(fd < 0)
+            continue;
+
+        d2 = fdopendir(fd);
+        if(d2 == 0)
+            close(fd);
+        else {
+            do_coldboot(d2);
+            closedir(d2);
+        }
+    }
+}
+
+static void coldboot(const char *path)
+{
+    DIR *d = opendir(path);
+    if(d) {
+        do_coldboot(d);
+        closedir(d);
+    }
+}
+
+void device_init(void)
+{
+    suseconds_t t0, t1;
+    struct stat info;
+    int fd;
+
+    sehandle = NULL;
+    if (is_selinux_enabled() > 0) {
+        sehandle = selinux_android_file_context_handle();
+        selinux_status_open(true);
+    }
+
+    /* is 256K enough? udev uses 16MB! */
+    device_fd = uevent_open_socket(256*1024, true);
+    if(device_fd < 0)
+        return;
+
+    fcntl(device_fd, F_SETFD, FD_CLOEXEC);
+    fcntl(device_fd, F_SETFL, O_NONBLOCK);
+
+    if (stat(coldboot_done, &info) < 0) {
+        t0 = get_usecs();
+        coldboot("/sys/class");
+        coldboot("/sys/block");
+        coldboot("/sys/devices");
+        t1 = get_usecs();
+        fd = open(coldboot_done, O_WRONLY|O_CREAT, 0000);
+        close(fd);
+        log_event_print("coldboot %ld uS\n", ((long) (t1 - t0)));
+    } else {
+        log_event_print("skipping coldboot, already done\n");
+    }
+}
+
+int get_device_fd()
+{
+    return device_fd;
+}
diff --git a/devices.h b/devices.h
new file mode 100644
index 0000000..5d0fe88
--- /dev/null
+++ b/devices.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_DEVICES_H
+#define _INIT_DEVICES_H
+
+#include <sys/stat.h>
+
+extern void handle_device_fd();
+extern void device_init(void);
+extern int add_dev_perms(const char *name, const char *attr,
+                         mode_t perm, unsigned int uid,
+                         unsigned int gid, unsigned short prefix,
+                         unsigned short wildcard);
+int get_device_fd();
+#endif	/* _INIT_DEVICES_H */
diff --git a/grab-bootchart.sh b/grab-bootchart.sh
new file mode 100755
index 0000000..7fe8904
--- /dev/null
+++ b/grab-bootchart.sh
@@ -0,0 +1,22 @@
+#!/bin/sh
+#
+# this script is used to retrieve the bootchart log generated
+# by init when compiled with INIT_BOOTCHART=true.
+#
+# for all details, see //device/system/init/README.BOOTCHART
+#
+TMPDIR=/tmp/android-bootchart
+rm -rf $TMPDIR
+mkdir -p $TMPDIR
+
+LOGROOT=/data/bootchart
+TARBALL=bootchart.tgz
+
+FILES="header proc_stat.log proc_ps.log proc_diskstats.log kernel_pacct"
+
+for f in $FILES; do
+    adb pull $LOGROOT/$f $TMPDIR/$f 2>&1 > /dev/null
+done
+(cd $TMPDIR && tar -czf $TARBALL $FILES)
+cp -f $TMPDIR/$TARBALL ./$TARBALL
+echo "look at $TARBALL"
diff --git a/init.c b/init.c
new file mode 100755
index 0000000..579dbfa
--- /dev/null
+++ b/init.c
@@ -0,0 +1,1312 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <mtd/mtd-user.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+#include <selinux/android.h>
+
+#include <libgen.h>
+
+#include <cutils/list.h>
+#include <cutils/android_reboot.h>
+#include <cutils/sockets.h>
+#include <cutils/iosched_policy.h>
+#include <cutils/fs.h>
+#include <private/android_filesystem_config.h>
+#include <termios.h>
+
+#include "devices.h"
+#include "init.h"
+#include "log.h"
+#include "property_service.h"
+#include "bootchart.h"
+#include "signal_handler.h"
+#include "keychords.h"
+#include "init_parser.h"
+#include "util.h"
+#include "ueventd.h"
+#include "watchdogd.h"
+
+struct selabel_handle *sehandle;
+struct selabel_handle *sehandle_prop;
+
+static int property_triggers_enabled = 0;
+
+#if BOOTCHART
+static int   bootchart_count;
+#endif
+
+static char console[32];
+static char bootmode[32];
+static char hardware[32];
+static unsigned revision = 0;
+static char qemu[32];
+
+static struct action *cur_action = NULL;
+static struct command *cur_command = NULL;
+static struct listnode *command_queue = NULL;
+
+void notify_service_state(const char *name, const char *state)
+{
+    char pname[PROP_NAME_MAX];
+    int len = strlen(name);
+    if ((len + 10) > PROP_NAME_MAX)
+        return;
+    snprintf(pname, sizeof(pname), "init.svc.%s", name);
+    property_set(pname, state);
+}
+
+static int have_console;
+static char console_name[PROP_VALUE_MAX] = "/dev/console";
+static time_t process_needs_restart;
+
+static const char *ENV[32];
+
+/* add_environment - add "key=value" to the current environment */
+int add_environment(const char *key, const char *val)
+{
+    size_t n;
+    size_t key_len = strlen(key);
+
+    /* The last environment entry is reserved to terminate the list */
+    for (n = 0; n < (ARRAY_SIZE(ENV) - 1); n++) {
+
+        /* Delete any existing entry for this key */
+        if (ENV[n] != NULL) {
+            size_t entry_key_len = strcspn(ENV[n], "=");
+            if ((entry_key_len == key_len) && (strncmp(ENV[n], key, entry_key_len) == 0)) {
+                free((char*)ENV[n]);
+                ENV[n] = NULL;
+            }
+        }
+
+        /* Add entry if a free slot is available */
+        if (ENV[n] == NULL) {
+            size_t len = key_len + strlen(val) + 2;
+            char *entry = malloc(len);
+            snprintf(entry, len, "%s=%s", key, val);
+            ENV[n] = entry;
+            return 0;
+        }
+    }
+
+    ERROR("No env. room to store: '%s':'%s'\n", key, val);
+
+    return -1;
+}
+
+static void zap_stdio(void)
+{
+    int fd;
+    fd = open("/dev/null", O_RDWR);
+    dup2(fd, 0);
+    dup2(fd, 1);
+    dup2(fd, 2);
+    close(fd);
+}
+
+static void open_console()
+{
+    int fd;
+    if ((fd = open(console_name, O_RDWR)) < 0) {
+        fd = open("/dev/null", O_RDWR);
+    }
+    ioctl(fd, TIOCSCTTY, 0);
+    dup2(fd, 0);
+    dup2(fd, 1);
+    dup2(fd, 2);
+    close(fd);
+}
+
+static void publish_socket(const char *name, int fd)
+{
+    char key[64] = ANDROID_SOCKET_ENV_PREFIX;
+    char val[64];
+
+    strlcpy(key + sizeof(ANDROID_SOCKET_ENV_PREFIX) - 1,
+            name,
+            sizeof(key) - sizeof(ANDROID_SOCKET_ENV_PREFIX));
+    snprintf(val, sizeof(val), "%d", fd);
+    add_environment(key, val);
+
+    /* make sure we don't close-on-exec */
+    fcntl(fd, F_SETFD, 0);
+}
+/**
+ * 
+ */
+void service_start(struct service *svc, const char *dynamic_args)
+{
+    struct stat s;
+    pid_t pid;
+    int needs_console;
+    int n;
+    char *scon = NULL;
+    int rc;
+
+        /* starting a service removes it from the disabled or reset
+         * state and immediately takes it out of the restarting
+         * state if it was in there
+         */
+	//
+    svc->flags &= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));
+    svc->time_started = 0;
+
+        /* running processes require no additional work -- if
+         * they're in the process of exiting, we've ensured
+         * that they will immediately restart on exit, unless
+         * they are ONESHOT
+         */
+//SVC_RUNNING
+    if (svc->flags & SVC_RUNNING) {
+        return;
+    }
+	//
+	//console_init_action /dev/console,1
+    needs_console = (svc->flags & SVC_CONSOLE) ? 1 : 0;
+    if (needs_console && (!have_console)) {
+        ERROR("service '%s' requires console\n", svc->name);
+        svc->flags |= SVC_DISABLED;
+        return;
+    }
+	//Service
+    if (stat(svc->args[0], &s) != 0) {
+        ERROR("cannot find '%s', disabling '%s'\n", svc->args[0], svc->name);
+        svc->flags |= SVC_DISABLED;
+        return;
+    }
+	//SVC_ONESHOT
+	//
+    if ((!(svc->flags & SVC_ONESHOT)) && dynamic_args) {
+        ERROR("service '%s' must be one-shot to use dynamic args, disabling\n",
+               svc->args[0]);
+        svc->flags |= SVC_DISABLED;
+        return;
+    }
+//
+    if (is_selinux_enabled() > 0) {
+        if (svc->seclabel) {
+            scon = strdup(svc->seclabel);
+            if (!scon) {
+                ERROR("Out of memory while starting '%s'\n", svc->name);
+                return;
+            }
+        } else {
+            char *mycon = NULL, *fcon = NULL;
+
+            INFO("computing context for service '%s'\n", svc->args[0]);
+            rc = getcon(&mycon);
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", svc->name);
+                return;
+            }
+
+            rc = getfilecon(svc->args[0], &fcon);
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", svc->name);
+                freecon(mycon);
+                return;
+            }
+
+            rc = security_compute_create(mycon, fcon, string_to_security_class("process"), &scon);
+            if (rc == 0 && !strcmp(scon, mycon)) {
+                ERROR("Warning!  Service %s needs a SELinux domain defined; please fix!\n", svc->name);
+            }
+            freecon(mycon);
+            freecon(fcon);
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", svc->name);
+                return;
+            }
+        }
+    }
+
+    NOTICE("starting '%s'\n", svc->name);
+//fork
+    pid = fork();
+
+    if (pid == 0) {
+        struct socketinfo *si;
+        struct svcenvinfo *ei;
+        char tmp[32];
+        int fd, sz;
+
+        umask(077);
+		//
+        if (properties_inited()) {
+            get_property_workspace(&fd, &sz);
+            sprintf(tmp, "%d,%d", dup(fd), sz);
+            add_environment("ANDROID_PROPERTY_WORKSPACE", tmp);
+        }
+
+        for (ei = svc->envvars; ei; ei = ei->next)
+            add_environment(ei->name, ei->value);
+// setsockcreatecon(scon);
+//sokcetsocket
+//socketPF_UNIXsocketrootexec
+//
+//execAndroid
+//ANDROID_SOCKET_ XXXXXX
+//socket
+//socketsocket
+//execfcntl(fd,F_SETFD,0)
+//publish_socket
+        for (si = svc->sockets; si; si = si->next) {
+            int socket_type = (
+                    !strcmp(si->type, "stream") ? SOCK_STREAM :
+                        (!strcmp(si->type, "dgram") ? SOCK_DGRAM : SOCK_SEQPACKET));
+            int s = create_socket(si->name, socket_type,
+                                  si->perm, si->uid, si->gid, si->socketcon ?: scon);
+            if (s >= 0) {
+                publish_socket(si->name, s);
+            }
+        }
+
+        freecon(scon);
+        scon = NULL;
+
+        if (svc->ioprio_class != IoSchedClass_NONE) {
+            if (android_set_ioprio(getpid(), svc->ioprio_class, svc->ioprio_pri)) {
+                ERROR("Failed to set pid %d ioprio = %d,%d: %s\n",
+                      getpid(), svc->ioprio_class, svc->ioprio_pri, strerror(errno));
+            }
+        }
+//3
+        if (needs_console) {
+            setsid();
+            open_console();
+        } else {
+            zap_stdio();
+        }
+
+#if 0
+        for (n = 0; svc->args[n]; n++) {
+            INFO("args[%d] = '%s'\n", n, svc->args[n]);
+        }
+        for (n = 0; ENV[n]; n++) {
+            INFO("env[%d] = '%s'\n", n, ENV[n]);
+        }
+#endif
+
+        setpgid(0, getpid());
+
+    /* as requested, set our gid, supplemental gids, and uid */
+        if (svc->gid) {
+            if (setgid(svc->gid) != 0) {
+                ERROR("setgid failed: %s\n", strerror(errno));
+                _exit(127);
+            }
+        }
+        if (svc->nr_supp_gids) {
+            if (setgroups(svc->nr_supp_gids, svc->supp_gids) != 0) {
+                ERROR("setgroups failed: %s\n", strerror(errno));
+                _exit(127);
+            }
+        }
+        if (svc->uid) {
+            if (setuid(svc->uid) != 0) {
+                ERROR("setuid failed: %s\n", strerror(errno));
+                _exit(127);
+            }
+        }
+        if (svc->seclabel) {
+            if (is_selinux_enabled() > 0 && setexeccon(svc->seclabel) < 0) {
+                ERROR("cannot setexeccon('%s'): %s\n", svc->seclabel, strerror(errno));
+                _exit(127);
+            }
+        }
+//exec
+//execinitexecve()
+//
+        if (!dynamic_args) {
+            if (execve(svc->args[0], (char**) svc->args, (char**) ENV) < 0) {
+                ERROR("cannot execve('%s'): %s\n", svc->args[0], strerror(errno));
+            }
+        } else {
+            char *arg_ptrs[INIT_PARSER_MAXARGS+1];
+            int arg_idx = svc->nargs;
+            char *tmp = strdup(dynamic_args);
+            char *next = tmp;
+            char *bword;
+
+            /* Copy the static arguments */
+            memcpy(arg_ptrs, svc->args, (svc->nargs * sizeof(char *)));
+
+            while((bword = strsep(&next, " "))) {
+                arg_ptrs[arg_idx++] = bword;
+                if (arg_idx == INIT_PARSER_MAXARGS)
+                    break;
+            }
+            arg_ptrs[arg_idx] = '\0';
+            execve(svc->args[0], (char**) arg_ptrs, (char**) ENV);
+        }
+        _exit(127);
+    }
+
+    freecon(scon);
+
+    if (pid < 0) {
+        ERROR("failed to start '%s'\n", svc->name);
+        svc->pid = 0;
+        return;
+    }
+
+    svc->time_started = gettime();
+    svc->pid = pid;
+    svc->flags |= SVC_RUNNING;
+
+    if (properties_inited())
+        notify_service_state(svc->name, "running");
+}
+
+/* The how field should be either SVC_DISABLED, SVC_RESET, or SVC_RESTART */
+static void service_stop_or_reset(struct service *svc, int how)
+{
+    /* The service is still SVC_RUNNING until its process exits, but if it has
+     * already exited it shoudn't attempt a restart yet. */
+    svc->flags &= ~(SVC_RESTARTING | SVC_DISABLED_START);
+
+    if ((how != SVC_DISABLED) && (how != SVC_RESET) && (how != SVC_RESTART)) {
+        /* Hrm, an illegal flag.  Default to SVC_DISABLED */
+        how = SVC_DISABLED;
+    }
+        /* if the service has not yet started, prevent
+         * it from auto-starting with its class
+         */
+    if (how == SVC_RESET) {
+        svc->flags |= (svc->flags & SVC_RC_DISABLED) ? SVC_DISABLED : SVC_RESET;
+    } else {
+        svc->flags |= how;
+    }
+
+    if (svc->pid) {
+        NOTICE("service '%s' is being killed\n", svc->name);
+        kill(-svc->pid, SIGKILL);
+        notify_service_state(svc->name, "stopping");
+    } else {
+        notify_service_state(svc->name, "stopped");
+    }
+}
+
+void service_reset(struct service *svc)
+{
+    service_stop_or_reset(svc, SVC_RESET);
+}
+
+void service_stop(struct service *svc)
+{
+    service_stop_or_reset(svc, SVC_DISABLED);
+}
+
+void service_restart(struct service *svc)
+{
+    if (svc->flags & SVC_RUNNING) {
+        /* Stop, wait, then start the service. */
+        service_stop_or_reset(svc, SVC_RESTART);
+    } else if (!(svc->flags & SVC_RESTARTING)) {
+        /* Just start the service since it's not running. */
+        service_start(svc, NULL);
+    } /* else: Service is restarting anyways. */
+}
+
+void property_changed(const char *name, const char *value)
+{
+    if (property_triggers_enabled)
+        queue_property_triggers(name, value);
+}
+
+static void restart_service_if_needed(struct service *svc)
+{
+    time_t next_start_time = svc->time_started + 5;
+
+    if (next_start_time <= gettime()) {
+        svc->flags &= (~SVC_RESTARTING);
+        service_start(svc, NULL);
+        return;
+    }
+
+    if ((next_start_time < process_needs_restart) ||
+        (process_needs_restart == 0)) {
+        process_needs_restart = next_start_time;
+    }
+}
+
+static void restart_processes()
+{
+    process_needs_restart = 0;
+	/**service_for_each_flagsservice_list
+	 * SVC_RESTARTINGrestart_service_if_needed()
+	 * restart_service_if_neededservice_start()
+	 * restart_processes----->restart_service_if_needed------>
+	 * -->service_start
+	 */
+    service_for_each_flags(SVC_RESTARTING,
+                           restart_service_if_needed);
+}
+
+static void msg_start(const char *name)
+{
+    struct service *svc = NULL;
+    char *tmp = NULL;
+    char *args = NULL;
+
+    if (!strchr(name, ':'))
+        svc = service_find_by_name(name);
+    else {
+        tmp = strdup(name);
+        if (tmp) {
+            args = strchr(tmp, ':');
+            *args = '\0';
+            args++;
+
+            svc = service_find_by_name(tmp);
+        }
+    }
+
+    if (svc) {
+        service_start(svc, args);
+    } else {
+        ERROR("no such service '%s'\n", name);
+    }
+    if (tmp)
+        free(tmp);
+}
+
+static void msg_stop(const char *name)
+{
+    struct service *svc = service_find_by_name(name);
+
+    if (svc) {
+        service_stop(svc);
+    } else {
+        ERROR("no such service '%s'\n", name);
+    }
+}
+
+static void msg_restart(const char *name)
+{
+    struct service *svc = service_find_by_name(name);
+
+    if (svc) {
+        service_restart(svc);
+    } else {
+        ERROR("no such service '%s'\n", name);
+    }
+}
+
+void handle_control_message(const char *msg, const char *arg)
+{
+    if (!strcmp(msg,"start")) {
+        msg_start(arg);
+    } else if (!strcmp(msg,"stop")) {
+        msg_stop(arg);
+    } else if (!strcmp(msg,"restart")) {
+        msg_restart(arg);
+    } else {
+        ERROR("unknown control msg '%s'\n", msg);
+    }
+}
+
+static struct command *get_first_command(struct action *act)
+{
+    struct listnode *node;
+    node = list_head(&act->commands);
+    if (!node || list_empty(&act->commands))
+        return NULL;
+
+    return node_to_item(node, struct command, clist);
+}
+
+static struct command *get_next_command(struct action *act, struct command *cmd)
+{
+    struct listnode *node;
+    node = cmd->clist.next;
+    if (!node)
+        return NULL;
+    if (node == &act->commands)
+        return NULL;
+
+    return node_to_item(node, struct command, clist);
+}
+
+static int is_last_command(struct action *act, struct command *cmd)
+{
+    return (list_tail(&act->commands) == &cmd->clist);
+}
+
+void execute_one_command(void)
+{
+    int ret, i;
+    char cmd_str[256] = "";
+
+    if (!cur_action || !cur_command || is_last_command(cur_action, cur_command)) {
+        cur_action = action_remove_queue_head();
+        cur_command = NULL;
+        if (!cur_action)
+            return;
+        INFO("processing action %p (%s)\n", cur_action, cur_action->name);
+        cur_command = get_first_command(cur_action);
+    } else {
+        cur_command = get_next_command(cur_action, cur_command);
+    }
+
+    if (!cur_command)
+        return;
+
+    ret = cur_command->func(cur_command->nargs, cur_command->args);
+    if (klog_get_level() >= KLOG_INFO_LEVEL) {
+        for (i = 0; i < cur_command->nargs; i++) {
+            strlcat(cmd_str, cur_command->args[i], sizeof(cmd_str));
+            if (i < cur_command->nargs - 1) {
+                strlcat(cmd_str, " ", sizeof(cmd_str));
+            }
+        }
+        INFO("command '%s' action=%s status=%d (%s:%d)\n",
+             cmd_str, cur_action ? cur_action->name : "", ret, cur_command->filename,
+             cur_command->line);
+    }
+}
+
+static int wait_for_coldboot_done_action(int nargs, char **args)
+{
+    int ret;
+    INFO("wait for %s\n", coldboot_done);
+    ret = wait_for_file(coldboot_done, COMMAND_RETRY_TIMEOUT);
+    if (ret)
+        ERROR("Timed out waiting for %s\n", coldboot_done);
+    return ret;
+}
+
+/*
+ * Writes 512 bytes of output from Hardware RNG (/dev/hw_random, backed
+ * by Linux kernel's hw_random framework) into Linux RNG's via /dev/urandom.
+ * Does nothing if Hardware RNG is not present.
+ *
+ * Since we don't yet trust the quality of Hardware RNG, these bytes are not
+ * mixed into the primary pool of Linux RNG and the entropy estimate is left
+ * unmodified.
+ *
+ * If the HW RNG device /dev/hw_random is present, we require that at least
+ * 512 bytes read from it are written into Linux RNG. QA is expected to catch
+ * devices/configurations where these I/O operations are blocking for a long
+ * time. We do not reboot or halt on failures, as this is a best-effort
+ * attempt.
+ */
+static int mix_hwrng_into_linux_rng_action(int nargs, char **args)
+{
+    int result = -1;
+    int hwrandom_fd = -1;
+    int urandom_fd = -1;
+    char buf[512];
+    ssize_t chunk_size;
+    size_t total_bytes_written = 0;
+
+    hwrandom_fd = TEMP_FAILURE_RETRY(
+            open("/dev/hw_random", O_RDONLY | O_NOFOLLOW));
+    if (hwrandom_fd == -1) {
+        if (errno == ENOENT) {
+          ERROR("/dev/hw_random not found\n");
+          /* It's not an error to not have a Hardware RNG. */
+          result = 0;
+        } else {
+          ERROR("Failed to open /dev/hw_random: %s\n", strerror(errno));
+        }
+        goto ret;
+    }
+
+    urandom_fd = TEMP_FAILURE_RETRY(
+            open("/dev/urandom", O_WRONLY | O_NOFOLLOW));
+    if (urandom_fd == -1) {
+        ERROR("Failed to open /dev/urandom: %s\n", strerror(errno));
+        goto ret;
+    }
+
+    while (total_bytes_written < sizeof(buf)) {
+        chunk_size = TEMP_FAILURE_RETRY(
+                read(hwrandom_fd, buf, sizeof(buf) - total_bytes_written));
+        if (chunk_size == -1) {
+            ERROR("Failed to read from /dev/hw_random: %s\n", strerror(errno));
+            goto ret;
+        } else if (chunk_size == 0) {
+            ERROR("Failed to read from /dev/hw_random: EOF\n");
+            goto ret;
+        }
+
+        chunk_size = TEMP_FAILURE_RETRY(write(urandom_fd, buf, chunk_size));
+        if (chunk_size == -1) {
+            ERROR("Failed to write to /dev/urandom: %s\n", strerror(errno));
+            goto ret;
+        }
+        total_bytes_written += chunk_size;
+    }
+
+    INFO("Mixed %zu bytes from /dev/hw_random into /dev/urandom",
+                total_bytes_written);
+    result = 0;
+
+ret:
+    if (hwrandom_fd != -1) {
+        close(hwrandom_fd);
+    }
+    if (urandom_fd != -1) {
+        close(urandom_fd);
+    }
+    memset(buf, 0, sizeof(buf));
+    return result;
+}
+
+static int keychord_init_action(int nargs, char **args)
+{
+    keychord_init();
+    return 0;
+}
+
+static int console_init_action(int nargs, char **args)
+{
+    int fd;
+
+    if (console[0]) {
+        snprintf(console_name, sizeof(console_name), "/dev/%s", console);
+    }
+
+    fd = open(console_name, O_RDWR);
+ ///dev/console 1()
+	if (fd >= 0)
+        have_console = 1;
+    close(fd);
+
+    fd = open("/dev/tty0", O_WRONLY);
+    if (fd >= 0) {
+        const char *msg;
+            msg = "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"  // console is 40 cols x 30 lines
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "             A N D R O I D ";
+        write(fd, msg, strlen(msg));
+        close(fd);
+    }
+
+    return 0;
+}
+
+static void import_kernel_nv(char *name, int for_emulator)
+{
+    char *value = strchr(name, '=');
+    int name_len = strlen(name);
+
+    if (value == 0) return;
+    *value++ = 0;
+    if (name_len == 0) return;
+
+    if (for_emulator) {
+        /* in the emulator, export any kernel option with the
+         * ro.kernel. prefix */
+        char buff[PROP_NAME_MAX];
+        int len = snprintf( buff, sizeof(buff), "ro.kernel.%s", name );
+
+        if (len < (int)sizeof(buff))
+            property_set( buff, value );
+        return;
+    }
+
+    if (!strcmp(name,"qemu")) {
+        strlcpy(qemu, value, sizeof(qemu));
+    } else if (!strncmp(name, "androidboot.", 12) && name_len > 12) {
+        const char *boot_prop_name = name + 12;
+        char prop[PROP_NAME_MAX];
+        int cnt;
+
+        cnt = snprintf(prop, sizeof(prop), "ro.boot.%s", boot_prop_name);
+        if (cnt < PROP_NAME_MAX)
+            property_set(prop, value);
+    }
+}
+
+static int get_chip_id(char *buf, size_t size)
+{
+    char *path = "/proc/cpuinfo";
+    FILE *fd;
+    char data[128];
+    char *key, *value, *end;
+    int len = -1;
+
+    fd = fopen(path, "r");
+    if (fd == NULL) {
+        ERROR("cannot open %s\n", path);
+        goto oops;
+    }
+
+    while (fgets(data, sizeof(data), fd)) {
+        key = data;
+        value = strchr(key, ':');
+        if (value == 0)
+            continue;
+        *value++ = 0;
+
+        if (strncmp(key, "Serial", 6))
+            continue;
+
+        while (isspace(*value))
+            value++;
+
+        end = strchr(value, '\n');
+        *end = 0;
+        len = snprintf(buf, size, "%s", value);
+        break;
+    }
+
+    fclose(fd);
+oops:
+    return len;
+}
+
+static void export_kernel_boot_props(void)
+{
+    char tmp[PROP_VALUE_MAX];
+    int ret;
+    unsigned i;
+    struct {
+        const char *src_prop;
+        const char *dest_prop;
+        const char *def_val;
+    } prop_map[] = {
+        { "ro.boot.serialno", "ro.serialno", "", },
+        { "ro.boot.mode", "ro.bootmode", "unknown", },
+        { "ro.boot.baseband", "ro.baseband", "unknown", },
+        { "ro.boot.bootloader", "ro.bootloader", "unknown", },
+    };
+    char buf[32] = {0};
+
+    if (get_chip_id(buf, sizeof(buf)) < 0) {
+        ERROR("get chip id failed\n");
+    } else {
+        property_set("ro.boot.serialno", buf);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(prop_map); i++) {
+        ret = property_get(prop_map[i].src_prop, tmp);
+        if (ret > 0)
+            property_set(prop_map[i].dest_prop, tmp);
+        else
+            property_set(prop_map[i].dest_prop, prop_map[i].def_val);
+    }
+
+    ret = property_get("ro.boot.console", tmp);
+    if (ret)
+        strlcpy(console, tmp, sizeof(console));
+
+    /* save a copy for init's usage during boot */
+    property_get("ro.bootmode", tmp);
+    strlcpy(bootmode, tmp, sizeof(bootmode));
+
+    /* if this was given on kernel command line, override what we read
+     * before (e.g. from /proc/cpuinfo), if anything */
+    ret = property_get("ro.boot.hardware", tmp);
+    if (ret)
+        strlcpy(hardware, tmp, sizeof(hardware));
+    property_set("ro.hardware", hardware);
+
+    snprintf(tmp, PROP_VALUE_MAX, "%d", revision);
+    property_set("ro.revision", tmp);
+
+    /* TODO: these are obsolete. We should delete them */
+    if (!strcmp(bootmode,"factory"))
+        property_set("ro.factorytest", "1");
+    else if (!strcmp(bootmode,"factory2"))
+        property_set("ro.factorytest", "2");
+    else
+        property_set("ro.factorytest", "0");
+}
+
+static void process_kernel_cmdline(void)
+{
+    /* don't expose the raw commandline to nonpriv processes */
+    chmod("/proc/cmdline", 0440);
+
+    /* first pass does the common stuff, and finds if we are in qemu.
+     * second pass is only necessary for qemu to export all kernel params
+     * as props.
+     */
+    import_kernel_cmdline(0, import_kernel_nv);
+    if (qemu[0])
+        import_kernel_cmdline(1, import_kernel_nv);
+
+    /* now propogate the info given on command line to internal variables
+     * used by init as well as the current required properties
+     */
+    export_kernel_boot_props();
+}
+
+static int property_service_init_action(int nargs, char **args)
+{
+    /* read any property files on system or data and
+     * fire up the property service.  This must happen
+     * after the ro.foo properties are set above so
+     * that /data/local.prop cannot interfere with them.
+     */
+    start_property_service();
+    if (get_property_set_fd() < 0) {
+        ERROR("start_property_service() failed\n");
+        exit(1);
+    }
+
+    return 0;
+}
+
+static int signal_init_action(int nargs, char **args)
+{
+    signal_init();
+    if (get_signal_fd() < 0) {
+        ERROR("signal_init() failed\n");
+        exit(1);
+    }
+    return 0;
+}
+
+static int queue_property_triggers_action(int nargs, char **args)
+{
+    queue_all_property_triggers();
+    /* enable property triggers */
+    property_triggers_enabled = 1;
+    return 0;
+}
+
+#if BOOTCHART
+static int bootchart_init_action(int nargs, char **args)
+{
+    bootchart_count = bootchart_init();
+    if (bootchart_count < 0) {
+        ERROR("bootcharting init failure\n");
+    } else if (bootchart_count > 0) {
+        NOTICE("bootcharting started (period=%d ms)\n", bootchart_count*BOOTCHART_POLLING_MS);
+    } else {
+        NOTICE("bootcharting ignored\n");
+    }
+
+    return 0;
+}
+#endif
+
+static const struct selinux_opt seopts_prop[] = {
+        { SELABEL_OPT_PATH, "/property_contexts" },
+        { SELABEL_OPT_PATH, "/data/security/current/property_contexts" },
+        { 0, NULL }
+};
+
+struct selabel_handle* selinux_android_prop_context_handle(void)
+{
+    int policy_index = selinux_android_use_data_policy() ? 1 : 0;
+    struct selabel_handle* sehandle = selabel_open(SELABEL_CTX_ANDROID_PROP,
+                                                   &seopts_prop[policy_index], 1);
+    if (!sehandle) {
+        ERROR("SELinux:  Could not load property_contexts:  %s\n",
+              strerror(errno));
+        return NULL;
+    }
+    INFO("SELinux: Loaded property contexts from %s\n", seopts_prop[policy_index].value);
+    return sehandle;
+}
+
+void selinux_init_all_handles(void)
+{
+    sehandle = selinux_android_file_context_handle();
+    selinux_android_set_sehandle(sehandle);
+    sehandle_prop = selinux_android_prop_context_handle();
+}
+
+static bool selinux_is_disabled(void)
+{
+#ifdef ALLOW_DISABLE_SELINUX
+    char tmp[PROP_VALUE_MAX];
+
+    if (access("/sys/fs/selinux", F_OK) != 0) {
+        /* SELinux is not compiled into the kernel, or has been disabled
+         * via the kernel command line "selinux=0".
+         */
+        return true;
+    }
+
+    if ((property_get("ro.boot.selinux", tmp) != 0) && (strcmp(tmp, "disabled") == 0)) {
+        /* SELinux is compiled into the kernel, but we've been told to disable it. */
+        return true;
+    }
+#endif
+
+    return false;
+}
+
+static bool selinux_is_enforcing(void)
+{
+#ifdef ALLOW_DISABLE_SELINUX
+    char tmp[PROP_VALUE_MAX];
+
+    if (property_get("ro.boot.selinux", tmp) == 0) {
+        /* Property is not set.  Assume enforcing */
+        return true;
+    }
+
+    if (strcmp(tmp, "permissive") == 0) {
+        /* SELinux is in the kernel, but we've been told to go into permissive mode */
+        return false;
+    }
+
+    if (strcmp(tmp, "enforcing") != 0) {
+        ERROR("SELinux: Unknown value of ro.boot.selinux. Got: \"%s\". Assuming enforcing.\n", tmp);
+    }
+
+#endif
+    return true;
+}
+
+int selinux_reload_policy(void)
+{
+    if (selinux_is_disabled()) {
+        return -1;
+    }
+
+    INFO("SELinux: Attempting to reload policy files\n");
+
+    if (selinux_android_reload_policy() == -1) {
+        return -1;
+    }
+
+    if (sehandle)
+        selabel_close(sehandle);
+
+    if (sehandle_prop)
+        selabel_close(sehandle_prop);
+
+    selinux_init_all_handles();
+    return 0;
+}
+
+static int audit_callback(void *data, security_class_t cls __attribute__((unused)), char *buf, size_t len)
+{
+    snprintf(buf, len, "property=%s", !data ? "NULL" : (char *)data);
+    return 0;
+}
+
+int log_callback(int type, const char *fmt, ...)
+{
+    int level;
+    va_list ap;
+    switch (type) {
+    case SELINUX_WARNING:
+        level = KLOG_WARNING_LEVEL;
+        break;
+    case SELINUX_INFO:
+        level = KLOG_INFO_LEVEL;
+        break;
+    default:
+        level = KLOG_ERROR_LEVEL;
+        break;
+    }
+    va_start(ap, fmt);
+    klog_vwrite(level, fmt, ap);
+    va_end(ap);
+    return 0;
+}
+
+static void selinux_initialize(void)
+{
+    if (selinux_is_disabled()) {
+        return;
+    }
+
+    INFO("loading selinux policy\n");
+    if (selinux_android_load_policy() < 0) {
+        ERROR("SELinux: Failed to load policy; rebooting into recovery mode\n");
+        android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
+        while (1) { pause(); }  // never reached
+    }
+
+    selinux_init_all_handles();
+    bool is_enforcing = selinux_is_enforcing();
+    INFO("SELinux: security_setenforce(%d)\n", is_enforcing);
+    security_setenforce(is_enforcing);
+}
+
+#include "init_mem_opt.c"
+int main(int argc, char **argv)
+{
+    int fd_count = 0;
+    struct pollfd ufds[4];
+    char *tmpdev;
+    char* debuggable;
+    char tmp[32];
+    int property_set_fd_init = 0;
+    int signal_fd_init = 0;
+    int keychord_fd_init = 0;
+    bool is_charger = false;
+/*
+ * mainueventd
+ * ueventd ueventd_main(),watchdogd ,
+ * watchdogd_main()
+ */
+    if (!strcmp(basename(argv[0]), "ueventd"))
+        return ueventd_main(argc, argv);
+
+    if (!strcmp(basename(argv[0]), "watchdogd"))
+        return watchdogd_main(argc, argv);
+
+    /* clear the umask */
+    umask(0);
+
+        /* Get the basic filesystem setup we need put
+         * together in the initramdisk on / and then we'll
+         * let the rc file figure out the rest.
+         */
+    mkdir("/dev", 0755);
+    mkdir("/proc", 0755);
+    mkdir("/sys", 0755);
+
+    mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");// 
+	//tmpfs
+    mkdir("/dev/pts", 0755);
+    mkdir("/dev/socket", 0755);
+    mount("devpts", "/dev/pts", "devpts", 0, NULL);//
+    mount("proc", "/proc", "proc", 0, NULL);//
+	//cpuinfo
+	/**
+	 * sysfsproclinux2.6
+	 * 
+	 * 
+	 */
+    mount("sysfs", "/sys", "sysfs", 0, NULL)
+//booting
+        /* indicate that booting is in progress to background fw loaders, etc */
+    close(open("/dev/.booting", O_WRONLY | O_CREAT, 0000));
+
+        /* We must have some place other than / to create the
+         * device nodes for kmsg and null, otherwise we won't
+         * be able to remount / read-only later on.
+         * Now that tmpfs is mounted on /dev, we can actually
+         * talk to the outside world.
+         */
+	/**
+	 * open_devnull_stdio()
+	 * /dev/_null_
+	 */
+	
+    open_devnull_stdio();
+    /**
+	 * klog_init()/dev/__kmsg_,initkernellog
+	 * log
+	 * androidloginitkernellog
+	 */
+	klog_init();
+    property_init();
+//proc/cpuinfo
+    get_hardware_name(hardware, &revision);
+///proc/cmdline
+    process_kernel_cmdline();
+//selinuxandroid4.3
+    union selinux_callback cb;
+    cb.func_log = log_callback;
+    selinux_set_callback(SELINUX_CB_LOG, cb);
+
+    cb.func_audit = audit_callback;
+    selinux_set_callback(SELINUX_CB_AUDIT, cb);
+
+    selinux_initialize();
+    /* These directories were necessarily created before initial policy load
+     * and therefore need their security context restored to the proper value.
+     * This must happen before /dev is populated by ueventd.
+     */
+    restorecon("/dev");
+    restorecon("/dev/socket");
+    restorecon("/dev/__properties__");
+    restorecon_recursive("/sys");
+
+    is_charger = !strcmp(bootmode, "charger");
+//  property_load_boot_defaults default.prop
+//  
+//
+    NOTICE("property init\n");
+    property_load_boot_defaults();
+//
+//kernelinit
+//
+    NOTICE("reading config file\n");
+    init_parse_config_file("/init.rc");
+
+    action_for_each_trigger("early-init", action_add_queue_tail);
+/*queue_builtin_action
+ * Actionaction-queue
+ * ActionAndroid
+ * init.rc
+ * action
+ */
+
+          ERROR("/dev/hw_random not found1111111\n");
+		  //
+    queue_builtin_action(wait_for_coldboot_done_action, "wait_for_coldboot_done");
+          ERROR("/dev/hw_random not found2222222\n");
+		  //rng/dev/hw_random512LinuxRNG
+		  ///dev/urandom
+    queue_builtin_action(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");
+          ERROR("/dev/hw_random not found3333333\n");
+		  //keychord_init  
+    queue_builtin_action(keychord_init_action, "keychord_init");
+
+          ERROR("/dev/hw_random not found4444444\n");
+    	//Androidlogo
+	queue_builtin_action(console_init_action, "console_init");
+
+          ERROR("/dev/hw_random not found5555555\n");
+
+    /* execute all the boot actions to get us started */
+    action_for_each_trigger("init", action_add_queue_tail);
+
+          ERROR("/dev/hw_random not found6666666\n");
+    /* Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random
+     * wasn't ready immediately after wait_for_coldboot_done
+     */
+// farsight rng		  
+queue_builtin_action(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");
+  //
+	 queue_builtin_action(property_service_init_action, "property_service_init");
+ //
+	queue_builtin_action(signal_init_action, "signal_init");
+//late-init action
+    /* Don't mount filesystems or start core system services if in charger mode. */
+    if (is_charger) {
+        action_for_each_trigger("charger", action_add_queue_tail);
+    } else {
+        action_for_each_trigger("late-init", action_add_queue_tail);
+    }
+//ActionAction
+//Action
+    /* run all property triggers based on current state of the properties */
+    queue_builtin_action(queue_property_triggers_action, "queue_property_triggers");
+          ERROR("/dev/hw_random not found77777\n");
+
+/**
+ * 
+ * 
+ */
+#if BOOTCHART
+    queue_builtin_action(bootchart_init_action, "bootchart_init");
+#endif
+
+          ERROR("/dev/hw_random not found888888888\n");
+/**
+ * main()forexecute_one_command
+ * restart_processes()
+ */
+    for(;;) {
+        int nr, i, timeout = -1;
+
+        execute_one_command();
+        restart_processes();
+/**
+ * Init
+ * poll
+ * poll
+ */
+        if (!property_set_fd_init && get_property_set_fd() > 0) {
+            ufds[fd_count].fd = get_property_set_fd();
+            ufds[fd_count].events = POLLIN;
+            ufds[fd_count].revents = 0;
+            fd_count++;
+            property_set_fd_init = 1;
+        }
+        if (!signal_fd_init && get_signal_fd() > 0) {
+            ufds[fd_count].fd = get_signal_fd();
+            ufds[fd_count].events = POLLIN;
+            ufds[fd_count].revents = 0;
+            fd_count+ +;
+            signal_fd_init = 1;
+        }
+        if (!keychord_fd_init && get_keychord_fd() > 0) {
+            ufds[fd_count].fd = get_keychord_fd();
+            ufds[fd_count].events = POLLIN;
+            ufds[fd_count].revents = 0;
+            fd_count++;
+            keychord_fd_init = 1;
+        }
+
+        if (process_needs_restart) {
+            timeout = (process_needs_restart - gettime()) * 1000;
+            if (timeout < 0)
+                timeout = 0;
+        }
+
+        if (!action_queue_empty() || cur_action)
+            timeout = 0;
+
+#if BOOTCHART
+        if (bootchart_count > 0) {
+            if (timeout < 0 || timeout > BOOTCHART_POLLING_MS)
+                timeout = BOOTCHART_POLLING_MS;
+            if (bootchart_step() < 0 || --bootchart_count == 0) {
+                bootchart_finish();
+                bootchart_count = 0;
+            }
+        }
+#endif
+/**
+ * poll()select 
+ * pollselect
+ * poll().
+ */
+        nr = poll(ufds, fd_count, timeout);
+        if (nr <= 0)
+            continue;
+
+        for (i = 0; i < fd_count; i++) {
+            if (ufds[i].revents & POLLIN) {
+                if (ufds[i].fd == get_property_set_fd())
+                    handle_property_set_fd();
+                else if (ufds[i].fd == get_keychord_fd())
+                    handle_keychord();
+                else if (ufds[i].fd == get_signal_fd())
+                    handle_signal();
+            }
+        }
+    }
+
+    return 0;
+}
diff --git a/init.c~ b/init.c~
new file mode 100755
index 0000000..9ebf114
--- /dev/null
+++ b/init.c~
@@ -0,0 +1,1231 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <mtd/mtd-user.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+#include <selinux/android.h>
+
+#include <libgen.h>
+
+#include <cutils/list.h>
+#include <cutils/android_reboot.h>
+#include <cutils/sockets.h>
+#include <cutils/iosched_policy.h>
+#include <cutils/fs.h>
+#include <private/android_filesystem_config.h>
+#include <termios.h>
+
+#include "devices.h"
+#include "init.h"
+#include "log.h"
+#include "property_service.h"
+#include "bootchart.h"
+#include "signal_handler.h"
+#include "keychords.h"
+#include "init_parser.h"
+#include "util.h"
+#include "ueventd.h"
+#include "watchdogd.h"
+
+struct selabel_handle *sehandle;
+struct selabel_handle *sehandle_prop;
+
+static int property_triggers_enabled = 0;
+
+#if BOOTCHART
+static int   bootchart_count;
+#endif
+
+static char console[32];
+static char bootmode[32];
+static char hardware[32];
+static unsigned revision = 0;
+static char qemu[32];
+
+static struct action *cur_action = NULL;
+static struct command *cur_command = NULL;
+static struct listnode *command_queue = NULL;
+
+void notify_service_state(const char *name, const char *state)
+{
+    char pname[PROP_NAME_MAX];
+    int len = strlen(name);
+    if ((len + 10) > PROP_NAME_MAX)
+        return;
+    snprintf(pname, sizeof(pname), "init.svc.%s", name);
+    property_set(pname, state);
+}
+
+static int have_console;
+static char console_name[PROP_VALUE_MAX] = "/dev/console";
+static time_t process_needs_restart;
+
+static const char *ENV[32];
+
+/* add_environment - add "key=value" to the current environment */
+int add_environment(const char *key, const char *val)
+{
+    size_t n;
+    size_t key_len = strlen(key);
+
+    /* The last environment entry is reserved to terminate the list */
+    for (n = 0; n < (ARRAY_SIZE(ENV) - 1); n++) {
+
+        /* Delete any existing entry for this key */
+        if (ENV[n] != NULL) {
+            size_t entry_key_len = strcspn(ENV[n], "=");
+            if ((entry_key_len == key_len) && (strncmp(ENV[n], key, entry_key_len) == 0)) {
+                free((char*)ENV[n]);
+                ENV[n] = NULL;
+            }
+        }
+
+        /* Add entry if a free slot is available */
+        if (ENV[n] == NULL) {
+            size_t len = key_len + strlen(val) + 2;
+            char *entry = malloc(len);
+            snprintf(entry, len, "%s=%s", key, val);
+            ENV[n] = entry;
+            return 0;
+        }
+    }
+
+    ERROR("No env. room to store: '%s':'%s'\n", key, val);
+
+    return -1;
+}
+
+static void zap_stdio(void)
+{
+    int fd;
+    fd = open("/dev/null", O_RDWR);
+    dup2(fd, 0);
+    dup2(fd, 1);
+    dup2(fd, 2);
+    close(fd);
+}
+
+static void open_console()
+{
+    int fd;
+    if ((fd = open(console_name, O_RDWR)) < 0) {
+        fd = open("/dev/null", O_RDWR);
+    }
+    ioctl(fd, TIOCSCTTY, 0);
+    dup2(fd, 0);
+    dup2(fd, 1);
+    dup2(fd, 2);
+    close(fd);
+}
+
+static void publish_socket(const char *name, int fd)
+{
+    char key[64] = ANDROID_SOCKET_ENV_PREFIX;
+    char val[64];
+
+    strlcpy(key + sizeof(ANDROID_SOCKET_ENV_PREFIX) - 1,
+            name,
+            sizeof(key) - sizeof(ANDROID_SOCKET_ENV_PREFIX));
+    snprintf(val, sizeof(val), "%d", fd);
+    add_environment(key, val);
+
+    /* make sure we don't close-on-exec */
+    fcntl(fd, F_SETFD, 0);
+}
+
+void service_start(struct service *svc, const char *dynamic_args)
+{
+    struct stat s;
+    pid_t pid;
+    int needs_console;
+    int n;
+    char *scon = NULL;
+    int rc;
+
+        /* starting a service removes it from the disabled or reset
+         * state and immediately takes it out of the restarting
+         * state if it was in there
+         */
+    svc->flags &= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));
+    svc->time_started = 0;
+
+        /* running processes require no additional work -- if
+         * they're in the process of exiting, we've ensured
+         * that they will immediately restart on exit, unless
+         * they are ONESHOT
+         */
+    if (svc->flags & SVC_RUNNING) {
+        return;
+    }
+
+    needs_console = (svc->flags & SVC_CONSOLE) ? 1 : 0;
+    if (needs_console && (!have_console)) {
+        ERROR("service '%s' requires console\n", svc->name);
+        svc->flags |= SVC_DISABLED;
+        return;
+    }
+
+    if (stat(svc->args[0], &s) != 0) {
+        ERROR("cannot find '%s', disabling '%s'\n", svc->args[0], svc->name);
+        svc->flags |= SVC_DISABLED;
+        return;
+    }
+
+    if ((!(svc->flags & SVC_ONESHOT)) && dynamic_args) {
+        ERROR("service '%s' must be one-shot to use dynamic args, disabling\n",
+               svc->args[0]);
+        svc->flags |= SVC_DISABLED;
+        return;
+    }
+
+    if (is_selinux_enabled() > 0) {
+        if (svc->seclabel) {
+            scon = strdup(svc->seclabel);
+            if (!scon) {
+                ERROR("Out of memory while starting '%s'\n", svc->name);
+                return;
+            }
+        } else {
+            char *mycon = NULL, *fcon = NULL;
+
+            INFO("computing context for service '%s'\n", svc->args[0]);
+            rc = getcon(&mycon);
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", svc->name);
+                return;
+            }
+
+            rc = getfilecon(svc->args[0], &fcon);
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", svc->name);
+                freecon(mycon);
+                return;
+            }
+
+            rc = security_compute_create(mycon, fcon, string_to_security_class("process"), &scon);
+            if (rc == 0 && !strcmp(scon, mycon)) {
+                ERROR("Warning!  Service %s needs a SELinux domain defined; please fix!\n", svc->name);
+            }
+            freecon(mycon);
+            freecon(fcon);
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", svc->name);
+                return;
+            }
+        }
+    }
+
+    NOTICE("starting '%s'\n", svc->name);
+
+    pid = fork();
+
+    if (pid == 0) {
+        struct socketinfo *si;
+        struct svcenvinfo *ei;
+        char tmp[32];
+        int fd, sz;
+
+        umask(077);
+        if (properties_inited()) {
+            get_property_workspace(&fd, &sz);
+            sprintf(tmp, "%d,%d", dup(fd), sz);
+            add_environment("ANDROID_PROPERTY_WORKSPACE", tmp);
+        }
+
+        for (ei = svc->envvars; ei; ei = ei->next)
+            add_environment(ei->name, ei->value);
+
+        for (si = svc->sockets; si; si = si->next) {
+            int socket_type = (
+                    !strcmp(si->type, "stream") ? SOCK_STREAM :
+                        (!strcmp(si->type, "dgram") ? SOCK_DGRAM : SOCK_SEQPACKET));
+            int s = create_socket(si->name, socket_type,
+                                  si->perm, si->uid, si->gid, si->socketcon ?: scon);
+            if (s >= 0) {
+                publish_socket(si->name, s);
+            }
+        }
+
+        freecon(scon);
+        scon = NULL;
+
+        if (svc->ioprio_class != IoSchedClass_NONE) {
+            if (android_set_ioprio(getpid(), svc->ioprio_class, svc->ioprio_pri)) {
+                ERROR("Failed to set pid %d ioprio = %d,%d: %s\n",
+                      getpid(), svc->ioprio_class, svc->ioprio_pri, strerror(errno));
+            }
+        }
+
+        if (needs_console) {
+            setsid();
+            open_console();
+        } else {
+            zap_stdio();
+        }
+
+#if 0
+        for (n = 0; svc->args[n]; n++) {
+            INFO("args[%d] = '%s'\n", n, svc->args[n]);
+        }
+        for (n = 0; ENV[n]; n++) {
+            INFO("env[%d] = '%s'\n", n, ENV[n]);
+        }
+#endif
+
+        setpgid(0, getpid());
+
+    /* as requested, set our gid, supplemental gids, and uid */
+        if (svc->gid) {
+            if (setgid(svc->gid) != 0) {
+                ERROR("setgid failed: %s\n", strerror(errno));
+                _exit(127);
+            }
+        }
+        if (svc->nr_supp_gids) {
+            if (setgroups(svc->nr_supp_gids, svc->supp_gids) != 0) {
+                ERROR("setgroups failed: %s\n", strerror(errno));
+                _exit(127);
+            }
+        }
+        if (svc->uid) {
+            if (setuid(svc->uid) != 0) {
+                ERROR("setuid failed: %s\n", strerror(errno));
+                _exit(127);
+            }
+        }
+        if (svc->seclabel) {
+            if (is_selinux_enabled() > 0 && setexeccon(svc->seclabel) < 0) {
+                ERROR("cannot setexeccon('%s'): %s\n", svc->seclabel, strerror(errno));
+                _exit(127);
+            }
+        }
+
+        if (!dynamic_args) {
+            if (execve(svc->args[0], (char**) svc->args, (char**) ENV) < 0) {
+                ERROR("cannot execve('%s'): %s\n", svc->args[0], strerror(errno));
+            }
+        } else {
+            char *arg_ptrs[INIT_PARSER_MAXARGS+1];
+            int arg_idx = svc->nargs;
+            char *tmp = strdup(dynamic_args);
+            char *next = tmp;
+            char *bword;
+
+            /* Copy the static arguments */
+            memcpy(arg_ptrs, svc->args, (svc->nargs * sizeof(char *)));
+
+            while((bword = strsep(&next, " "))) {
+                arg_ptrs[arg_idx++] = bword;
+                if (arg_idx == INIT_PARSER_MAXARGS)
+                    break;
+            }
+            arg_ptrs[arg_idx] = '\0';
+            execve(svc->args[0], (char**) arg_ptrs, (char**) ENV);
+        }
+        _exit(127);
+    }
+
+    freecon(scon);
+
+    if (pid < 0) {
+        ERROR("failed to start '%s'\n", svc->name);
+        svc->pid = 0;
+        return;
+    }
+
+    svc->time_started = gettime();
+    svc->pid = pid;
+    svc->flags |= SVC_RUNNING;
+
+    if (properties_inited())
+        notify_service_state(svc->name, "running");
+}
+
+/* The how field should be either SVC_DISABLED, SVC_RESET, or SVC_RESTART */
+static void service_stop_or_reset(struct service *svc, int how)
+{
+    /* The service is still SVC_RUNNING until its process exits, but if it has
+     * already exited it shoudn't attempt a restart yet. */
+    svc->flags &= ~(SVC_RESTARTING | SVC_DISABLED_START);
+
+    if ((how != SVC_DISABLED) && (how != SVC_RESET) && (how != SVC_RESTART)) {
+        /* Hrm, an illegal flag.  Default to SVC_DISABLED */
+        how = SVC_DISABLED;
+    }
+        /* if the service has not yet started, prevent
+         * it from auto-starting with its class
+         */
+    if (how == SVC_RESET) {
+        svc->flags |= (svc->flags & SVC_RC_DISABLED) ? SVC_DISABLED : SVC_RESET;
+    } else {
+        svc->flags |= how;
+    }
+
+    if (svc->pid) {
+        NOTICE("service '%s' is being killed\n", svc->name);
+        kill(-svc->pid, SIGKILL);
+        notify_service_state(svc->name, "stopping");
+    } else {
+        notify_service_state(svc->name, "stopped");
+    }
+}
+
+void service_reset(struct service *svc)
+{
+    service_stop_or_reset(svc, SVC_RESET);
+}
+
+void service_stop(struct service *svc)
+{
+    service_stop_or_reset(svc, SVC_DISABLED);
+}
+
+void service_restart(struct service *svc)
+{
+    if (svc->flags & SVC_RUNNING) {
+        /* Stop, wait, then start the service. */
+        service_stop_or_reset(svc, SVC_RESTART);
+    } else if (!(svc->flags & SVC_RESTARTING)) {
+        /* Just start the service since it's not running. */
+        service_start(svc, NULL);
+    } /* else: Service is restarting anyways. */
+}
+
+void property_changed(const char *name, const char *value)
+{
+    if (property_triggers_enabled)
+        queue_property_triggers(name, value);
+}
+
+static void restart_service_if_needed(struct service *svc)
+{
+    time_t next_start_time = svc->time_started + 5;
+
+    if (next_start_time <= gettime()) {
+        svc->flags &= (~SVC_RESTARTING);
+        service_start(svc, NULL);
+        return;
+    }
+
+    if ((next_start_time < process_needs_restart) ||
+        (process_needs_restart == 0)) {
+        process_needs_restart = next_start_time;
+    }
+}
+
+static void restart_processes()
+{
+    process_needs_restart = 0;
+    service_for_each_flags(SVC_RESTARTING,
+                           restart_service_if_needed);
+}
+
+static void msg_start(const char *name)
+{
+    struct service *svc = NULL;
+    char *tmp = NULL;
+    char *args = NULL;
+
+    if (!strchr(name, ':'))
+        svc = service_find_by_name(name);
+    else {
+        tmp = strdup(name);
+        if (tmp) {
+            args = strchr(tmp, ':');
+            *args = '\0';
+            args++;
+
+            svc = service_find_by_name(tmp);
+        }
+    }
+
+    if (svc) {
+        service_start(svc, args);
+    } else {
+        ERROR("no such service '%s'\n", name);
+    }
+    if (tmp)
+        free(tmp);
+}
+
+static void msg_stop(const char *name)
+{
+    struct service *svc = service_find_by_name(name);
+
+    if (svc) {
+        service_stop(svc);
+    } else {
+        ERROR("no such service '%s'\n", name);
+    }
+}
+
+static void msg_restart(const char *name)
+{
+    struct service *svc = service_find_by_name(name);
+
+    if (svc) {
+        service_restart(svc);
+    } else {
+        ERROR("no such service '%s'\n", name);
+    }
+}
+
+void handle_control_message(const char *msg, const char *arg)
+{
+    if (!strcmp(msg,"start")) {
+        msg_start(arg);
+    } else if (!strcmp(msg,"stop")) {
+        msg_stop(arg);
+    } else if (!strcmp(msg,"restart")) {
+        msg_restart(arg);
+    } else {
+        ERROR("unknown control msg '%s'\n", msg);
+    }
+}
+
+static struct command *get_first_command(struct action *act)
+{
+    struct listnode *node;
+    node = list_head(&act->commands);
+    if (!node || list_empty(&act->commands))
+        return NULL;
+
+    return node_to_item(node, struct command, clist);
+}
+
+static struct command *get_next_command(struct action *act, struct command *cmd)
+{
+    struct listnode *node;
+    node = cmd->clist.next;
+    if (!node)
+        return NULL;
+    if (node == &act->commands)
+        return NULL;
+
+    return node_to_item(node, struct command, clist);
+}
+
+static int is_last_command(struct action *act, struct command *cmd)
+{
+    return (list_tail(&act->commands) == &cmd->clist);
+}
+
+void execute_one_command(void)
+{
+    int ret, i;
+    char cmd_str[256] = "";
+
+    if (!cur_action || !cur_command || is_last_command(cur_action, cur_command)) {
+        cur_action = action_remove_queue_head();
+        cur_command = NULL;
+        if (!cur_action)
+            return;
+        INFO("processing action %p (%s)\n", cur_action, cur_action->name);
+        cur_command = get_first_command(cur_action);
+    } else {
+        cur_command = get_next_command(cur_action, cur_command);
+    }
+
+    if (!cur_command)
+        return;
+
+    ret = cur_command->func(cur_command->nargs, cur_command->args);
+    if (klog_get_level() >= KLOG_INFO_LEVEL) {
+        for (i = 0; i < cur_command->nargs; i++) {
+            strlcat(cmd_str, cur_command->args[i], sizeof(cmd_str));
+            if (i < cur_command->nargs - 1) {
+                strlcat(cmd_str, " ", sizeof(cmd_str));
+            }
+        }
+        INFO("command '%s' action=%s status=%d (%s:%d)\n",
+             cmd_str, cur_action ? cur_action->name : "", ret, cur_command->filename,
+             cur_command->line);
+    }
+}
+
+static int wait_for_coldboot_done_action(int nargs, char **args)
+{
+    int ret;
+    INFO("wait for %s\n", coldboot_done);
+    ret = wait_for_file(coldboot_done, COMMAND_RETRY_TIMEOUT);
+    if (ret)
+        ERROR("Timed out waiting for %s\n", coldboot_done);
+    return ret;
+}
+
+/*
+ * Writes 512 bytes of output from Hardware RNG (/dev/hw_random, backed
+ * by Linux kernel's hw_random framework) into Linux RNG's via /dev/urandom.
+ * Does nothing if Hardware RNG is not present.
+ *
+ * Since we don't yet trust the quality of Hardware RNG, these bytes are not
+ * mixed into the primary pool of Linux RNG and the entropy estimate is left
+ * unmodified.
+ *
+ * If the HW RNG device /dev/hw_random is present, we require that at least
+ * 512 bytes read from it are written into Linux RNG. QA is expected to catch
+ * devices/configurations where these I/O operations are blocking for a long
+ * time. We do not reboot or halt on failures, as this is a best-effort
+ * attempt.
+ */
+static int mix_hwrng_into_linux_rng_action(int nargs, char **args)
+{
+    int result = -1;
+    int hwrandom_fd = -1;
+    int urandom_fd = -1;
+    char buf[512];
+    ssize_t chunk_size;
+    size_t total_bytes_written = 0;
+
+    hwrandom_fd = TEMP_FAILURE_RETRY(
+            open("/dev/hw_random", O_RDONLY | O_NOFOLLOW));
+    if (hwrandom_fd == -1) {
+        if (errno == ENOENT) {
+          ERROR("/dev/hw_random not found\n");
+          /* It's not an error to not have a Hardware RNG. */
+          result = 0;
+        } else {
+          ERROR("Failed to open /dev/hw_random: %s\n", strerror(errno));
+        }
+        goto ret;
+    }
+
+    urandom_fd = TEMP_FAILURE_RETRY(
+            open("/dev/urandom", O_WRONLY | O_NOFOLLOW));
+    if (urandom_fd == -1) {
+        ERROR("Failed to open /dev/urandom: %s\n", strerror(errno));
+        goto ret;
+    }
+
+    while (total_bytes_written < sizeof(buf)) {
+        chunk_size = TEMP_FAILURE_RETRY(
+                read(hwrandom_fd, buf, sizeof(buf) - total_bytes_written));
+        if (chunk_size == -1) {
+            ERROR("Failed to read from /dev/hw_random: %s\n", strerror(errno));
+            goto ret;
+        } else if (chunk_size == 0) {
+            ERROR("Failed to read from /dev/hw_random: EOF\n");
+            goto ret;
+        }
+
+        chunk_size = TEMP_FAILURE_RETRY(write(urandom_fd, buf, chunk_size));
+        if (chunk_size == -1) {
+            ERROR("Failed to write to /dev/urandom: %s\n", strerror(errno));
+            goto ret;
+        }
+        total_bytes_written += chunk_size;
+    }
+
+    INFO("Mixed %zu bytes from /dev/hw_random into /dev/urandom",
+                total_bytes_written);
+    result = 0;
+
+ret:
+    if (hwrandom_fd != -1) {
+        close(hwrandom_fd);
+    }
+    if (urandom_fd != -1) {
+        close(urandom_fd);
+    }
+    memset(buf, 0, sizeof(buf));
+    return result;
+}
+
+static int keychord_init_action(int nargs, char **args)
+{
+    keychord_init();
+    return 0;
+}
+
+static int console_init_action(int nargs, char **args)
+{
+    int fd;
+
+    if (console[0]) {
+        snprintf(console_name, sizeof(console_name), "/dev/%s", console);
+    }
+
+    fd = open(console_name, O_RDWR);
+    if (fd >= 0)
+        have_console = 1;
+    close(fd);
+
+    fd = open("/dev/tty0", O_WRONLY);
+    if (fd >= 0) {
+        const char *msg;
+            msg = "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"  // console is 40 cols x 30 lines
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "             A N D R O I D ";
+        write(fd, msg, strlen(msg));
+        close(fd);
+    }
+
+    return 0;
+}
+
+static void import_kernel_nv(char *name, int for_emulator)
+{
+    char *value = strchr(name, '=');
+    int name_len = strlen(name);
+
+    if (value == 0) return;
+    *value++ = 0;
+    if (name_len == 0) return;
+
+    if (for_emulator) {
+        /* in the emulator, export any kernel option with the
+         * ro.kernel. prefix */
+        char buff[PROP_NAME_MAX];
+        int len = snprintf( buff, sizeof(buff), "ro.kernel.%s", name );
+
+        if (len < (int)sizeof(buff))
+            property_set( buff, value );
+        return;
+    }
+
+    if (!strcmp(name,"qemu")) {
+        strlcpy(qemu, value, sizeof(qemu));
+    } else if (!strncmp(name, "androidboot.", 12) && name_len > 12) {
+        const char *boot_prop_name = name + 12;
+        char prop[PROP_NAME_MAX];
+        int cnt;
+
+        cnt = snprintf(prop, sizeof(prop), "ro.boot.%s", boot_prop_name);
+        if (cnt < PROP_NAME_MAX)
+            property_set(prop, value);
+    }
+}
+
+static int get_chip_id(char *buf, size_t size)
+{
+    char *path = "/proc/cpuinfo";
+    FILE *fd;
+    char data[128];
+    char *key, *value, *end;
+    int len = -1;
+
+    fd = fopen(path, "r");
+    if (fd == NULL) {
+        ERROR("cannot open %s\n", path);
+        goto oops;
+    }
+
+    while (fgets(data, sizeof(data), fd)) {
+        key = data;
+        value = strchr(key, ':');
+        if (value == 0)
+            continue;
+        *value++ = 0;
+
+        if (strncmp(key, "Serial", 6))
+            continue;
+
+        while (isspace(*value))
+            value++;
+
+        end = strchr(value, '\n');
+        *end = 0;
+        len = snprintf(buf, size, "%s", value);
+        break;
+    }
+
+    fclose(fd);
+oops:
+    return len;
+}
+
+static void export_kernel_boot_props(void)
+{
+    char tmp[PROP_VALUE_MAX];
+    int ret;
+    unsigned i;
+    struct {
+        const char *src_prop;
+        const char *dest_prop;
+        const char *def_val;
+    } prop_map[] = {
+        { "ro.boot.serialno", "ro.serialno", "", },
+        { "ro.boot.mode", "ro.bootmode", "unknown", },
+        { "ro.boot.baseband", "ro.baseband", "unknown", },
+        { "ro.boot.bootloader", "ro.bootloader", "unknown", },
+    };
+    char buf[32] = {0};
+
+    if (get_chip_id(buf, sizeof(buf)) < 0) {
+        ERROR("get chip id failed\n");
+    } else {
+        property_set("ro.boot.serialno", buf);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(prop_map); i++) {
+        ret = property_get(prop_map[i].src_prop, tmp);
+        if (ret > 0)
+            property_set(prop_map[i].dest_prop, tmp);
+        else
+            property_set(prop_map[i].dest_prop, prop_map[i].def_val);
+    }
+
+    ret = property_get("ro.boot.console", tmp);
+    if (ret)
+        strlcpy(console, tmp, sizeof(console));
+
+    /* save a copy for init's usage during boot */
+    property_get("ro.bootmode", tmp);
+    strlcpy(bootmode, tmp, sizeof(bootmode));
+
+    /* if this was given on kernel command line, override what we read
+     * before (e.g. from /proc/cpuinfo), if anything */
+    ret = property_get("ro.boot.hardware", tmp);
+    if (ret)
+        strlcpy(hardware, tmp, sizeof(hardware));
+    property_set("ro.hardware", hardware);
+
+    snprintf(tmp, PROP_VALUE_MAX, "%d", revision);
+    property_set("ro.revision", tmp);
+
+    /* TODO: these are obsolete. We should delete them */
+    if (!strcmp(bootmode,"factory"))
+        property_set("ro.factorytest", "1");
+    else if (!strcmp(bootmode,"factory2"))
+        property_set("ro.factorytest", "2");
+    else
+        property_set("ro.factorytest", "0");
+}
+
+static void process_kernel_cmdline(void)
+{
+    /* don't expose the raw commandline to nonpriv processes */
+    chmod("/proc/cmdline", 0440);
+
+    /* first pass does the common stuff, and finds if we are in qemu.
+     * second pass is only necessary for qemu to export all kernel params
+     * as props.
+     */
+    import_kernel_cmdline(0, import_kernel_nv);
+    if (qemu[0])
+        import_kernel_cmdline(1, import_kernel_nv);
+
+    /* now propogate the info given on command line to internal variables
+     * used by init as well as the current required properties
+     */
+    export_kernel_boot_props();
+}
+
+static int property_service_init_action(int nargs, char **args)
+{
+    /* read any property files on system or data and
+     * fire up the property service.  This must happen
+     * after the ro.foo properties are set above so
+     * that /data/local.prop cannot interfere with them.
+     */
+    start_property_service();
+    if (get_property_set_fd() < 0) {
+        ERROR("start_property_service() failed\n");
+        exit(1);
+    }
+
+    return 0;
+}
+
+static int signal_init_action(int nargs, char **args)
+{
+    signal_init();
+    if (get_signal_fd() < 0) {
+        ERROR("signal_init() failed\n");
+        exit(1);
+    }
+    return 0;
+}
+
+static int queue_property_triggers_action(int nargs, char **args)
+{
+    queue_all_property_triggers();
+    /* enable property triggers */
+    property_triggers_enabled = 1;
+    return 0;
+}
+
+#if BOOTCHART
+static int bootchart_init_action(int nargs, char **args)
+{
+    bootchart_count = bootchart_init();
+    if (bootchart_count < 0) {
+        ERROR("bootcharting init failure\n");
+    } else if (bootchart_count > 0) {
+        NOTICE("bootcharting started (period=%d ms)\n", bootchart_count*BOOTCHART_POLLING_MS);
+    } else {
+        NOTICE("bootcharting ignored\n");
+    }
+
+    return 0;
+}
+#endif
+
+static const struct selinux_opt seopts_prop[] = {
+        { SELABEL_OPT_PATH, "/property_contexts" },
+        { SELABEL_OPT_PATH, "/data/security/current/property_contexts" },
+        { 0, NULL }
+};
+
+struct selabel_handle* selinux_android_prop_context_handle(void)
+{
+    int policy_index = selinux_android_use_data_policy() ? 1 : 0;
+    struct selabel_handle* sehandle = selabel_open(SELABEL_CTX_ANDROID_PROP,
+                                                   &seopts_prop[policy_index], 1);
+    if (!sehandle) {
+        ERROR("SELinux:  Could not load property_contexts:  %s\n",
+              strerror(errno));
+        return NULL;
+    }
+    INFO("SELinux: Loaded property contexts from %s\n", seopts_prop[policy_index].value);
+    return sehandle;
+}
+
+void selinux_init_all_handles(void)
+{
+    sehandle = selinux_android_file_context_handle();
+    selinux_android_set_sehandle(sehandle);
+    sehandle_prop = selinux_android_prop_context_handle();
+}
+
+static bool selinux_is_disabled(void)
+{
+#ifdef ALLOW_DISABLE_SELINUX
+    char tmp[PROP_VALUE_MAX];
+
+    if (access("/sys/fs/selinux", F_OK) != 0) {
+        /* SELinux is not compiled into the kernel, or has been disabled
+         * via the kernel command line "selinux=0".
+         */
+        return true;
+    }
+
+    if ((property_get("ro.boot.selinux", tmp) != 0) && (strcmp(tmp, "disabled") == 0)) {
+        /* SELinux is compiled into the kernel, but we've been told to disable it. */
+        return true;
+    }
+#endif
+
+    return false;
+}
+
+static bool selinux_is_enforcing(void)
+{
+#ifdef ALLOW_DISABLE_SELINUX
+    char tmp[PROP_VALUE_MAX];
+
+    if (property_get("ro.boot.selinux", tmp) == 0) {
+        /* Property is not set.  Assume enforcing */
+        return true;
+    }
+
+    if (strcmp(tmp, "permissive") == 0) {
+        /* SELinux is in the kernel, but we've been told to go into permissive mode */
+        return false;
+    }
+
+    if (strcmp(tmp, "enforcing") != 0) {
+        ERROR("SELinux: Unknown value of ro.boot.selinux. Got: \"%s\". Assuming enforcing.\n", tmp);
+    }
+
+#endif
+    return true;
+}
+
+int selinux_reload_policy(void)
+{
+    if (selinux_is_disabled()) {
+        return -1;
+    }
+
+    INFO("SELinux: Attempting to reload policy files\n");
+
+    if (selinux_android_reload_policy() == -1) {
+        return -1;
+    }
+
+    if (sehandle)
+        selabel_close(sehandle);
+
+    if (sehandle_prop)
+        selabel_close(sehandle_prop);
+
+    selinux_init_all_handles();
+    return 0;
+}
+
+static int audit_callback(void *data, security_class_t cls __attribute__((unused)), char *buf, size_t len)
+{
+    snprintf(buf, len, "property=%s", !data ? "NULL" : (char *)data);
+    return 0;
+}
+
+int log_callback(int type, const char *fmt, ...)
+{
+    int level;
+    va_list ap;
+    switch (type) {
+    case SELINUX_WARNING:
+        level = KLOG_WARNING_LEVEL;
+        break;
+    case SELINUX_INFO:
+        level = KLOG_INFO_LEVEL;
+        break;
+    default:
+        level = KLOG_ERROR_LEVEL;
+        break;
+    }
+    va_start(ap, fmt);
+    klog_vwrite(level, fmt, ap);
+    va_end(ap);
+    return 0;
+}
+
+static void selinux_initialize(void)
+{
+    if (selinux_is_disabled()) {
+        return;
+    }
+
+    INFO("loading selinux policy\n");
+    if (selinux_android_load_policy() < 0) {
+        ERROR("SELinux: Failed to load policy; rebooting into recovery mode\n");
+        android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
+        while (1) { pause(); }  // never reached
+    }
+
+    selinux_init_all_handles();
+    bool is_enforcing = selinux_is_enforcing();
+    INFO("SELinux: security_setenforce(%d)\n", is_enforcing);
+    security_setenforce(is_enforcing);
+}
+
+#include "init_mem_opt.c"
+int main(int argc, char **argv)
+{
+    int fd_count = 0;
+    struct pollfd ufds[4];
+    char *tmpdev;
+    char* debuggable;
+    char tmp[32];
+    int property_set_fd_init = 0;
+    int signal_fd_init = 0;
+    int keychord_fd_init = 0;
+    bool is_charger = false;
+
+    if (!strcmp(basename(argv[0]), "ueventd"))
+        return ueventd_main(argc, argv);
+
+    if (!strcmp(basename(argv[0]), "watchdogd"))
+        return watchdogd_main(argc, argv);
+
+    /* clear the umask */
+    umask(0);
+
+        /* Get the basic filesystem setup we need put
+         * together in the initramdisk on / and then we'll
+         * let the rc file figure out the rest.
+         */
+    mkdir("/dev", 0755);
+    mkdir("/proc", 0755);
+    mkdir("/sys", 0755);
+
+    mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
+    mkdir("/dev/pts", 0755);
+    mkdir("/dev/socket", 0755);
+    mount("devpts", "/dev/pts", "devpts", 0, NULL);
+    mount("proc", "/proc", "proc", 0, NULL);
+    mount("sysfs", "/sys", "sysfs", 0, NULL);
+
+        /* indicate that booting is in progress to background fw loaders, etc */
+    close(open("/dev/.booting", O_WRONLY | O_CREAT, 0000));
+
+        /* We must have some place other than / to create the
+         * device nodes for kmsg and null, otherwise we won't
+         * be able to remount / read-only later on.
+         * Now that tmpfs is mounted on /dev, we can actually
+         * talk to the outside world.
+         */
+    open_devnull_stdio();
+    klog_init();
+    property_init();
+
+    get_hardware_name(hardware, &revision);
+
+    process_kernel_cmdline();
+
+    union selinux_callback cb;
+    cb.func_log = log_callback;
+    selinux_set_callback(SELINUX_CB_LOG, cb);
+
+    cb.func_audit = audit_callback;
+    selinux_set_callback(SELINUX_CB_AUDIT, cb);
+
+    selinux_initialize();
+    /* These directories were necessarily created before initial policy load
+     * and therefore need their security context restored to the proper value.
+     * This must happen before /dev is populated by ueventd.
+     */
+    restorecon("/dev");
+    restorecon("/dev/socket");
+    restorecon("/dev/__properties__");
+    restorecon_recursive("/sys");
+
+    is_charger = !strcmp(bootmode, "charger");
+
+    NOTICE("property init\n");
+    property_load_boot_defaults();
+
+    NOTICE("reading config file\n");
+    init_parse_config_file("/init.rc");
+
+    action_for_each_trigger("early-init", action_add_queue_tail);
+
+          ERROR("/dev/hw_random not found1111111\n");
+    queue_builtin_action(wait_for_coldboot_done_action, "wait_for_coldboot_done");
+          ERROR("/dev/hw_random not found2222222\n");
+    queue_builtin_action(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");
+          ERROR("/dev/hw_random not found3333333\n");
+    queue_builtin_action(keychord_init_action, "keychord_init");
+          ERROR("/dev/hw_random not found4444444\n");
+    queue_builtin_action(console_init_action, "console_init");
+
+          ERROR("/dev/hw_random not found5555555\n");
+
+    /* execute all the boot actions to get us started */
+    action_for_each_trigger("init", action_add_queue_tail);
+
+          ERROR("/dev/hw_random not found6666666\n");
+    /* Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random
+     * wasn't ready immediately after wait_for_coldboot_done
+     */
+    queue_builtin_action(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");
+    queue_builtin_action(property_service_init_action, "property_service_init");
+    queue_builtin_action(signal_init_action, "signal_init");
+
+    /* Don't mount filesystems or start core system services if in charger mode. */
+    if (is_charger) {
+        action_for_each_trigger("charger", action_add_queue_tail);
+    } else {
+        action_for_each_trigger("late-init", action_add_queue_tail);
+    }
+
+    /* run all property triggers based on current state of the properties */
+    queue_builtin_action(queue_property_triggers_action, "queue_property_triggers");
+          ERROR("/dev/hw_random not found77777\n");
+
+
+#if BOOTCHART
+    queue_builtin_action(bootchart_init_action, "bootchart_init");
+#endif
+
+          ERROR("/dev/hw_random not found888888888\n");
+    for(;;) {
+        int nr, i, timeout = -1;
+
+        execute_one_command();
+        restart_processes();
+
+        if (!property_set_fd_init && get_property_set_fd() > 0) {
+            ufds[fd_count].fd = get_property_set_fd();
+            ufds[fd_count].events = POLLIN;
+            ufds[fd_count].revents = 0;
+            fd_count++;
+            property_set_fd_init = 1;
+        }
+        if (!signal_fd_init && get_signal_fd() > 0) {
+            ufds[fd_count].fd = get_signal_fd();
+            ufds[fd_count].events = POLLIN;
+            ufds[fd_count].revents = 0;
+            fd_count++;
+            signal_fd_init = 1;
+        }
+        if (!keychord_fd_init && get_keychord_fd() > 0) {
+            ufds[fd_count].fd = get_keychord_fd();
+            ufds[fd_count].events = POLLIN;
+            ufds[fd_count].revents = 0;
+            fd_count++;
+            keychord_fd_init = 1;
+        }
+
+        if (process_needs_restart) {
+            timeout = (process_needs_restart - gettime()) * 1000;
+            if (timeout < 0)
+                timeout = 0;
+        }
+
+        if (!action_queue_empty() || cur_action)
+            timeout = 0;
+
+#if BOOTCHART
+        if (bootchart_count > 0) {
+            if (timeout < 0 || timeout > BOOTCHART_POLLING_MS)
+                timeout = BOOTCHART_POLLING_MS;
+            if (bootchart_step() < 0 || --bootchart_count == 0) {
+                bootchart_finish();
+                bootchart_count = 0;
+            }
+        }
+#endif
+
+        nr = poll(ufds, fd_count, timeout);
+        if (nr <= 0)
+            continue;
+
+        for (i = 0; i < fd_count; i++) {
+            if (ufds[i].revents & POLLIN) {
+                if (ufds[i].fd == get_property_set_fd())
+                    handle_property_set_fd();
+                else if (ufds[i].fd == get_keychord_fd())
+                    handle_keychord();
+                else if (ufds[i].fd == get_signal_fd())
+                    handle_signal();
+            }
+        }
+    }
+
+    return 0;
+}
diff --git a/init.h b/init.h
new file mode 100644
index 0000000..a7615a3
--- /dev/null
+++ b/init.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_INIT_H
+#define _INIT_INIT_H
+
+#include <cutils/list.h>
+
+#include <sys/stat.h>
+
+void handle_control_message(const char *msg, const char *arg);
+
+struct command
+{
+        /* list of commands in an action */
+    struct listnode clist;
+
+    int (*func)(int nargs, char **args);
+
+    int line;
+    const char *filename;
+
+    int nargs;
+    char *args[1];
+};
+
+struct action {
+        /* node in list of all actions */
+    struct listnode alist;
+        /* node in the queue of pending actions */
+    struct listnode qlist;
+        /* node in list of actions for a trigger */
+    struct listnode tlist;
+
+    unsigned hash;
+    const char *name;
+
+    struct listnode commands;
+    struct command *current;
+};
+
+struct socketinfo {
+    struct socketinfo *next;
+    const char *name;
+    const char *type;
+    uid_t uid;
+    gid_t gid;
+    int perm;
+    const char *socketcon;
+};
+
+struct svcenvinfo {
+    struct svcenvinfo *next;
+    const char *name;
+    const char *value;
+};
+
+#define SVC_DISABLED    0x01  /* do not autostart with class */
+#define SVC_ONESHOT     0x02  /* do not restart on exit */
+#define SVC_RUNNING     0x04  /* currently active */
+#define SVC_RESTARTING  0x08  /* waiting to restart */
+#define SVC_CONSOLE     0x10  /* requires console */
+#define SVC_CRITICAL    0x20  /* will reboot into recovery if keeps crashing */
+#define SVC_RESET       0x40  /* Use when stopping a process, but not disabling
+                                 so it can be restarted with its class */
+#define SVC_RC_DISABLED 0x80  /* Remember if the disabled flag was set in the rc script */
+#define SVC_RESTART     0x100 /* Use to safely restart (stop, wait, start) a service */
+#define SVC_DISABLED_START 0x200 /* a start was requested but it was disabled at the time */
+
+#define NR_SVC_SUPP_GIDS 12    /* twelve supplementary groups */
+
+#define COMMAND_RETRY_TIMEOUT 5
+
+struct service {
+        /* list of all services */
+    struct listnode slist;
+
+    const char *name;
+    const char *classname;
+
+    unsigned flags;
+    pid_t pid;
+    time_t time_started;    /* time of last start */
+    time_t time_crashed;    /* first crash within inspection window */
+    int nr_crashed;         /* number of times crashed within window */
+    
+    uid_t uid;
+    gid_t gid;
+    gid_t supp_gids[NR_SVC_SUPP_GIDS];
+    size_t nr_supp_gids;
+
+    char *seclabel;
+
+    struct socketinfo *sockets;
+    struct svcenvinfo *envvars;
+
+    struct action onrestart;  /* Actions to execute on restart. */
+    
+    /* keycodes for triggering this service via /dev/keychord */
+    int *keycodes;
+    int nkeycodes;
+    int keychord_id;
+
+    int ioprio_class;
+    int ioprio_pri;
+
+    int nargs;
+    /* "MUST BE AT THE END OF THE STRUCT" */
+    char *args[1];
+}; /*     ^-------'args' MUST be at the end of this struct! */
+
+void notify_service_state(const char *name, const char *state);
+
+struct service *service_find_by_name(const char *name);
+struct service *service_find_by_pid(pid_t pid);
+struct service *service_find_by_keychord(int keychord_id);
+void service_for_each(void (*func)(struct service *svc));
+void service_for_each_class(const char *classname,
+                            void (*func)(struct service *svc));
+void service_for_each_flags(unsigned matchflags,
+                            void (*func)(struct service *svc));
+void service_stop(struct service *svc);
+void service_reset(struct service *svc);
+void service_restart(struct service *svc);
+void service_start(struct service *svc, const char *dynamic_args);
+void property_changed(const char *name, const char *value);
+
+extern struct selabel_handle *sehandle;
+extern struct selabel_handle *sehandle_prop;
+extern int selinux_reload_policy(void);
+
+#endif	/* _INIT_INIT_H */
diff --git a/init_mem_opt.c b/init_mem_opt.c
new file mode 100755
index 0000000..757f321
--- /dev/null
+++ b/init_mem_opt.c
@@ -0,0 +1,346 @@
+/*
+ * memory optimization code
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <mtd/mtd-user.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+#include <selinux/android.h>
+
+#include <libgen.h>
+
+#include <cutils/list.h>
+#include <cutils/android_reboot.h>
+#include <cutils/sockets.h>
+#include <cutils/iosched_policy.h>
+#include <cutils/fs.h>
+#include <private/android_filesystem_config.h>
+#include <termios.h>
+
+#include "devices.h"
+#include "init.h"
+#include "log.h"
+#include "property_service.h"
+#include "bootchart.h"
+#include "signal_handler.h"
+#include "keychords.h"
+#include "init_parser.h"
+#include "util.h"
+#include "ueventd.h"
+#include "watchdogd.h"
+
+int g_total_mem = 0; /* unit: MB */
+
+static int get_dram_size(void)
+{
+#define MEMINFO_NODE	"/proc/meminfo"
+	FILE *fd;
+	char data[128], *tmp;
+	int dram_size = 1024;
+
+	fd = fopen(MEMINFO_NODE, "r");
+	if (fd == NULL) {
+		ERROR("cannot open %s, return default 1G\n", MEMINFO_NODE);
+		goto end;
+	}
+
+	while (fgets(data, sizeof(data), fd)) {
+		if (strstr(data, "MemTotal")) {
+			tmp = strchr(data, ':') + 1;
+            dram_size = atoi(tmp) >> 10; /* convert to MBytes */
+            break;
+        }
+    }
+
+	fclose(fd);
+end:
+    INFO("%s: return %d\n", __func__, dram_size);
+	return dram_size;
+}
+
+static bool get_lcd_resolution(int *width, int *height)
+{
+#define LCD_X_STR			"lcd_x          int       "
+#define LCD_Y_STR			"lcd_y          int       "
+#define DISP_SYS_NODE		"/sys/class/script/dump"
+#define SCRIPT_BUF_SIZE		0x10000
+	char *data = NULL, *temp;
+	bool ret = false;
+	int fd;
+
+	if (!width || !height)
+		return false;
+
+	data = malloc(SCRIPT_BUF_SIZE);
+	if (!data) {
+		ERROR("%s err: alloc data buf failed\n", __func__);
+		return false;
+	}
+	memset(data, 0, SCRIPT_BUF_SIZE);
+
+	fd = open(DISP_SYS_NODE, O_RDWR);
+	if (fd < 0) {
+		ERROR("%s err: cannot open %s\n", __func__, DISP_SYS_NODE);
+		free(data);
+		return false;
+	}
+
+	if (write(fd, "lcd0_para", strlen("lcd0_para")) < 0) {
+		ERROR("%s err: write lcd0_para to %s failed\n", __func__, DISP_SYS_NODE);
+		goto end;
+	}
+	if (read(fd, data, SCRIPT_BUF_SIZE) < 0) {
+		ERROR("%s err: read /sys/class/script/dump failed\n", __func__);
+		goto end;
+	}
+
+	/* get lcd_x */
+	temp = strstr(data, LCD_X_STR);
+	if (!temp) {
+		ERROR("%s err: get lcd_x failed\n", __func__);
+		goto end;
+	} else
+		temp += strlen(LCD_X_STR);
+	if (width)
+		*width = atoi(temp);
+
+	/* get lcd_y */
+	temp = strstr(data, LCD_Y_STR);
+	if (!temp) {
+		ERROR("%s err: get lcd_y failed\n", __func__);
+		goto end;
+	} else
+		temp += strlen(LCD_Y_STR);
+	if (height)
+		*height = atoi(temp);
+
+	ret = true;
+
+end:
+	close(fd);
+	free(data);
+	return ret;
+}
+
+inline void trim(char *buf)
+{
+	char *temp, lastch;
+	int i = 0, first_valid = false;
+
+	if (!buf || *buf == 0)
+		return;
+
+	/* trim tail */
+	while ((temp = buf + strlen(buf) - 1) && *temp != 0) {
+		if (*temp==' ' || *temp=='\t'
+				|| *temp=='\n' || *temp=='\r')
+			*temp = 0;
+		else
+			break;
+	}
+
+	if (*buf == 0)
+		return;
+
+	/* trim head */
+	while (i < (int)strlen(buf)) {
+		if (buf[i]==' ' || buf[i]=='\t'
+				|| buf[i]=='\n' || buf[i]=='\r') {
+			i++;
+			continue;
+		} else if (buf[i] != 0) {
+			strcpy(buf, &buf[i]);
+			break;
+		} else {
+			buf[0] = 0;
+			break;
+		}
+	}
+}
+
+#define CONFIG_MEM_FILE		"/config_mem.ini"
+
+void config_item(char *buf)
+{
+	char data[1024], key[256], value[256];
+	bool find = false;
+	FILE *fd;
+	int len;
+
+	fd = fopen(CONFIG_MEM_FILE, "r");
+	if (fd == NULL) {
+		ERROR("cannot open %s\n", CONFIG_MEM_FILE);
+		return;
+	}
+
+	while (!feof(fd)) {
+		if (!fgets(data, sizeof(data), fd)) /* eof or read error */
+			continue;
+
+		if (strlen(data) >= sizeof(data) - 1) {
+			ERROR("%s err: line too long!\n", __func__);
+			goto end;
+		}
+
+		trim(data);
+
+        if (data[0]=='#' || data[0]==0) /* comment or blank line */
+			continue;
+
+		if (!find) {
+			if (data[0]=='[' && strstr(data, buf)) {
+				find = true;
+				continue;
+			}
+        } else {
+			if (data[0]=='[')
+				break; /* NEXT item, so break */
+			else if (!strstr(data, "=") || data[strlen(data)-1] == '=')
+				continue; /* not key=value style, or has no value field */
+
+			len = strlen(data) - strlen(strstr(data, "="));
+			strncpy(key, data, len);
+			key[len] = '\0';
+			trim(key);
+
+			strcpy(value, strstr(data, "=") + 1);
+			trim(value);
+
+			INFO("%s: get key->value %s %s\n", __func__, key, value);
+			if (key[0] == '/')  { /* file node, as: /sys/class/adj=12 */
+				sprintf(data, "echo %s > %s", value, key);
+				system(data);
+			} else /* property node, as: dalvik.vm.heapsize=184m */
+				property_set(key, value);
+        }
+    }
+
+end:
+	fclose(fd);
+}
+
+bool get_value_for_key(char *main_key, char *sub_key, char ret_value[], int len)
+{
+	char data[1024], tmp[256];
+	bool find_mainkey = false, ret = false;
+	FILE *fd = NULL;
+
+	fd = fopen(CONFIG_MEM_FILE, "r");
+	if (fd == NULL) {
+		ERROR("cannot open %s\n", CONFIG_MEM_FILE);
+		return false;
+	}
+
+	while (!feof(fd)) {
+		if (!fgets(data, sizeof(data), fd)) /* eof or read error */
+			continue;
+
+		if (strlen(data) >= sizeof(data) - 1) {
+			ERROR("%s err: line too long!\n", __func__);
+			goto end;
+		}
+
+		trim(data);
+
+        if (data[0]=='#' || data[0]==0) /* comment or blank line */
+			continue;
+
+		if (!find_mainkey) {
+			if (data[0]=='[' && !strncmp(data+1, main_key,
+				strlen(main_key))) { /* +1 means omit '[' */
+				find_mainkey = true;
+				continue;
+			}
+        } else {
+			if (data[0]=='[')
+				goto end; /* NEXT item, so break */
+			else if (!strstr(data, "=") || data[strlen(data)-1] == '=')
+				continue; /* not 'key = value' style, or has no value field */
+
+			len = strlen(data) - strlen(strstr(data, "="));
+			strncpy(tmp, data, len);
+			tmp[len] = '\0';
+			trim(tmp);
+
+			if (strcmp(tmp, sub_key))
+				continue; /* not subkey */
+
+			strcpy(tmp, strstr(data, "=") + 1);
+			trim(tmp);
+			if ((int)strlen(tmp) >= len) {
+				ERROR("%s err: %s->%s value too long!\n", __func__, main_key, sub_key);
+				goto end;
+			}
+	
+			NOTICE("%s: get %s->%s: %s\n", __func__, main_key, sub_key, tmp);
+			strcpy(ret_value, tmp);
+			ret = true;
+			break;
+        }
+    }
+
+end:
+	fclose(fd);
+	return ret;
+}
+
+void property_opt_for_mem(void)
+{
+	char buf[PROP_VALUE_MAX] = {0};
+	static int width = 0, height = 0;
+
+	NOTICE("%s: start!\n", __func__);
+	if(property_get("ro.memopt.disable", buf) && !strcmp(buf,"true")) {
+		NOTICE("%s: disable adaptive memory function!\n", __func__);
+		return;
+	}
+
+	if (!g_total_mem)
+		g_total_mem = get_dram_size();
+
+	if (g_total_mem <= 512)
+		property_set("ro.config.low_ram", "true");
+	else
+		property_set("ro.config.low_ram", "false");
+
+	if (!width || !height) {
+		if (!get_lcd_resolution(&width, &height)) {
+			NOTICE("%s: get lcd resolution failed!\n", __func__);
+			return;
+		}
+	}
+
+	/* dalvik heap para */
+	if (g_total_mem <= 512)
+		strcpy(buf, "dalvik_512m");
+	else if (g_total_mem > 512 && g_total_mem <= 1024)
+		strcpy(buf, "dalvik_1024m");
+	else if (g_total_mem > 1024 && g_total_mem <= 2048)
+		strcpy(buf, "dalvik_2048m");
+	config_item(buf);
+	/* hwui para */
+	sprintf(buf, "hwui_%d", (width > height ? width : height));
+	config_item(buf);
+
+	system("echo 12000 > /sys/module/lowmemorykiller/parameters/minfree");
+	NOTICE("%s: end!\n", __func__);
+}
+
diff --git a/init_parser.c b/init_parser.c
new file mode 100644
index 0000000..39a122a
--- /dev/null
+++ b/init_parser.c
@@ -0,0 +1,879 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stddef.h>
+#include <ctype.h>
+
+#include "init.h"
+#include "parser.h"
+#include "init_parser.h"
+#include "log.h"
+#include "property_service.h"
+#include "util.h"
+
+#include <cutils/iosched_policy.h>
+#include <cutils/list.h>
+
+static list_declare(service_list);
+static list_declare(action_list);
+static list_declare(action_queue);
+
+struct import {
+    struct listnode list;
+    const char *filename;
+};
+
+static void *parse_service(struct parse_state *state, int nargs, char **args);
+static void parse_line_service(struct parse_state *state, int nargs, char **args);
+
+static void *parse_action(struct parse_state *state, int nargs, char **args);
+static void parse_line_action(struct parse_state *state, int nargs, char **args);
+
+#define SECTION 0x01
+#define COMMAND 0x02
+#define OPTION  0x04
+
+#include "keywords.h"
+
+#define KEYWORD(symbol, flags, nargs, func) \
+    [ K_##symbol ] = { #symbol, func, nargs + 1, flags, },
+
+static struct {
+    const char *name;
+    int (*func)(int nargs, char **args);
+    unsigned char nargs;
+    unsigned char flags;
+} keyword_info[KEYWORD_COUNT] = {
+    [ K_UNKNOWN ] = { "unknown", 0, 0, 0 },
+#include "keywords.h"
+};
+#undef KEYWORD
+
+#define kw_is(kw, type) (keyword_info[kw].flags & (type))
+#define kw_name(kw) (keyword_info[kw].name)
+#define kw_func(kw) (keyword_info[kw].func)
+#define kw_nargs(kw) (keyword_info[kw].nargs)
+
+static int lookup_keyword(const char *s)
+{
+    switch (*s++) {
+    case 'c':
+    if (!strcmp(s, "opy")) return K_copy;
+        if (!strcmp(s, "apability")) return K_capability;
+        if (!strcmp(s, "hdir")) return K_chdir;
+        if (!strcmp(s, "hroot")) return K_chroot;
+        if (!strcmp(s, "lass")) return K_class;
+        if (!strcmp(s, "lass_start")) return K_class_start;
+        if (!strcmp(s, "lass_stop")) return K_class_stop;
+        if (!strcmp(s, "lass_reset")) return K_class_reset;
+        if (!strcmp(s, "onsole")) return K_console;
+        if (!strcmp(s, "hown")) return K_chown;
+        if (!strcmp(s, "hmod")) return K_chmod;
+        if (!strcmp(s, "ritical")) return K_critical;
+        break;
+    case 'd':
+        if (!strcmp(s, "isabled")) return K_disabled;
+        if (!strcmp(s, "omainname")) return K_domainname;
+        break;
+    case 'e':
+        if (!strcmp(s, "nable")) return K_enable;
+        if (!strcmp(s, "xec")) return K_exec;
+        if (!strcmp(s, "xport")) return K_export;
+        break;
+    case 'f':
+        if (!strcmp(s, "ormat_userdata")) return K_format_userdata;
+        break;
+    case 'g':
+        if (!strcmp(s, "roup")) return K_group;
+        break;
+    case 'h':
+        if (!strcmp(s, "ostname")) return K_hostname;
+        break;
+    case 'i':
+        if (!strcmp(s, "oprio")) return K_ioprio;
+        if (!strcmp(s, "fup")) return K_ifup;
+        if (!strcmp(s, "nsmod")) return K_insmod;
+        if (!strcmp(s, "mport")) return K_import;
+        break;
+    case 'k':
+        if (!strcmp(s, "eycodes")) return K_keycodes;
+        break;
+    case 'l':
+        if (!strcmp(s, "oglevel")) return K_loglevel;
+        if (!strcmp(s, "oad_persist_props")) return K_load_persist_props;
+        if (!strcmp(s, "oad_all_props")) return K_load_all_props;
+        break;
+    case 'm':
+        if (!strcmp(s, "kdir")) return K_mkdir;
+        if (!strcmp(s, "ount_all")) return K_mount_all;
+        if (!strcmp(s, "ount")) return K_mount;
+        break;
+    case 'o':
+        if (!strcmp(s, "n")) return K_on;
+        if (!strcmp(s, "neshot")) return K_oneshot;
+        if (!strcmp(s, "nrestart")) return K_onrestart;
+        break;
+    case 'p':
+        if (!strcmp(s, "owerctl")) return K_powerctl;
+    case 'r':
+        if (!strcmp(s, "estart")) return K_restart;
+        if (!strcmp(s, "estorecon")) return K_restorecon;
+        if (!strcmp(s, "estorecon_recursive")) return K_restorecon_recursive;
+        if (!strcmp(s, "mdir")) return K_rmdir;
+        if (!strcmp(s, "m")) return K_rm;
+        break;
+    case 's':
+        if (!strcmp(s, "eclabel")) return K_seclabel;
+        if (!strcmp(s, "ervice")) return K_service;
+        if (!strcmp(s, "etcon")) return K_setcon;
+        if (!strcmp(s, "etenforce")) return K_setenforce;
+        if (!strcmp(s, "etenv")) return K_setenv;
+        if (!strcmp(s, "etkey")) return K_setkey;
+        if (!strcmp(s, "etprop")) return K_setprop;
+        if (!strcmp(s, "etrlimit")) return K_setrlimit;
+        if (!strcmp(s, "etsebool")) return K_setsebool;
+        if (!strcmp(s, "ocket")) return K_socket;
+        if (!strcmp(s, "tart")) return K_start;
+        if (!strcmp(s, "top")) return K_stop;
+        if (!strcmp(s, "wapon_all")) return K_swapon_all;
+        if (!strcmp(s, "ymlink")) return K_symlink;
+        if (!strcmp(s, "ysclktz")) return K_sysclktz;
+        break;
+    case 't':
+        if (!strcmp(s, "rigger")) return K_trigger;
+        break;
+    case 'u':
+        if (!strcmp(s, "ser")) return K_user;
+        break;
+    case 'w':
+        if (!strcmp(s, "rite")) return K_write;
+        if (!strcmp(s, "ait")) return K_wait;
+        break;
+    }
+    return K_UNKNOWN;
+}
+
+static void parse_line_no_op(struct parse_state *state, int nargs, char **args)
+{
+}
+
+static int push_chars(char **dst, int *len, const char *chars, int cnt)
+{
+    if (cnt > *len)
+        return -1;
+
+    memcpy(*dst, chars, cnt);
+    *dst += cnt;
+    *len -= cnt;
+
+    return 0;
+}
+
+int expand_props(char *dst, const char *src, int dst_size)
+{
+    int cnt = 0;
+    char *dst_ptr = dst;
+    const char *src_ptr = src;
+    int src_len;
+    int idx = 0;
+    int ret = 0;
+    int left = dst_size - 1;
+
+    if (!src || !dst || dst_size == 0)
+        return -1;
+
+    src_len = strlen(src);
+
+    /* - variables can either be $x.y or ${x.y}, in case they are only part
+     *   of the string.
+     * - will accept $$ as a literal $.
+     * - no nested property expansion, i.e. ${foo.${bar}} is not supported,
+     *   bad things will happen
+     */
+    while (*src_ptr && left > 0) {
+        char *c;
+        char prop[PROP_NAME_MAX + 1];
+        char prop_val[PROP_VALUE_MAX];
+        int prop_len = 0;
+        int prop_val_len;
+
+        c = strchr(src_ptr, '$');
+        if (!c) {
+            while (left-- > 0 && *src_ptr)
+                *(dst_ptr++) = *(src_ptr++);
+            break;
+        }
+
+        memset(prop, 0, sizeof(prop));
+
+        ret = push_chars(&dst_ptr, &left, src_ptr, c - src_ptr);
+        if (ret < 0)
+            goto err_nospace;
+        c++;
+
+        if (*c == '$') {
+            *(dst_ptr++) = *(c++);
+            src_ptr = c;
+            left--;
+            continue;
+        } else if (*c == '\0') {
+            break;
+        }
+
+        if (*c == '{') {
+            c++;
+            while (*c && *c != '}' && prop_len < PROP_NAME_MAX)
+                prop[prop_len++] = *(c++);
+            if (*c != '}') {
+                /* failed to find closing brace, abort. */
+                if (prop_len == PROP_NAME_MAX)
+                    ERROR("prop name too long during expansion of '%s'\n",
+                          src);
+                else if (*c == '\0')
+                    ERROR("unexpected end of string in '%s', looking for }\n",
+                          src);
+                goto err;
+            }
+            prop[prop_len] = '\0';
+            c++;
+        } else if (*c) {
+            while (*c && prop_len < PROP_NAME_MAX)
+                prop[prop_len++] = *(c++);
+            if (prop_len == PROP_NAME_MAX && *c != '\0') {
+                ERROR("prop name too long in '%s'\n", src);
+                goto err;
+            }
+            prop[prop_len] = '\0';
+            ERROR("using deprecated syntax for specifying property '%s', use ${name} instead\n",
+                  prop);
+        }
+
+        if (prop_len == 0) {
+            ERROR("invalid zero-length prop name in '%s'\n", src);
+            goto err;
+        }
+
+        prop_val_len = property_get(prop, prop_val);
+        if (!prop_val_len) {
+            ERROR("property '%s' doesn't exist while expanding '%s'\n",
+                  prop, src);
+            goto err;
+        }
+
+        ret = push_chars(&dst_ptr, &left, prop_val, prop_val_len);
+        if (ret < 0)
+            goto err_nospace;
+        src_ptr = c;
+        continue;
+    }
+
+    *dst_ptr = '\0';
+    return 0;
+
+err_nospace:
+    ERROR("destination buffer overflow while expanding '%s'\n", src);
+err:
+    return -1;
+}
+
+static void parse_import(struct parse_state *state, int nargs, char **args)
+{
+    struct listnode *import_list = state->priv;
+    struct import *import;
+    char conf_file[PATH_MAX];
+    int ret;
+
+    if (nargs != 2) {
+        ERROR("single argument needed for import\n");
+        return;
+    }
+
+    ret = expand_props(conf_file, args[1], sizeof(conf_file));
+    if (ret) {
+        ERROR("error while handling import on line '%d' in '%s'\n",
+              state->line, state->filename);
+        return;
+    }
+
+    import = calloc(1, sizeof(struct import));
+    import->filename = strdup(conf_file);
+    list_add_tail(import_list, &import->list);
+    INFO("found import '%s', adding to import list", import->filename);
+}
+
+static void parse_new_section(struct parse_state *state, int kw,
+                       int nargs, char **args)
+{
+    printf("[ %s %s ]\n", args[0],
+           nargs > 1 ? args[1] : "");
+    switch(kw) {
+    case K_service:
+        state->context = parse_service(state, nargs, args);
+        if (state->context) {
+            state->parse_line = parse_line_service;
+            return;
+        }
+        break;
+    case K_on:
+        state->context = parse_action(state, nargs, args);
+        if (state->context) {
+            state->parse_line = parse_line_action;
+            return;
+        }
+        break;
+    case K_import:
+        parse_import(state, nargs, args);
+        break;
+    }
+    state->parse_line = parse_line_no_op;
+}
+
+static void parse_config(const char *fn, char *s)
+{
+    struct parse_state state;
+    struct listnode import_list;
+    struct listnode *node;
+    char *args[INIT_PARSER_MAXARGS];
+    int nargs;
+
+    nargs = 0;
+    state.filename = fn;
+    state.line = 0;
+    state.ptr = s;
+    state.nexttoken = 0;
+    state.parse_line = parse_line_no_op;
+
+    list_init(&import_list);
+    state.priv = &import_list;
+
+    for (;;) {
+        switch (next_token(&state)) {
+        case T_EOF:
+            state.parse_line(&state, 0, 0);
+            goto parser_done;
+        case T_NEWLINE:
+            state.line++;
+            if (nargs) {
+                int kw = lookup_keyword(args[0]);
+                if (kw_is(kw, SECTION)) {
+                    state.parse_line(&state, 0, 0);
+                    parse_new_section(&state, kw, nargs, args);
+                } else {
+                    state.parse_line(&state, nargs, args);
+                }
+                nargs = 0;
+            }
+            break;
+        case T_TEXT:
+            if (nargs < INIT_PARSER_MAXARGS) {
+                args[nargs++] = state.text;
+            }
+            break;
+        }
+    }
+
+parser_done:
+    list_for_each(node, &import_list) {
+         struct import *import = node_to_item(node, struct import, list);
+         int ret;
+
+         INFO("importing '%s'", import->filename);
+         ret = init_parse_config_file(import->filename);
+         if (ret)
+             ERROR("could not import file '%s' from '%s'\n",
+                   import->filename, fn);
+    }
+}
+
+int init_parse_config_file(const char *fn)
+{
+    char *data;
+    data = read_file(fn, 0);
+    if (!data) return -1;
+
+    parse_config(fn, data);
+    DUMP();
+    return 0;
+}
+
+static int valid_name(const char *name)
+{
+    if (strlen(name) > 16) {
+        return 0;
+    }
+    while (*name) {
+        if (!isalnum(*name) && (*name != '_') && (*name != '-')) {
+            return 0;
+        }
+        name++;
+    }
+    return 1;
+}
+
+struct service *service_find_by_name(const char *name)
+{
+    struct listnode *node;
+    struct service *svc;
+    list_for_each(node, &service_list) {
+        svc = node_to_item(node, struct service, slist);
+        if (!strcmp(svc->name, name)) {
+            return svc;
+        }
+    }
+    return 0;
+}
+
+struct service *service_find_by_pid(pid_t pid)
+{
+    struct listnode *node;
+    struct service *svc;
+    list_for_each(node, &service_list) {
+        svc = node_to_item(node, struct service, slist);
+        if (svc->pid == pid) {
+            return svc;
+        }
+    }
+    return 0;
+}
+
+struct service *service_find_by_keychord(int keychord_id)
+{
+    struct listnode *node;
+    struct service *svc;
+    list_for_each(node, &service_list) {
+        svc = node_to_item(node, struct service, slist);
+        if (svc->keychord_id == keychord_id) {
+            return svc;
+        }
+    }
+    return 0;
+}
+
+void service_for_each(void (*func)(struct service *svc))
+{
+    struct listnode *node;
+    struct service *svc;
+    list_for_each(node, &service_list) {
+        svc = node_to_item(node, struct service, slist);
+        func(svc);
+    }
+}
+
+void service_for_each_class(const char *classname,
+                            void (*func)(struct service *svc))
+{
+    struct listnode *node;
+    struct service *svc;
+    list_for_each(node, &service_list) {
+        svc = node_to_item(node, struct service, slist);
+        if (!strcmp(svc->classname, classname)) {
+            func(svc);
+        }
+    }
+}
+
+void service_for_each_flags(unsigned matchflags,
+                            void (*func)(struct service *svc))
+{
+    struct listnode *node;
+    struct service *svc;
+    list_for_each(node, &service_list) {
+        svc = node_to_item(node, struct service, slist);
+        if (svc->flags & matchflags) {
+            func(svc);
+        }
+    }
+}
+
+void action_for_each_trigger(const char *trigger,
+                             void (*func)(struct action *act))
+{
+    struct listnode *node;
+    struct action *act;
+    list_for_each(node, &action_list) {
+        act = node_to_item(node, struct action, alist);
+        if (!strcmp(act->name, trigger)) {
+            func(act);
+        }
+    }
+}
+
+void queue_property_triggers(const char *name, const char *value)
+{
+    struct listnode *node;
+    struct action *act;
+    list_for_each(node, &action_list) {
+        act = node_to_item(node, struct action, alist);
+        if (!strncmp(act->name, "property:", strlen("property:"))) {
+            const char *test = act->name + strlen("property:");
+            int name_length = strlen(name);
+
+            if (!strncmp(name, test, name_length) &&
+                    test[name_length] == '=' &&
+                    (!strcmp(test + name_length + 1, value) ||
+                     !strcmp(test + name_length + 1, "*"))) {
+                action_add_queue_tail(act);
+            }
+        }
+    }
+}
+
+void queue_all_property_triggers()
+{
+    struct listnode *node;
+    struct action *act;
+    list_for_each(node, &action_list) {
+        act = node_to_item(node, struct action, alist);
+        if (!strncmp(act->name, "property:", strlen("property:"))) {
+            /* parse property name and value
+               syntax is property:<name>=<value> */
+            const char* name = act->name + strlen("property:");
+            const char* equals = strchr(name, '=');
+            if (equals) {
+                char prop_name[PROP_NAME_MAX + 1];
+                char value[PROP_VALUE_MAX];
+                int length = equals - name;
+                if (length > PROP_NAME_MAX) {
+                    ERROR("property name too long in trigger %s", act->name);
+                } else {
+                    int ret;
+                    memcpy(prop_name, name, length);
+                    prop_name[length] = 0;
+
+                    /* does the property exist, and match the trigger value? */
+                    ret = property_get(prop_name, value);
+                    if (ret > 0 && (!strcmp(equals + 1, value) ||
+                                    !strcmp(equals + 1, "*"))) {
+                        action_add_queue_tail(act);
+                    }
+                }
+            }
+        }
+    }
+}
+
+void queue_builtin_action(int (*func)(int nargs, char **args), char *name)
+{
+    struct action *act;
+    struct command *cmd;
+
+    act = calloc(1, sizeof(*act));
+    act->name = name;
+    list_init(&act->commands);
+    list_init(&act->qlist);
+
+    cmd = calloc(1, sizeof(*cmd));
+    cmd->func = func;
+    cmd->args[0] = name;
+    cmd->nargs = 1;
+    list_add_tail(&act->commands, &cmd->clist);
+
+    list_add_tail(&action_list, &act->alist);
+    action_add_queue_tail(act);
+}
+
+void action_add_queue_tail(struct action *act)
+{
+    if (list_empty(&act->qlist)) {
+        list_add_tail(&action_queue, &act->qlist);
+    }
+}
+
+struct action *action_remove_queue_head(void)
+{
+    if (list_empty(&action_queue)) {
+        return 0;
+    } else {
+        struct listnode *node = list_head(&action_queue);
+        struct action *act = node_to_item(node, struct action, qlist);
+        list_remove(node);
+        list_init(node);
+        return act;
+    }
+}
+
+int action_queue_empty()
+{
+    return list_empty(&action_queue);
+}
+
+static void *parse_service(struct parse_state *state, int nargs, char **args)
+{
+    struct service *svc;
+    if (nargs < 3) {
+        parse_error(state, "services must have a name and a program\n");
+        return 0;
+    }
+    if (!valid_name(args[1])) {
+        parse_error(state, "invalid service name '%s'\n", args[1]);
+        return 0;
+    }
+
+    svc = service_find_by_name(args[1]);
+    if (svc) {
+        parse_error(state, "ignored duplicate definition of service '%s'\n", args[1]);
+        return 0;
+    }
+
+    nargs -= 2;
+    svc = calloc(1, sizeof(*svc) + sizeof(char*) * nargs);
+    if (!svc) {
+        parse_error(state, "out of memory\n");
+        return 0;
+    }
+    svc->name = args[1];
+    svc->classname = "default";
+    memcpy(svc->args, args + 2, sizeof(char*) * nargs);
+    svc->args[nargs] = 0;
+    svc->nargs = nargs;
+    svc->onrestart.name = "onrestart";
+    list_init(&svc->onrestart.commands);
+    list_add_tail(&service_list, &svc->slist);
+    return svc;
+}
+
+static void parse_line_service(struct parse_state *state, int nargs, char **args)
+{
+    struct service *svc = state->context;
+    struct command *cmd;
+    int i, kw, kw_nargs;
+
+    if (nargs == 0) {
+        return;
+    }
+
+    svc->ioprio_class = IoSchedClass_NONE;
+
+    kw = lookup_keyword(args[0]);
+    switch (kw) {
+    case K_capability:
+        break;
+    case K_class:
+        if (nargs != 2) {
+            parse_error(state, "class option requires a classname\n");
+        } else {
+            svc->classname = args[1];
+        }
+        break;
+    case K_console:
+        svc->flags |= SVC_CONSOLE;
+        break;
+    case K_disabled:
+        svc->flags |= SVC_DISABLED;
+        svc->flags |= SVC_RC_DISABLED;
+        break;
+    case K_ioprio:
+        if (nargs != 3) {
+            parse_error(state, "ioprio optin usage: ioprio <rt|be|idle> <ioprio 0-7>\n");
+        } else {
+            svc->ioprio_pri = strtoul(args[2], 0, 8);
+
+            if (svc->ioprio_pri < 0 || svc->ioprio_pri > 7) {
+                parse_error(state, "priority value must be range 0 - 7\n");
+                break;
+            }
+
+            if (!strcmp(args[1], "rt")) {
+                svc->ioprio_class = IoSchedClass_RT;
+            } else if (!strcmp(args[1], "be")) {
+                svc->ioprio_class = IoSchedClass_BE;
+            } else if (!strcmp(args[1], "idle")) {
+                svc->ioprio_class = IoSchedClass_IDLE;
+            } else {
+                parse_error(state, "ioprio option usage: ioprio <rt|be|idle> <0-7>\n");
+            }
+        }
+        break;
+    case K_group:
+        if (nargs < 2) {
+            parse_error(state, "group option requires a group id\n");
+        } else if (nargs > NR_SVC_SUPP_GIDS + 2) {
+            parse_error(state, "group option accepts at most %d supp. groups\n",
+                        NR_SVC_SUPP_GIDS);
+        } else {
+            int n;
+            svc->gid = decode_uid(args[1]);
+            for (n = 2; n < nargs; n++) {
+                svc->supp_gids[n-2] = decode_uid(args[n]);
+            }
+            svc->nr_supp_gids = n - 2;
+        }
+        break;
+    case K_keycodes:
+        if (nargs < 2) {
+            parse_error(state, "keycodes option requires atleast one keycode\n");
+        } else {
+            svc->keycodes = malloc((nargs - 1) * sizeof(svc->keycodes[0]));
+            if (!svc->keycodes) {
+                parse_error(state, "could not allocate keycodes\n");
+            } else {
+                svc->nkeycodes = nargs - 1;
+                for (i = 1; i < nargs; i++) {
+                    svc->keycodes[i - 1] = atoi(args[i]);
+                }
+            }
+        }
+        break;
+    case K_oneshot:
+        svc->flags |= SVC_ONESHOT;
+        break;
+    case K_onrestart:
+        nargs--;
+        args++;
+        kw = lookup_keyword(args[0]);
+        if (!kw_is(kw, COMMAND)) {
+            parse_error(state, "invalid command '%s'\n", args[0]);
+            break;
+        }
+        kw_nargs = kw_nargs(kw);
+        if (nargs < kw_nargs) {
+            parse_error(state, "%s requires %d %s\n", args[0], kw_nargs - 1,
+                kw_nargs > 2 ? "arguments" : "argument");
+            break;
+        }
+
+        cmd = malloc(sizeof(*cmd) + sizeof(char*) * nargs);
+        cmd->func = kw_func(kw);
+        cmd->nargs = nargs;
+        memcpy(cmd->args, args, sizeof(char*) * nargs);
+        list_add_tail(&svc->onrestart.commands, &cmd->clist);
+        break;
+    case K_critical:
+        svc->flags |= SVC_CRITICAL;
+        break;
+    case K_setenv: { /* name value */
+        struct svcenvinfo *ei;
+        if (nargs < 3) {
+            parse_error(state, "setenv option requires name and value arguments\n");
+            break;
+        }
+        ei = calloc(1, sizeof(*ei));
+        if (!ei) {
+            parse_error(state, "out of memory\n");
+            break;
+        }
+        ei->name = args[1];
+        ei->value = args[2];
+        ei->next = svc->envvars;
+        svc->envvars = ei;
+        break;
+    }
+    case K_socket: {/* name type perm [ uid gid context ] */
+        struct socketinfo *si;
+        if (nargs < 4) {
+            parse_error(state, "socket option requires name, type, perm arguments\n");
+            break;
+        }
+        if (strcmp(args[2],"dgram") && strcmp(args[2],"stream")
+                && strcmp(args[2],"seqpacket")) {
+            parse_error(state, "socket type must be 'dgram', 'stream' or 'seqpacket'\n");
+            break;
+        }
+        si = calloc(1, sizeof(*si));
+        if (!si) {
+            parse_error(state, "out of memory\n");
+            break;
+        }
+        si->name = args[1];
+        si->type = args[2];
+        si->perm = strtoul(args[3], 0, 8);
+        if (nargs > 4)
+            si->uid = decode_uid(args[4]);
+        if (nargs > 5)
+            si->gid = decode_uid(args[5]);
+        if (nargs > 6)
+            si->socketcon = args[6];
+        si->next = svc->sockets;
+        svc->sockets = si;
+        break;
+    }
+    case K_user:
+        if (nargs != 2) {
+            parse_error(state, "user option requires a user id\n");
+        } else {
+            svc->uid = decode_uid(args[1]);
+        }
+        break;
+    case K_seclabel:
+        if (nargs != 2) {
+            parse_error(state, "seclabel option requires a label string\n");
+        } else {
+            svc->seclabel = args[1];
+        }
+        break;
+
+    default:
+        parse_error(state, "invalid option '%s'\n", args[0]);
+    }
+}
+
+static void *parse_action(struct parse_state *state, int nargs, char **args)
+{
+    struct action *act;
+    if (nargs < 2) {
+        parse_error(state, "actions must have a trigger\n");
+        return 0;
+    }
+    if (nargs > 2) {
+        parse_error(state, "actions may not have extra parameters\n");
+        return 0;
+    }
+    act = calloc(1, sizeof(*act));
+    act->name = args[1];
+    list_init(&act->commands);
+    list_init(&act->qlist);
+    list_add_tail(&action_list, &act->alist);
+        /* XXX add to hash */
+    return act;
+}
+
+static void parse_line_action(struct parse_state* state, int nargs, char **args)
+{
+    struct command *cmd;
+    struct action *act = state->context;
+    int (*func)(int nargs, char **args);
+    int kw, n;
+
+    if (nargs == 0) {
+        return;
+    }
+
+    kw = lookup_keyword(args[0]);
+    if (!kw_is(kw, COMMAND)) {
+        parse_error(state, "invalid command '%s'\n", args[0]);
+        return;
+    }
+
+    n = kw_nargs(kw);
+    if (nargs < n) {
+        parse_error(state, "%s requires %d %s\n", args[0], n - 1,
+            n > 2 ? "arguments" : "argument");
+        return;
+    }
+    cmd = malloc(sizeof(*cmd) + sizeof(char*) * nargs);
+    cmd->func = kw_func(kw);
+    cmd->line = state->line;
+    cmd->filename = state->filename;
+    cmd->nargs = nargs;
+    memcpy(cmd->args, args, sizeof(char*) * nargs);
+    list_add_tail(&act->commands, &cmd->clist);
+}
diff --git a/init_parser.h b/init_parser.h
new file mode 100644
index 0000000..b078cad
--- /dev/null
+++ b/init_parser.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_INIT_PARSER_H_
+#define _INIT_INIT_PARSER_H_
+
+#define INIT_PARSER_MAXARGS 64
+
+struct action;
+
+struct action *action_remove_queue_head(void);
+void action_add_queue_tail(struct action *act);
+void action_for_each_trigger(const char *trigger,
+                             void (*func)(struct action *act));
+int action_queue_empty(void);
+void queue_property_triggers(const char *name, const char *value);
+void queue_all_property_triggers();
+void queue_builtin_action(int (*func)(int nargs, char **args), char *name);
+
+int init_parse_config_file(const char *fn);
+int expand_props(char *dst, const char *src, int len);
+
+#endif
diff --git a/keychords.c b/keychords.c
new file mode 100644
index 0000000..4a64042
--- /dev/null
+++ b/keychords.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <linux/keychord.h>
+#include <unistd.h>
+
+#include "init.h"
+#include "log.h"
+#include "property_service.h"
+
+static struct input_keychord *keychords = 0;
+static int keychords_count = 0;
+static int keychords_length = 0;
+static int keychord_fd = -1;
+
+void add_service_keycodes(struct service *svc)
+{
+    struct input_keychord *keychord;
+    int i, size;
+
+    if (svc->keycodes) {
+        /* add a new keychord to the list */
+        size = sizeof(*keychord) + svc->nkeycodes * sizeof(keychord->keycodes[0]);
+        keychords = realloc(keychords, keychords_length + size);
+        if (!keychords) {
+            ERROR("could not allocate keychords\n");
+            keychords_length = 0;
+            keychords_count = 0;
+            return;
+        }
+
+        keychord = (struct input_keychord *)((char *)keychords + keychords_length);
+        keychord->version = KEYCHORD_VERSION;
+        keychord->id = keychords_count + 1;
+        keychord->count = svc->nkeycodes;
+        svc->keychord_id = keychord->id;
+
+        for (i = 0; i < svc->nkeycodes; i++) {
+            keychord->keycodes[i] = svc->keycodes[i];
+        }
+        keychords_count++;
+        keychords_length += size;
+    }
+}
+
+void keychord_init()
+{
+    int fd, ret;
+
+    service_for_each(add_service_keycodes);
+
+    /* nothing to do if no services require keychords */
+    if (!keychords)
+        return;
+
+    fd = open("/dev/keychord", O_RDWR);
+    if (fd < 0) {
+        ERROR("could not open /dev/keychord\n");
+        return;
+    }
+    fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+    ret = write(fd, keychords, keychords_length);
+    if (ret != keychords_length) {
+        ERROR("could not configure /dev/keychord %d (%d)\n", ret, errno);
+        close(fd);
+        fd = -1;
+    }
+
+    free(keychords);
+    keychords = 0;
+
+    keychord_fd = fd;
+}
+
+void handle_keychord()
+{
+    struct service *svc;
+    char adb_enabled[PROP_VALUE_MAX];
+    int ret;
+    __u16 id;
+
+    // Only handle keychords if adb is enabled.
+    property_get("init.svc.adbd", adb_enabled);
+    ret = read(keychord_fd, &id, sizeof(id));
+    if (ret != sizeof(id)) {
+        ERROR("could not read keychord id\n");
+        return;
+    }
+
+    if (!strcmp(adb_enabled, "running")) {
+        svc = service_find_by_keychord(id);
+        if (svc) {
+            INFO("starting service %s from keychord\n", svc->name);
+            service_start(svc, NULL);
+        } else {
+            ERROR("service for keychord %d not found\n", id);
+        }
+    }
+}
+
+int get_keychord_fd()
+{
+    return keychord_fd;
+}
diff --git a/keychords.h b/keychords.h
new file mode 100644
index 0000000..070b858
--- /dev/null
+++ b/keychords.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_KEYCHORDS_H_
+#define _INIT_KEYCHORDS_H_
+
+struct service;
+
+void add_service_keycodes(struct service *svc);
+void keychord_init(void);
+void handle_keychord(void);
+int get_keychord_fd(void);
+
+#endif
diff --git a/keywords.h b/keywords.h
new file mode 100644
index 0000000..5e60ba9
--- /dev/null
+++ b/keywords.h
@@ -0,0 +1,115 @@
+
+#ifndef KEYWORD
+int do_chroot(int nargs, char **args);
+int do_chdir(int nargs, char **args);
+int do_class_start(int nargs, char **args);
+int do_class_stop(int nargs, char **args);
+int do_class_reset(int nargs, char **args);
+int do_domainname(int nargs, char **args);
+int do_enable(int nargs, char **args);
+int do_exec(int nargs, char **args);
+int do_export(int nargs, char **args);
+int do_format_userdata(int nargs, char **args);
+int do_hostname(int nargs, char **args);
+int do_ifup(int nargs, char **args);
+int do_insmod(int nargs, char **args);
+int do_mkdir(int nargs, char **args);
+int do_mount_all(int nargs, char **args);
+int do_mount(int nargs, char **args);
+int do_powerctl(int nargs, char **args);
+int do_restart(int nargs, char **args);
+int do_restorecon(int nargs, char **args);
+int do_restorecon_recursive(int nargs, char **args);
+int do_rm(int nargs, char **args);
+int do_rmdir(int nargs, char **args);
+int do_setcon(int nargs, char **args);
+int do_setenforce(int nargs, char **args);
+int do_setkey(int nargs, char **args);
+int do_setprop(int nargs, char **args);
+int do_setrlimit(int nargs, char **args);
+int do_setsebool(int nargs, char **args);
+int do_start(int nargs, char **args);
+int do_stop(int nargs, char **args);
+int do_swapon_all(int nargs, char **args);
+int do_trigger(int nargs, char **args);
+int do_symlink(int nargs, char **args);
+int do_sysclktz(int nargs, char **args);
+int do_write(int nargs, char **args);
+int do_copy(int nargs, char **args);
+int do_chown(int nargs, char **args);
+int do_chmod(int nargs, char **args);
+int do_loglevel(int nargs, char **args);
+int do_load_persist_props(int nargs, char **args);
+int do_load_all_props(int nargs, char **args);
+int do_wait(int nargs, char **args);
+#define __MAKE_KEYWORD_ENUM__
+#define KEYWORD(symbol, flags, nargs, func) K_##symbol,
+enum {
+    K_UNKNOWN,
+#endif
+    KEYWORD(capability,  OPTION,  0, 0)
+    KEYWORD(chdir,       COMMAND, 1, do_chdir)
+    KEYWORD(chroot,      COMMAND, 1, do_chroot)
+    KEYWORD(class,       OPTION,  0, 0)
+    KEYWORD(class_start, COMMAND, 1, do_class_start)
+    KEYWORD(class_stop,  COMMAND, 1, do_class_stop)
+    KEYWORD(class_reset, COMMAND, 1, do_class_reset)
+    KEYWORD(console,     OPTION,  0, 0)
+    KEYWORD(critical,    OPTION,  0, 0)
+    KEYWORD(disabled,    OPTION,  0, 0)
+    KEYWORD(domainname,  COMMAND, 1, do_domainname)
+    KEYWORD(enable,      COMMAND, 1, do_enable)
+    KEYWORD(exec,        COMMAND, 1, do_exec)
+    KEYWORD(export,      COMMAND, 2, do_export)
+    KEYWORD(format_userdata,      COMMAND, 1, do_format_userdata)
+    KEYWORD(group,       OPTION,  0, 0)
+    KEYWORD(hostname,    COMMAND, 1, do_hostname)
+    KEYWORD(ifup,        COMMAND, 1, do_ifup)
+    KEYWORD(insmod,      COMMAND, 1, do_insmod)
+    KEYWORD(import,      SECTION, 1, 0)
+    KEYWORD(keycodes,    OPTION,  0, 0)
+    KEYWORD(mkdir,       COMMAND, 1, do_mkdir)
+    KEYWORD(mount_all,   COMMAND, 1, do_mount_all)
+    KEYWORD(mount,       COMMAND, 3, do_mount)
+    KEYWORD(on,          SECTION, 0, 0)
+    KEYWORD(oneshot,     OPTION,  0, 0)
+    KEYWORD(onrestart,   OPTION,  0, 0)
+    KEYWORD(powerctl,    COMMAND, 1, do_powerctl)
+    KEYWORD(restart,     COMMAND, 1, do_restart)
+    KEYWORD(restorecon,  COMMAND, 1, do_restorecon)
+    KEYWORD(restorecon_recursive,  COMMAND, 1, do_restorecon_recursive)
+    KEYWORD(rm,          COMMAND, 1, do_rm)
+    KEYWORD(rmdir,       COMMAND, 1, do_rmdir)
+    KEYWORD(seclabel,    OPTION,  0, 0)
+    KEYWORD(service,     SECTION, 0, 0)
+    KEYWORD(setcon,      COMMAND, 1, do_setcon)
+    KEYWORD(setenforce,  COMMAND, 1, do_setenforce)
+    KEYWORD(setenv,      OPTION,  2, 0)
+    KEYWORD(setkey,      COMMAND, 0, do_setkey)
+    KEYWORD(setprop,     COMMAND, 2, do_setprop)
+    KEYWORD(setrlimit,   COMMAND, 3, do_setrlimit)
+    KEYWORD(setsebool,   COMMAND, 2, do_setsebool)
+    KEYWORD(socket,      OPTION,  0, 0)
+    KEYWORD(start,       COMMAND, 1, do_start)
+    KEYWORD(stop,        COMMAND, 1, do_stop)
+    KEYWORD(swapon_all,  COMMAND, 1, do_swapon_all)
+    KEYWORD(trigger,     COMMAND, 1, do_trigger)
+    KEYWORD(symlink,     COMMAND, 1, do_symlink)
+    KEYWORD(sysclktz,    COMMAND, 1, do_sysclktz)
+    KEYWORD(user,        OPTION,  0, 0)
+    KEYWORD(wait,        COMMAND, 1, do_wait)
+    KEYWORD(write,       COMMAND, 2, do_write)
+    KEYWORD(copy,        COMMAND, 2, do_copy)
+    KEYWORD(chown,       COMMAND, 2, do_chown)
+    KEYWORD(chmod,       COMMAND, 2, do_chmod)
+    KEYWORD(loglevel,    COMMAND, 1, do_loglevel)
+    KEYWORD(load_persist_props,    COMMAND, 0, do_load_persist_props)
+    KEYWORD(load_all_props,        COMMAND, 0, do_load_all_props)
+    KEYWORD(ioprio,      OPTION,  0, 0)
+#ifdef __MAKE_KEYWORD_ENUM__
+    KEYWORD_COUNT,
+};
+#undef __MAKE_KEYWORD_ENUM__
+#undef KEYWORD
+#endif
+
diff --git a/log.h b/log.h
new file mode 100644
index 0000000..e9cb65a
--- /dev/null
+++ b/log.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_LOG_H_
+#define _INIT_LOG_H_
+
+#include <cutils/klog.h>
+
+#define ERROR(x...)   KLOG_ERROR("init", x)
+#define NOTICE(x...)  KLOG_NOTICE("init", x)
+#define INFO(x...)    KLOG_INFO("init", x)
+
+extern int log_callback(int type, const char *fmt, ...);
+
+#endif
diff --git a/parser.c b/parser.c
new file mode 100644
index 0000000..48e7aec
--- /dev/null
+++ b/parser.c
@@ -0,0 +1,183 @@
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+
+#include "parser.h"
+#include "log.h"
+
+#define RAW(x...) log_write(6, x)
+
+void DUMP(void)
+{
+#if 0
+    struct service *svc;
+    struct action *act;
+    struct command *cmd;
+    struct listnode *node;
+    struct listnode *node2;
+    struct socketinfo *si;
+    int n;
+    
+    list_for_each(node, &service_list) {
+        svc = node_to_item(node, struct service, slist);
+        RAW("service %s\n", svc->name);
+        RAW("  class '%s'\n", svc->classname);
+        RAW("  exec");
+        for (n = 0; n < svc->nargs; n++) {
+            RAW(" '%s'", svc->args[n]);
+        }
+        RAW("\n");
+        for (si = svc->sockets; si; si = si->next) {
+            RAW("  socket %s %s 0%o\n", si->name, si->type, si->perm);
+        }
+    }
+
+    list_for_each(node, &action_list) {
+        act = node_to_item(node, struct action, alist);
+        RAW("on %s\n", act->name);
+        list_for_each(node2, &act->commands) {
+            cmd = node_to_item(node2, struct command, clist);
+            RAW("  %p", cmd->func);
+            for (n = 0; n < cmd->nargs; n++) {
+                RAW(" %s", cmd->args[n]);
+            }
+            RAW("\n");
+        }
+        RAW("\n");
+    }
+#endif       
+}
+
+void parse_error(struct parse_state *state, const char *fmt, ...)
+{
+    va_list ap;
+    char buf[128];
+    int off;
+    
+    snprintf(buf, 128, "%s: %d: ", state->filename, state->line);
+    buf[127] = 0;
+    off = strlen(buf);
+
+    va_start(ap, fmt);
+    vsnprintf(buf + off, 128 - off, fmt, ap);
+    va_end(ap);
+    buf[127] = 0;
+    ERROR("%s", buf);
+}
+
+int next_token(struct parse_state *state)
+{
+    char *x = state->ptr;
+    char *s;
+
+    if (state->nexttoken) {
+        int t = state->nexttoken;
+        state->nexttoken = 0;
+        return t;
+    }
+
+    for (;;) {
+        switch (*x) {
+        case 0:
+            state->ptr = x;
+            return T_EOF;
+        case '\n':
+            x++;
+            state->ptr = x;
+            return T_NEWLINE;
+        case ' ':
+        case '\t':
+        case '\r':
+            x++;
+            continue;
+        case '#':
+            while (*x && (*x != '\n')) x++;
+            if (*x == '\n') {
+                state->ptr = x+1;
+                return T_NEWLINE;
+            } else {
+                state->ptr = x;
+                return T_EOF;
+            }
+        default:
+            goto text;
+        }
+    }
+
+textdone:
+    state->ptr = x;
+    *s = 0;
+    return T_TEXT;
+text:
+    state->text = s = x;
+textresume:
+    for (;;) {
+        switch (*x) {
+        case 0:
+            goto textdone;
+        case ' ':
+        case '\t':
+        case '\r':
+            x++;
+            goto textdone;
+        case '\n':
+            state->nexttoken = T_NEWLINE;
+            x++;
+            goto textdone;
+        case '"':
+            x++;
+            for (;;) {
+                switch (*x) {
+                case 0:
+                        /* unterminated quoted thing */
+                    state->ptr = x;
+                    return T_EOF;
+                case '"':
+                    x++;
+                    goto textresume;
+                default:
+                    *s++ = *x++;
+                }
+            }
+            break;
+        case '\\':
+            x++;
+            switch (*x) {
+            case 0:
+                goto textdone;
+            case 'n':
+                *s++ = '\n';
+                break;
+            case 'r':
+                *s++ = '\r';
+                break;
+            case 't':
+                *s++ = '\t';
+                break;
+            case '\\':
+                *s++ = '\\';
+                break;
+            case '\r':
+                    /* \ <cr> <lf> -> line continuation */
+                if (x[1] != '\n') {
+                    x++;
+                    continue;
+                }
+            case '\n':
+                    /* \ <lf> -> line continuation */
+                state->line++;
+                x++;
+                    /* eat any extra whitespace */
+                while((*x == ' ') || (*x == '\t')) x++;
+                continue;
+            default:
+                    /* unknown escape -- just copy */
+                *s++ = *x++;
+            }
+            continue;
+        default:
+            *s++ = *x++;
+        }
+    }
+    return T_EOF;
+}
diff --git a/parser.h b/parser.h
new file mode 100644
index 0000000..a58272a
--- /dev/null
+++ b/parser.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PARSER_H_
+#define PARSER_H_
+
+#define T_EOF 0
+#define T_TEXT 1
+#define T_NEWLINE 2
+
+struct parse_state
+{
+    char *ptr;
+    char *text;
+    int line;
+    int nexttoken;
+    void *context;
+    void (*parse_line)(struct parse_state *state, int nargs, char **args);
+    const char *filename;
+    void *priv;
+};
+
+void DUMP(void);
+int next_token(struct parse_state *state);
+void parse_error(struct parse_state *state, const char *fmt, ...);
+
+#endif /* PARSER_H_ */
diff --git a/property_service.c b/property_service.c
new file mode 100755
index 0000000..e375912
--- /dev/null
+++ b/property_service.c
@@ -0,0 +1,644 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <dirent.h>
+#include <limits.h>
+#include <errno.h>
+#include <sys/poll.h>
+
+#include <cutils/misc.h>
+#include <cutils/sockets.h>
+#include <cutils/multiuser.h>
+
+#define _REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H_
+#include <sys/_system_properties.h>
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/mman.h>
+#include <private/android_filesystem_config.h>
+
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+
+#include "property_service.h"
+#include "init.h"
+#include "util.h"
+#include "log.h"
+
+#define PERSISTENT_PROPERTY_DIR  "/data/property"
+
+static int persistent_properties_loaded = 0;
+static int property_area_inited = 0;
+
+static int property_set_fd = -1;
+static unsigned int runmode = 0xa7; /* 0xa7: CPU0-A7, 0xa15: CPU0-A15 */
+#ifdef SUN9IW1P1
+static int aw_init_runmode(void)
+{
+    char *path = "/sys/class/script/get_item";
+    FILE *fd;
+    char *key = "cpu_logical_map cpu0";
+    char data[4];
+    unsigned int value;
+
+    fd = fopen(path, "r+");
+    if (fd == NULL) {
+        ERROR("cannot open %s, %s\n", path, strerror(errno));
+        return errno;
+    }
+
+    if (fwrite(key, 1, strlen(key), fd) < strlen(key)) {
+        ERROR("cannot write %s to %s, %s\n", key, path, strerror(errno));
+        goto oops;
+    }
+    fflush(fd);
+    rewind(fd);
+
+    if (fread(data, 1, 4, fd) < 4) {
+        ERROR("cannot read 4 bytes from %s, %s\n", path, strerror(errno));
+        goto oops;
+    }
+    fclose(fd);
+
+    value = (data[3] << 24) |(data[2] << 16) | (data[1] << 8) | data[0];
+    switch (value) {
+        case 0x0:
+            runmode = 0xa7;
+            property_set("ro.sys.runmode", "0xa7");
+            break;
+
+        case 0x100:
+            runmode = 0xa15;
+            property_set("ro.sys.runmode", "0xa15");
+            break;
+
+        default:
+            runmode = 0xa7;
+            property_set("ro.sys.runmode", "0xa7");
+    }
+    return 0;
+
+oops:
+    property_set("ro.sys.runmode", "0xa7");
+    fclose(fd);
+    return errno;
+}
+#endif
+#ifdef AW_BOOSTUP_ENABLE
+int aw_boost_up_perf(const char *name, const char *value);
+int aw_init_boostup(int runmode);
+#endif
+
+typedef struct {
+    size_t size;
+    int fd;
+} workspace;
+
+static int init_workspace(workspace *w, size_t size)
+{
+    void *data;
+    int fd = open(PROP_FILENAME, O_RDONLY | O_NOFOLLOW);
+    if (fd < 0)
+        return -1;
+
+    w->size = size;
+    w->fd = fd;
+    return 0;
+}
+
+static workspace pa_workspace;
+
+static int init_property_area(void)
+{
+    if (property_area_inited)
+        return -1;
+
+    if(__system_property_area_init())//
+        return -1;///dev/__properties__
+
+    if(init_workspace(&pa_workspace, 0))//
+        return -1;//pa_workspace 
+
+    fcntl(pa_workspace.fd, F_SETFD, FD_CLOEXEC);
+
+    property_area_inited = 1;
+    return 0;
+}
+
+static int check_mac_perms(const char *name, char *sctx)
+{
+    if (is_selinux_enabled() <= 0)
+        return 1;
+
+    char *tctx = NULL;
+    const char *class = "property_service";
+    const char *perm = "set";
+    int result = 0;
+
+    if (!sctx)
+        goto err;
+
+    if (!sehandle_prop)
+        goto err;
+
+    if (selabel_lookup(sehandle_prop, &tctx, name, 1) != 0)
+        goto err;
+
+    if (selinux_check_access(sctx, tctx, class, perm, (void*) name) == 0)
+        result = 1;
+
+    freecon(tctx);
+ err:
+    return result;
+}
+
+static int check_control_mac_perms(const char *name, char *sctx)
+{
+    /*
+     *  Create a name prefix out of ctl.<service name>
+     *  The new prefix allows the use of the existing
+     *  property service backend labeling while avoiding
+     *  mislabels based on true property prefixes.
+     */
+    char ctl_name[PROP_VALUE_MAX+4];
+    int ret = snprintf(ctl_name, sizeof(ctl_name), "ctl.%s", name);
+
+    if (ret < 0 || (size_t) ret >= sizeof(ctl_name))
+        return 0;
+
+    return check_mac_perms(ctl_name, sctx);
+}
+
+/*
+ * Checks permissions for setting system properties.
+ * Returns 1 if uid allowed, 0 otherwise.
+ */
+static int check_perms(const char *name, char *sctx)
+{
+    int i;
+    unsigned int app_id;
+
+    if(!strncmp(name, "ro.", 3))
+        name +=3;
+
+    return check_mac_perms(name, sctx);
+}
+
+int __property_get(const char *name, char *value)
+{
+    return __system_property_get(name, value);
+}
+
+static void write_persistent_property(const char *name, const char *value)
+{
+    char tempPath[PATH_MAX];
+    char path[PATH_MAX];
+    int fd;
+
+    snprintf(tempPath, sizeof(tempPath), "%s/.temp.XXXXXX", PERSISTENT_PROPERTY_DIR);
+    fd = mkstemp(tempPath);
+    if (fd < 0) {
+        ERROR("Unable to write persistent property to temp file %s errno: %d\n", tempPath, errno);
+        return;
+    }
+    write(fd, value, strlen(value));
+    fsync(fd);
+    close(fd);
+
+    snprintf(path, sizeof(path), "%s/%s", PERSISTENT_PROPERTY_DIR, name);
+    if (rename(tempPath, path)) {
+        unlink(tempPath);
+        ERROR("Unable to rename persistent property file %s to %s\n", tempPath, path);
+    }
+}
+
+static bool is_legal_property_name(const char* name, size_t namelen)
+{
+    size_t i;
+    if (namelen >= PROP_NAME_MAX) return false;
+    if (namelen < 1) return false;
+    if (name[0] == '.') return false;
+    if (name[namelen - 1] == '.') return false;
+
+    /* Only allow alphanumeric, plus '.', '-', or '_' */
+    /* Don't allow ".." to appear in a property name */
+    for (i = 0; i < namelen; i++) {
+        if (name[i] == '.') {
+            // i=0 is guaranteed to never have a dot. See above.
+            if (name[i-1] == '.') return false;
+            continue;
+        }
+        if (name[i] == '_' || name[i] == '-') continue;
+        if (name[i] >= 'a' && name[i] <= 'z') continue;
+        if (name[i] >= 'A' && name[i] <= 'Z') continue;
+        if (name[i] >= '0' && name[i] <= '9') continue;
+        return false;
+    }
+
+    return true;
+}
+
+int property_set(const char *name, const char *value)
+{
+    prop_info *pi;
+    int ret;
+
+    size_t namelen = strlen(name);
+    size_t valuelen = strlen(value);
+
+    if (!is_legal_property_name(name, namelen)) return -1;
+    if (valuelen >= PROP_VALUE_MAX) return -1;
+
+    pi = (prop_info*) __system_property_find(name);
+
+    if(pi != 0) {
+        /* ro.* properties may NEVER be modified once set */
+        if(!strncmp(name, "ro.", 3)) return -1;
+
+        __system_property_update(pi, value, valuelen);
+    } else {
+        ret = __system_property_add(name, namelen, value, valuelen);
+        if (ret < 0) {
+            ERROR("Failed to set '%s'='%s'\n", name, value);
+            return ret;
+        }
+    }
+    /* If name starts with "net." treat as a DNS property. */
+    if (strncmp("net.", name, strlen("net.")) == 0)  {
+        if (strcmp("net.change", name) == 0) {
+            return 0;
+        }
+       /*
+        * The 'net.change' property is a special property used track when any
+        * 'net.*' property name is updated. It is _ONLY_ updated here. Its value
+        * contains the last updated 'net.*' property.
+        */
+        property_set("net.change", name);
+    } else if (persistent_properties_loaded &&
+            strncmp("persist.", name, strlen("persist.")) == 0) {
+        /*
+         * Don't write properties to disk until after we have read all default properties
+         * to prevent them from being overwritten by default values.
+         */
+        write_persistent_property(name, value);
+    } else if (strcmp("selinux.reload_policy", name) == 0 &&
+               strcmp("1", value) == 0) {
+        selinux_reload_policy();
+    }
+    property_changed(name, value);
+
+#ifdef AW_BOOSTUP_ENABLE
+    aw_boost_up_perf(name, value);
+#endif
+    return 0;
+}
+//socketInit
+void handle_property_set_fd()
+{
+    prop_msg msg;
+    int s;
+    int r;
+    int res;
+    struct ucred cr;
+    struct sockaddr_un addr;
+    socklen_t addr_size = sizeof(addr);
+    socklen_t cr_size = sizeof(cr);
+    char * source_ctx = NULL;
+    struct pollfd ufds[1];
+    const int timeout_ms = 2 * 1000;  /* Default 2 sec timeout for caller to send property. */
+    int nr;
+
+    if ((s = accept(property_set_fd, (struct sockaddr *) &addr, &addr_size)) < 0) {
+        return;
+    }
+
+    /* Check socket options here */
+    if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &cr, &cr_size) < 0) {
+        close(s);
+        ERROR("Unable to receive socket options\n");
+        return;
+    }
+
+    ufds[0].fd = s;
+    ufds[0].events = POLLIN;
+    ufds[0].revents = 0;
+    nr = TEMP_FAILURE_RETRY(poll(ufds, 1, timeout_ms));
+    if (nr == 0) {
+        ERROR("sys_prop: timeout waiting for uid=%d to send property message.\n", cr.uid);
+        close(s);
+        return;
+    } else if (nr < 0) {
+        ERROR("sys_prop: error waiting for uid=%d to send property message. err=%d %s\n", cr.uid, errno, strerror(errno));
+        close(s);
+        return;
+    }
+
+    r = TEMP_FAILURE_RETRY(recv(s, &msg, sizeof(msg), MSG_DONTWAIT));
+    if(r != sizeof(prop_msg)) {
+        ERROR("sys_prop: mis-match msg size received: %d expected: %zu errno: %d\n",
+              r, sizeof(prop_msg), errno);
+        close(s);
+        return;
+    }
+
+    switch(msg.cmd) {
+    case PROP_MSG_SETPROP:
+        msg.name[PROP_NAME_MAX-1] = 0;
+        msg.value[PROP_VALUE_MAX-1] = 0;
+
+        if (!is_legal_property_name(msg.name, strlen(msg.name))) {
+            ERROR("sys_prop: illegal property name. Got: \"%s\"\n", msg.name);
+            close(s);
+            return;
+        }
+
+        getpeercon(s, &source_ctx);
+//
+//132
+//.
+//.
+//. 0---9 a---z A----Z - _
+//
+        if(memcmp(msg.name,"ctl.",4) == 0) {
+            // Keep the old close-socket-early behavior when handling
+            // ctl.* properties.
+            close(s);
+            if (check_control_mac_perms(msg.value, source_ctx)) {
+                handle_control_message((char*) msg.name + 4, (char*) msg.value);
+            } else {
+                ERROR("sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n",
+                        msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid);
+            }
+        } else {
+            if (check_perms(msg.name, source_ctx)) {
+                property_set((char*) msg.name, (char*) msg.value);
+            } else {
+                ERROR("sys_prop: permission denied uid:%d  name:%s\n",
+                      cr.uid, msg.name);
+            }
+
+            // Note: bionic's property client code assumes that the
+            // property server will not close the socket until *AFTER*
+            // the property is written to memory.
+            close(s);
+        }
+        freecon(source_ctx);
+        break;
+
+    default:
+        close(s);
+        break;
+    }
+}
+
+void get_property_workspace(int *fd, int *sz)
+{
+    *fd = pa_workspace.fd;
+    *sz = pa_workspace.size;
+}
+
+static void load_properties_from_file(const char *, const char *);
+void property_opt_for_mem(void);
+
+/*
+ * Filter is used to decide which properties to load: NULL loads all keys,
+ * "ro.foo.*" is a prefix match, and "ro.foo.bar" is an exact match.
+ */
+static void load_properties(char *data, const char *filter)
+{
+    char *key, *value, *eol, *sol, *tmp, *fn;
+    size_t flen = 0;
+
+    if (filter) {
+        flen = strlen(filter);
+    }
+
+    sol = data;
+    while ((eol = strchr(sol, '\n'))) {
+        key = sol;
+        *eol++ = 0;
+        sol = eol;
+
+        while (isspace(*key)) key++;
+        if (*key == '#') continue;
+
+        tmp = eol - 2;
+        while ((tmp > key) && isspace(*tmp)) *tmp-- = 0;
+
+        if (!strncmp(key, "import ", 7) && flen == 0) {
+            fn = key + 7;
+            while (isspace(*fn)) fn++;
+
+            key = strchr(fn, ' ');
+            if (key) {
+                *key++ = 0;
+                while (isspace(*key)) key++;
+            }
+
+            load_properties_from_file(fn, key);
+
+        } else {
+            value = strchr(key, '=');
+            if (!value) continue;
+            *value++ = 0;
+
+            tmp = value - 2;
+            while ((tmp > key) && isspace(*tmp)) *tmp-- = 0;
+
+            while (isspace(*value)) value++;
+
+            if (flen > 0) {
+                if (filter[flen - 1] == '*') {
+                    if (strncmp(key, filter, flen - 1)) continue;
+                } else {
+                    if (strcmp(key, filter)) continue;
+                }
+            }
+
+            property_set(key, value);
+        }
+    }
+
+	property_opt_for_mem();
+}
+
+/*
+ * Filter is used to decide which properties to load: NULL loads all keys,
+ * "ro.foo.*" is a prefix match, and "ro.foo.bar" is an exact match.
+ */
+static void load_properties_from_file(const char *fn, const char *filter)
+{
+    char *data;
+    unsigned sz;
+
+    data = read_file(fn, &sz);
+
+    if(data != 0) {
+        load_properties(data, filter);
+        free(data);
+    }
+}
+
+static void load_persistent_properties()
+{
+    DIR* dir = opendir(PERSISTENT_PROPERTY_DIR);
+    int dir_fd;
+    struct dirent*  entry;
+    char value[PROP_VALUE_MAX];
+    int fd, length;
+    struct stat sb;
+
+    if (dir) {
+        dir_fd = dirfd(dir);
+        while ((entry = readdir(dir)) != NULL) {
+            if (strncmp("persist.", entry->d_name, strlen("persist.")))
+                continue;
+#if HAVE_DIRENT_D_TYPE
+            if (entry->d_type != DT_REG)
+                continue;
+#endif
+            /* open the file and read the property value */
+            fd = openat(dir_fd, entry->d_name, O_RDONLY | O_NOFOLLOW);
+            if (fd < 0) {
+                ERROR("Unable to open persistent property file \"%s\" errno: %d\n",
+                      entry->d_name, errno);
+                continue;
+            }
+            if (fstat(fd, &sb) < 0) {
+                ERROR("fstat on property file \"%s\" failed errno: %d\n", entry->d_name, errno);
+                close(fd);
+                continue;
+            }
+
+            // File must not be accessible to others, be owned by root/root, and
+            // not be a hard link to any other file.
+            if (((sb.st_mode & (S_IRWXG | S_IRWXO)) != 0)
+                    || (sb.st_uid != 0)
+                    || (sb.st_gid != 0)
+                    || (sb.st_nlink != 1)) {
+                ERROR("skipping insecure property file %s (uid=%u gid=%u nlink=%d mode=%o)\n",
+                      entry->d_name, (unsigned int)sb.st_uid, (unsigned int)sb.st_gid,
+                      sb.st_nlink, sb.st_mode);
+                close(fd);
+                continue;
+            }
+
+            length = read(fd, value, sizeof(value) - 1);
+            if (length >= 0) {
+                value[length] = 0;
+                property_set(entry->d_name, value);
+            } else {
+                ERROR("Unable to read persistent property file %s errno: %d\n",
+                      entry->d_name, errno);
+            }
+            close(fd);
+        }
+        closedir(dir);
+    } else {
+        ERROR("Unable to open persistent property directory %s errno: %d\n", PERSISTENT_PROPERTY_DIR, errno);
+    }
+
+    persistent_properties_loaded = 1;
+}
+
+void property_init(void)
+{
+    init_property_area();//
+}
+
+void property_load_boot_defaults(void)
+{
+    load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT, NULL);
+}
+
+int properties_inited(void)
+{
+    return property_area_inited;
+}
+
+static void load_override_properties() {
+#ifdef ALLOW_LOCAL_PROP_OVERRIDE
+    char debuggable[PROP_VALUE_MAX];
+    int ret;
+
+    ret = property_get("ro.debuggable", debuggable);
+    if (ret && (strcmp(debuggable, "1") == 0)) {
+        load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE, NULL);
+    }
+#endif /* ALLOW_LOCAL_PROP_OVERRIDE */
+}
+
+
+/* When booting an encrypted system, /data is not mounted when the
+ * property service is started, so any properties stored there are
+ * not loaded.  Vold triggers init to load these properties once it
+ * has mounted /data.
+ */
+void load_persist_props(void)
+{
+    load_override_properties();
+    /* Read persistent properties after all default values have been loaded. */
+    load_persistent_properties();
+}
+
+void load_all_props(void)
+{
+    load_properties_from_file(PROP_PATH_SYSTEM_BUILD, NULL);
+    load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT, NULL);
+    load_properties_from_file(PROP_PATH_FACTORY, "ro.*");
+
+    load_override_properties();
+
+    /* Read persistent properties after all default values have been loaded. */
+    load_persistent_properties();
+}
+
+void start_property_service(void)
+{
+    int fd;
+
+    fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0, NULL);
+    if(fd < 0) return;
+    fcntl(fd, F_SETFD, FD_CLOEXEC);
+    fcntl(fd, F_SETFL, O_NONBLOCK);
+
+    listen(fd, 8);
+    property_set_fd = fd;
+#ifdef SUN9IW1P1
+    aw_init_runmode();
+#endif
+
+#ifdef AW_BOOSTUP_ENABLE
+    aw_init_boostup(runmode);
+#endif
+
+}
+
+int get_property_set_fd()
+{
+    return property_set_fd;
+}
diff --git a/property_service.h b/property_service.h
new file mode 100644
index 0000000..730495e
--- /dev/null
+++ b/property_service.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_PROPERTY_H
+#define _INIT_PROPERTY_H
+
+#include <stdbool.h>
+#include <sys/system_properties.h>
+
+extern void handle_property_set_fd(void);
+extern void property_init(void);
+extern void property_load_boot_defaults(void);
+extern void load_persist_props(void);
+extern void load_all_props(void);
+extern void start_property_service(void);
+void get_property_workspace(int *fd, int *sz);
+extern int __property_get(const char *name, char *value);
+extern int property_set(const char *name, const char *value);
+extern int properties_inited();
+int get_property_set_fd(void);
+
+extern void __property_get_size_error()
+    __attribute__((__error__("property_get called with too small buffer")));
+
+static inline
+__attribute__ ((always_inline))
+__attribute__ ((gnu_inline))
+__attribute__ ((artificial))
+int property_get(const char *name, char *value)
+{
+    size_t value_len = __builtin_object_size(value, 0);
+    if (value_len != PROP_VALUE_MAX)
+        __property_get_size_error();
+
+    return __property_get(name, value);
+}
+
+#endif	/* _INIT_PROPERTY_H */
diff --git a/readme.txt b/readme.txt
new file mode 100644
index 0000000..26be536
--- /dev/null
+++ b/readme.txt
@@ -0,0 +1,349 @@
+
+Android Init Language
+---------------------
+
+The Android Init Language consists of four broad classes of statements,
+which are Actions, Commands, Services, and Options.
+
+All of these are line-oriented, consisting of tokens separated by
+whitespace.  The c-style backslash escapes may be used to insert
+whitespace into a token.  Double quotes may also be used to prevent
+whitespace from breaking text into multiple tokens.  The backslash,
+when it is the last character on a line, may be used for line-folding.
+
+Lines which start with a # (leading whitespace allowed) are comments.
+
+Actions and Services implicitly declare a new section.  All commands
+or options belong to the section most recently declared.  Commands
+or options before the first section are ignored.
+
+Actions and Services have unique names.  If a second Action or Service
+is declared with the same name as an existing one, it is ignored as
+an error.  (??? should we override instead)
+
+
+Actions
+-------
+Actions are named sequences of commands.  Actions have a trigger which
+is used to determine when the action should occur.  When an event
+occurs which matches an action's trigger, that action is added to
+the tail of a to-be-executed queue (unless it is already on the
+queue).
+
+Each action in the queue is dequeued in sequence and each command in
+that action is executed in sequence.  Init handles other activities
+(device creation/destruction, property setting, process restarting)
+"between" the execution of the commands in activities.
+
+Actions take the form of:
+
+on <trigger>
+   <command>
+   <command>
+   <command>
+
+
+Services
+--------
+Services are programs which init launches and (optionally) restarts
+when they exit.  Services take the form of:
+
+service <name> <pathname> [ <argument> ]*
+   <option>
+   <option>
+   ...
+
+
+Options
+-------
+Options are modifiers to services.  They affect how and when init
+runs the service.
+
+critical
+   This is a device-critical service. If it exits more than four times in
+   four minutes, the device will reboot into recovery mode.
+
+disabled
+   This service will not automatically start with its class.
+   It must be explicitly started by name.
+
+setenv <name> <value>
+   Set the environment variable <name> to <value> in the launched process.
+
+socket <name> <type> <perm> [ <user> [ <group> [ <context> ] ] ]
+   Create a unix domain socket named /dev/socket/<name> and pass
+   its fd to the launched process.  <type> must be "dgram", "stream" or "seqpacket".
+   User and group default to 0.
+   Context is the SELinux security context for the socket.
+   It defaults to the service security context, as specified by seclabel or
+   computed based on the service executable file security context.
+
+user <username>
+   Change to username before exec'ing this service.
+   Currently defaults to root.  (??? probably should default to nobody)
+   Currently, if your process requires linux capabilities then you cannot use
+   this command. You must instead request the capabilities in-process while
+   still root, and then drop to your desired uid.
+
+group <groupname> [ <groupname> ]*
+   Change to groupname before exec'ing this service.  Additional
+   groupnames beyond the (required) first one are used to set the
+   supplemental groups of the process (via setgroups()).
+   Currently defaults to root.  (??? probably should default to nobody)
+
+seclabel <securitycontext>
+  Change to securitycontext before exec'ing this service.
+  Primarily for use by services run from the rootfs, e.g. ueventd, adbd.
+  Services on the system partition can instead use policy-defined transitions
+  based on their file security context.
+  If not specified and no transition is defined in policy, defaults to the init context.
+
+oneshot
+   Do not restart the service when it exits.
+
+class <name>
+   Specify a class name for the service.  All services in a
+   named class may be started or stopped together.  A service
+   is in the class "default" if one is not specified via the
+   class option.
+
+onrestart
+    Execute a Command (see below) when service restarts.
+
+Triggers
+--------
+   Triggers are strings which can be used to match certain kinds
+   of events and used to cause an action to occur.
+
+boot
+   This is the first trigger that will occur when init starts
+   (after /init.conf is loaded)
+
+<name>=<value>
+   Triggers of this form occur when the property <name> is set
+   to the specific value <value>.
+
+device-added-<path>
+device-removed-<path>
+   Triggers of these forms occur when a device node is added
+   or removed.
+
+service-exited-<name>
+   Triggers of this form occur when the specified service exits.
+
+
+Commands
+--------
+
+exec <path> [ <argument> ]*
+   Fork and execute a program (<path>).  This will block until
+   the program completes execution.  It is best to avoid exec
+   as unlike the builtin commands, it runs the risk of getting
+   init "stuck". (??? maybe there should be a timeout?)
+
+export <name> <value>
+   Set the environment variable <name> equal to <value> in the
+   global environment (which will be inherited by all processes
+   started after this command is executed)
+
+ifup <interface>
+   Bring the network interface <interface> online.
+
+import <filename>
+   Parse an init config file, extending the current configuration.
+
+hostname <name>
+   Set the host name.
+
+chdir <directory>
+   Change working directory.
+
+chmod <octal-mode> <path>
+   Change file access permissions.
+
+chown <owner> <group> <path>
+   Change file owner and group.
+
+chroot <directory>
+  Change process root directory.
+
+class_start <serviceclass>
+   Start all services of the specified class if they are
+   not already running.
+
+class_stop <serviceclass>
+   Stop all services of the specified class if they are
+   currently running.
+
+domainname <name>
+   Set the domain name.
+
+enable <servicename>
+   Turns a disabled service into an enabled one as if the service did not
+   specify disabled.
+   If the service is supposed to be running, it will be started now.
+   Typically used when the bootloader sets a variable that indicates a specific
+   service should be started when needed. E.g.
+     on property:ro.boot.myfancyhardware=1
+        enable my_fancy_service_for_my_fancy_hardware
+
+
+insmod <path>
+   Install the module at <path>
+
+mkdir <path> [mode] [owner] [group]
+   Create a directory at <path>, optionally with the given mode, owner, and
+   group. If not provided, the directory is created with permissions 755 and
+   owned by the root user and root group.
+
+mount <type> <device> <dir> [ <mountoption> ]*
+   Attempt to mount the named device at the directory <dir>
+   <device> may be of the form mtd@name to specify a mtd block
+   device by name.
+   <mountoption>s include "ro", "rw", "remount", "noatime", ...
+
+restorecon <path> [ <path> ]*
+   Restore the file named by <path> to the security context specified
+   in the file_contexts configuration.
+   Not required for directories created by the init.rc as these are
+   automatically labeled correctly by init.
+
+restorecon_recursive <path> [ <path> ]*
+   Recursively restore the directory tree named by <path> to the
+   security contexts specified in the file_contexts configuration.
+   Do NOT use this with paths leading to shell-writable or app-writable
+   directories, e.g. /data/local/tmp, /data/data or any prefix thereof.
+
+setcon <securitycontext>
+   Set the current process security context to the specified string.
+   This is typically only used from early-init to set the init context
+   before any other process is started.
+
+setenforce 0|1
+   Set the SELinux system-wide enforcing status.
+   0 is permissive (i.e. log but do not deny), 1 is enforcing.
+
+setkey
+   TBD
+
+setprop <name> <value>
+   Set system property <name> to <value>.
+
+setrlimit <resource> <cur> <max>
+   Set the rlimit for a resource.
+
+setsebool <name> <value>
+   Set SELinux boolean <name> to <value>.
+   <value> may be 1|true|on or 0|false|off
+
+start <service>
+   Start a service running if it is not already running.
+
+stop <service>
+   Stop a service from running if it is currently running.
+
+symlink <target> <path>
+   Create a symbolic link at <path> with the value <target>
+
+sysclktz <mins_west_of_gmt>
+   Set the system clock base (0 if system clock ticks in GMT)
+
+trigger <event>
+   Trigger an event.  Used to queue an action from another
+   action.
+
+wait <path> [ <timeout> ]
+  Poll for the existence of the given file and return when found,
+  or the timeout has been reached. If timeout is not specified it
+  currently defaults to five seconds.
+
+write <path> <string>
+   Open the file at <path> and write a string to it with write(2)
+   without appending.
+
+
+Properties
+----------
+Init updates some system properties to provide some insight into
+what it's doing:
+
+init.action 
+   Equal to the name of the action currently being executed or "" if none
+
+init.command
+   Equal to the command being executed or "" if none.
+
+init.svc.<name>
+   State of a named service ("stopped", "running", "restarting")
+
+
+Example init.conf
+-----------------
+
+# not complete -- just providing some examples of usage
+#
+on boot
+   export PATH /sbin:/system/sbin:/system/bin
+   export LD_LIBRARY_PATH /system/lib
+
+   mkdir /dev
+   mkdir /proc
+   mkdir /sys
+
+   mount tmpfs tmpfs /dev
+   mkdir /dev/pts
+   mkdir /dev/socket
+   mount devpts devpts /dev/pts
+   mount proc proc /proc
+   mount sysfs sysfs /sys
+
+   write /proc/cpu/alignment 4
+
+   ifup lo
+
+   hostname localhost
+   domainname localhost
+
+   mount yaffs2 mtd@system /system
+   mount yaffs2 mtd@userdata /data
+
+   import /system/etc/init.conf
+
+   class_start default
+
+service adbd /sbin/adbd
+   user adb
+   group adb
+
+service usbd /system/bin/usbd -r
+   user usbd
+   group usbd
+   socket usbd 666
+
+service zygote /system/bin/app_process -Xzygote /system/bin --zygote
+   socket zygote 666
+
+service runtime /system/bin/runtime
+   user system
+   group system
+
+on device-added-/dev/compass
+   start akmd
+
+on device-removed-/dev/compass
+   stop akmd
+
+service akmd /sbin/akmd
+   disabled
+   user akmd
+   group akmd
+
+Debugging notes
+---------------
+By default, programs executed by init will drop stdout and stderr into
+/dev/null. To help with debugging, you can execute your program via the
+Andoird program logwrapper. This will redirect stdout/stderr into the
+Android logging system (accessed via logcat).
+
+For example
+service akmd /system/bin/logwrapper /sbin/akmd
diff --git a/signal_handler.c b/signal_handler.c
new file mode 100644
index 0000000..7e8e1a7
--- /dev/null
+++ b/signal_handler.c
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include <cutils/sockets.h>
+#include <cutils/android_reboot.h>
+#include <cutils/list.h>
+
+#include "init.h"
+#include "util.h"
+#include "log.h"
+
+static int signal_fd = -1;
+static int signal_recv_fd = -1;
+
+static void sigchld_handler(int s)
+{
+    write(signal_fd, &s, 1);
+}
+
+#define CRITICAL_CRASH_THRESHOLD    4       /* if we crash >4 times ... */
+#define CRITICAL_CRASH_WINDOW       (4*60)  /* ... in 4 minutes, goto recovery*/
+
+static int wait_for_one_process(int block)
+{
+    pid_t pid;
+    int status;
+    struct service *svc;
+    struct socketinfo *si;
+    time_t now;
+    struct listnode *node;
+    struct command *cmd;
+
+    while ( (pid = waitpid(-1, &status, block ? 0 : WNOHANG)) == -1 && errno == EINTR );
+    if (pid <= 0) return -1;
+    INFO("waitpid returned pid %d, status = %08x\n", pid, status);
+
+    svc = service_find_by_pid(pid);
+    if (!svc) {
+        if (WIFEXITED(status)) {
+            ERROR("untracked pid %d exited with status %d\n", pid, WEXITSTATUS(status));
+        } else if (WIFSIGNALED(status)) {
+            ERROR("untracked pid %d killed by signal %d\n", pid, WTERMSIG(status));
+        } else if (WIFSTOPPED(status)) {
+            ERROR("untracked pid %d stopped by signal %d\n", pid, WSTOPSIG(status));
+        } else {
+            ERROR("untracked pid %d state changed\n", pid);
+        }
+        return 0;
+    }
+
+    NOTICE("process '%s', pid %d exited\n", svc->name, pid);
+
+    if (!(svc->flags & SVC_ONESHOT) || (svc->flags & SVC_RESTART)) {
+        kill(-pid, SIGKILL);
+        NOTICE("process '%s' killing any children in process group\n", svc->name);
+    }
+
+    /* remove any sockets we may have created */
+    for (si = svc->sockets; si; si = si->next) {
+        char tmp[128];
+        snprintf(tmp, sizeof(tmp), ANDROID_SOCKET_DIR"/%s", si->name);
+        unlink(tmp);
+    }
+
+    svc->pid = 0;
+    svc->flags &= (~SVC_RUNNING);
+
+        /* oneshot processes go into the disabled state on exit,
+         * except when manually restarted. */
+    if ((svc->flags & SVC_ONESHOT) && !(svc->flags & SVC_RESTART)) {
+        svc->flags |= SVC_DISABLED;
+    }
+
+        /* disabled and reset processes do not get restarted automatically */
+    if (svc->flags & (SVC_DISABLED | SVC_RESET) )  {
+        notify_service_state(svc->name, "stopped");
+        return 0;
+    }
+
+    now = gettime();
+    if ((svc->flags & SVC_CRITICAL) && !(svc->flags & SVC_RESTART)) {
+        if (svc->time_crashed + CRITICAL_CRASH_WINDOW >= now) {
+            if (++svc->nr_crashed > CRITICAL_CRASH_THRESHOLD) {
+                ERROR("critical process '%s' exited %d times in %d minutes; "
+                      "rebooting into recovery mode\n", svc->name,
+                      CRITICAL_CRASH_THRESHOLD, CRITICAL_CRASH_WINDOW / 60);
+                android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
+                return 0;
+            }
+        } else {
+            svc->time_crashed = now;
+            svc->nr_crashed = 1;
+        }
+    }
+
+    svc->flags &= (~SVC_RESTART);
+    svc->flags |= SVC_RESTARTING;
+
+    /* Execute all onrestart commands for this service. */
+    list_for_each(node, &svc->onrestart.commands) {
+        cmd = node_to_item(node, struct command, clist);
+        cmd->func(cmd->nargs, cmd->args);
+    }
+    notify_service_state(svc->name, "restarting");
+    return 0;
+}
+
+void handle_signal(void)
+{
+    char tmp[32];
+
+    /* we got a SIGCHLD - reap and restart as needed */
+    read(signal_recv_fd, tmp, sizeof(tmp));
+    while (!wait_for_one_process(0))
+        ;
+}
+
+void signal_init(void)
+{
+    int s[2];
+
+    struct sigaction act;
+    memset(&act, 0, sizeof(act));
+    act.sa_handler = sigchld_handler;
+    act.sa_flags = SA_NOCLDSTOP;
+    sigaction(SIGCHLD, &act, 0);
+
+    /* create a signalling mechanism for the sigchld handler */
+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, s) == 0) {
+        signal_fd = s[0];
+        signal_recv_fd = s[1];
+        fcntl(s[0], F_SETFD, FD_CLOEXEC);
+        fcntl(s[0], F_SETFL, O_NONBLOCK);
+        fcntl(s[1], F_SETFD, FD_CLOEXEC);
+        fcntl(s[1], F_SETFL, O_NONBLOCK);
+    }
+
+    handle_signal();
+}
+
+int get_signal_fd()
+{
+    return signal_recv_fd;
+}
diff --git a/signal_handler.h b/signal_handler.h
new file mode 100644
index 0000000..b092ccb
--- /dev/null
+++ b/signal_handler.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_SIGNAL_HANDLER_H_
+#define _INIT_SIGNAL_HANDLER_H_
+
+void signal_init(void);
+void handle_signal(void);
+int get_signal_fd(void);
+
+#endif
diff --git a/tags b/tags
new file mode 100644
index 0000000..9ef662a
--- /dev/null
+++ b/tags
@@ -0,0 +1,616 @@
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+!_TAG_PROGRAM_VERSION	5.6	//
+.INSTALLED	Android.mk	/^ALL_MODULES.$(LOCAL_MODULE).INSTALLED := \\$/;"	m
+ARRAY_SIZE	util.h	23;"	d
+AW_BOOST_UP_CPUS	boostup.c	31;"	d	file:
+AW_BOOST_UP_CPUS_NORMAL	boostup.c	37;"	d	file:
+AW_BOOST_UP_CPUS_NORMAL	boostup.c	41;"	d	file:
+AW_BOOST_UP_CPUS_NORMAL	boostup.c	45;"	d	file:
+AW_BOOST_UP_CPUS_PERF	boostup.c	36;"	d	file:
+AW_BOOST_UP_CPUS_PERF	boostup.c	40;"	d	file:
+AW_BOOST_UP_CPUS_PERF	boostup.c	44;"	d	file:
+AW_BOOST_UP_CPUS_VIDEO	boostup.c	38;"	d	file:
+AW_BOOST_UP_CPUS_VIDEO	boostup.c	42;"	d	file:
+AW_BOOST_UP_CPUS_VIDEO	boostup.c	46;"	d	file:
+AW_BOOST_UP_DRAM	boostup.c	30;"	d	file:
+AW_BOOST_UP_DRAM_4KLOCALVIDEO	boostup.c	54;"	d	file:
+AW_BOOST_UP_DRAM_BGMUSIC	boostup.c	53;"	d	file:
+AW_BOOST_UP_DRAM_DEFAULT	boostup.c	50;"	d	file:
+AW_BOOST_UP_DRAM_HOME	boostup.c	51;"	d	file:
+AW_BOOST_UP_DRAM_LOCALVIDEO	boostup.c	52;"	d	file:
+AW_BOOST_UP_GPU	boostup.c	33;"	d	file:
+AW_BOOST_UP_GPU_4KLOCALVIDEO	boostup.c	61;"	d	file:
+AW_BOOST_UP_GPU_BGMUSIC	boostup.c	60;"	d	file:
+AW_BOOST_UP_GPU_DEFAULT	boostup.c	57;"	d	file:
+AW_BOOST_UP_GPU_HOME	boostup.c	58;"	d	file:
+AW_BOOST_UP_GPU_LOCALVIDEO	boostup.c	59;"	d	file:
+AW_BOOST_UP_GPU_PERF	boostup.c	62;"	d	file:
+AW_BOOST_UP_TASK	boostup.c	32;"	d	file:
+BOOST_UP_DEBUG	boostup.c	/^static bool BOOST_UP_DEBUG = true;$/;"	v	file:
+BOOTCHART	bootchart.h	21;"	d
+BOOTCHART_DEFAULT_TIME_SEC	bootchart.h	31;"	d
+BOOTCHART_MAX_TIME_SEC	bootchart.h	32;"	d
+BOOTCHART_POLLING_MS	bootchart.h	30;"	d
+COMMAND	init_parser.c	52;"	d	file:
+COMMAND_RETRY_TIMEOUT	init.h	85;"	d
+CONFIG_MEM_FILE	init_mem_opt.c	179;"	d	file:
+CRITICAL_CRASH_THRESHOLD	signal_handler.c	41;"	d	file:
+CRITICAL_CRASH_WINDOW	signal_handler.c	42;"	d	file:
+DATA_MNT_POINT	builtins.c	444;"	d	file:
+DEVNAME_UEVENT_DEVNAME	ueventd.h	/^        DEVNAME_UEVENT_DEVNAME,$/;"	e	enum:ueventd_subsystem::__anon3
+DEVNAME_UEVENT_DEVPATH	ueventd.h	/^        DEVNAME_UEVENT_DEVPATH,$/;"	e	enum:ueventd_subsystem::__anon3
+DEVNAME_UNKNOWN	ueventd.h	/^        DEVNAME_UNKNOWN = 0,$/;"	e	enum:ueventd_subsystem::__anon3
+DEVPATH_LEN	devices.c	641;"	d	file:
+DEV_NAME	watchdogd.c	27;"	d	file:
+DISP_SYS_NODE	init_mem_opt.c	83;"	d	file:
+DUMP	parser.c	/^void DUMP(void)$/;"	f
+ENV	init.c	/^static const char *ENV[32];$/;"	v	file:
+ERROR	log.h	22;"	d
+FILE_BUFF_SIZE	bootchart.c	78;"	d	file:
+FIRMWARE_DIR1	devices.c	54;"	d	file:
+FIRMWARE_DIR2	devices.c	55;"	d	file:
+FIRMWARE_DIR3	devices.c	56;"	d	file:
+FileBuff	bootchart.c	/^} FileBuffRec, *FileBuff;$/;"	t	typeref:struct:__anon1	file:
+FileBuffRec	bootchart.c	/^} FileBuffRec, *FileBuff;$/;"	t	typeref:struct:__anon1	file:
+INFO	log.h	24;"	d
+INIT_BINARY	Android.mk	/^$(SYMLINKS): INIT_BINARY := $(LOCAL_MODULE)$/;"	m
+INIT_PARSER_MAXARGS	init_parser.h	20;"	d
+KERNEL_OPTION	bootchart.c	318;"	d	file:
+KEYWORD	init_parser.c	57;"	d	file:
+KEYWORD	init_parser.c	69;"	d	file:
+KEYWORD	keywords.h	/^    KEYWORD(capability,  OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(chdir,       COMMAND, 1, do_chdir)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(chmod,       COMMAND, 2, do_chmod)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(chown,       COMMAND, 2, do_chown)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(chroot,      COMMAND, 1, do_chroot)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(class,       OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(class_reset, COMMAND, 1, do_class_reset)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(class_start, COMMAND, 1, do_class_start)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(class_stop,  COMMAND, 1, do_class_stop)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(console,     OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(copy,        COMMAND, 2, do_copy)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(critical,    OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(disabled,    OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(domainname,  COMMAND, 1, do_domainname)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(enable,      COMMAND, 1, do_enable)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(exec,        COMMAND, 1, do_exec)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(export,      COMMAND, 2, do_export)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(format_userdata,      COMMAND, 1, do_format_userdata)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(group,       OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(hostname,    COMMAND, 1, do_hostname)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(ifup,        COMMAND, 1, do_ifup)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(import,      SECTION, 1, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(insmod,      COMMAND, 1, do_insmod)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(ioprio,      OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(keycodes,    OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(load_all_props,        COMMAND, 0, do_load_all_props)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(load_persist_props,    COMMAND, 0, do_load_persist_props)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(loglevel,    COMMAND, 1, do_loglevel)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(mkdir,       COMMAND, 1, do_mkdir)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(mount,       COMMAND, 3, do_mount)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(mount_all,   COMMAND, 1, do_mount_all)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(on,          SECTION, 0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(oneshot,     OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(onrestart,   OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(powerctl,    COMMAND, 1, do_powerctl)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(restart,     COMMAND, 1, do_restart)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(restorecon,  COMMAND, 1, do_restorecon)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(restorecon_recursive,  COMMAND, 1, do_restorecon_recursive)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(rm,          COMMAND, 1, do_rm)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(rmdir,       COMMAND, 1, do_rmdir)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(seclabel,    OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(service,     SECTION, 0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(setcon,      COMMAND, 1, do_setcon)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(setenforce,  COMMAND, 1, do_setenforce)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(setenv,      OPTION,  2, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(setkey,      COMMAND, 0, do_setkey)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(setprop,     COMMAND, 2, do_setprop)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(setrlimit,   COMMAND, 3, do_setrlimit)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(setsebool,   COMMAND, 2, do_setsebool)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(socket,      OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(start,       COMMAND, 1, do_start)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(stop,        COMMAND, 1, do_stop)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(swapon_all,  COMMAND, 1, do_swapon_all)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(symlink,     COMMAND, 1, do_symlink)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(sysclktz,    COMMAND, 1, do_sysclktz)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(trigger,     COMMAND, 1, do_trigger)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(user,        OPTION,  0, 0)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(wait,        COMMAND, 1, do_wait)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	/^    KEYWORD(write,       COMMAND, 2, do_write)$/;"	e	enum:__anon8
+KEYWORD	keywords.h	113;"	d
+KEYWORD	keywords.h	46;"	d
+KEYWORD	ueventd_keywords.h	/^    KEYWORD(devname,        OPTION,     1)$/;"	e	enum:__anon2
+KEYWORD	ueventd_keywords.h	/^    KEYWORD(dirname,        OPTION,     1)$/;"	e	enum:__anon2
+KEYWORD	ueventd_keywords.h	/^    KEYWORD(subsystem,      SECTION,    1)$/;"	e	enum:__anon2
+KEYWORD	ueventd_keywords.h	14;"	d
+KEYWORD	ueventd_keywords.h	3;"	d
+KEYWORD	ueventd_parser.c	40;"	d	file:
+KEYWORD	ueventd_parser.c	51;"	d	file:
+KEYWORD_COUNT	keywords.h	/^    KEYWORD_COUNT,$/;"	e	enum:__anon8
+KEYWORD_COUNT	ueventd_keywords.h	/^    KEYWORD_COUNT,$/;"	e	enum:__anon2
+K_UNKNOWN	keywords.h	/^    K_UNKNOWN,$/;"	e	enum:__anon8
+K_UNKNOWN	ueventd_keywords.h	/^    K_UNKNOWN,$/;"	e	enum:__anon2
+LCD_X_STR	init_mem_opt.c	81;"	d	file:
+LCD_Y_STR	init_mem_opt.c	82;"	d	file:
+LOCAL_FORCE_STATIC_EXECUTABLE	Android.mk	/^LOCAL_FORCE_STATIC_EXECUTABLE := true$/;"	m
+LOCAL_MODULE	Android.mk	/^LOCAL_MODULE:= init$/;"	m
+LOCAL_MODULE_PATH	Android.mk	/^LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)$/;"	m
+LOCAL_PATH	Android.mk	/^LOCAL_PATH:= $(call my-dir)$/;"	m
+LOCAL_SRC_FILES	Android.mk	/^LOCAL_SRC_FILES:= \\$/;"	m
+LOCAL_STATIC_LIBRARIES	Android.mk	/^LOCAL_STATIC_LIBRARIES := \\$/;"	m
+LOCAL_UNSTRIPPED_PATH	Android.mk	/^LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)$/;"	m
+LOG_ACCT	bootchart.c	44;"	d	file:
+LOG_DISK	bootchart.c	42;"	d	file:
+LOG_HEADER	bootchart.c	43;"	d	file:
+LOG_PROCS	bootchart.c	41;"	d	file:
+LOG_ROOT	bootchart.c	39;"	d	file:
+LOG_STARTFILE	bootchart.c	46;"	d	file:
+LOG_STAT	bootchart.c	40;"	d	file:
+LOG_STOPFILE	bootchart.c	47;"	d	file:
+MAX_MTD_PARTITIONS	util.c	193;"	d	file:
+MAX_PARAMETERS	builtins.c	258;"	d	file:
+MEMINFO_NODE	init_mem_opt.c	54;"	d	file:
+NOTICE	log.h	23;"	d
+NR_SVC_SUPP_GIDS	init.h	83;"	d
+OPTION	init_parser.c	53;"	d	file:
+OPTION	ueventd_parser.c	36;"	d	file:
+PARSER_H_	parser.h	18;"	d
+PERSISTENT_PROPERTY_DIR	property_service.c	52;"	d	file:
+RAW	parser.c	8;"	d	file:
+SAMPLE_PERIOD	bootchart.c	38;"	d	file:
+SCRIPT_BUF_SIZE	init_mem_opt.c	84;"	d	file:
+SECTION	init_parser.c	51;"	d	file:
+SECTION	ueventd_parser.c	35;"	d	file:
+SVC_CONSOLE	init.h	75;"	d
+SVC_CRITICAL	init.h	76;"	d
+SVC_DISABLED	init.h	71;"	d
+SVC_DISABLED_START	init.h	81;"	d
+SVC_ONESHOT	init.h	72;"	d
+SVC_RC_DISABLED	init.h	79;"	d
+SVC_RESET	init.h	77;"	d
+SVC_RESTART	init.h	80;"	d
+SVC_RESTARTING	init.h	74;"	d
+SVC_RUNNING	init.h	73;"	d
+SYMLINKS	Android.mk	/^SYMLINKS := \\$/;"	m
+SYSFS_PREFIX	devices.c	53;"	d	file:
+T_EOF	parser.h	20;"	d
+T_NEWLINE	parser.h	22;"	d
+T_TEXT	parser.h	21;"	d
+UEVENTD_PARSER_MAXARGS	ueventd_parser.h	22;"	d
+UEVENT_MSG_LEN	devices.c	945;"	d	file:
+UNUSED	devices.c	51;"	d	file:
+VERSION	bootchart.c	37;"	d	file:
+_BOOTCHART_H	bootchart.h	18;"	d
+_INIT_DEVICES_H	devices.h	18;"	d
+_INIT_INIT_H	init.h	18;"	d
+_INIT_INIT_PARSER_H_	init_parser.h	18;"	d
+_INIT_KEYCHORDS_H_	keychords.h	18;"	d
+_INIT_LOG_H_	log.h	18;"	d
+_INIT_PROPERTY_H	property_service.h	18;"	d
+_INIT_SIGNAL_HANDLER_H_	signal_handler.h	18;"	d
+_INIT_UEVENTD_H_	ueventd.h	18;"	d
+_INIT_UEVENTD_PARSER_H_	ueventd_parser.h	18;"	d
+_INIT_UTIL_H_	util.h	18;"	d
+_INIT_WATCHDOGD_H_	watchdogd.h	18;"	d
+_REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H_	property_service.c	33;"	d	file:
+__MAKE_KEYWORD_ENUM__	keywords.h	112;"	d
+__MAKE_KEYWORD_ENUM__	keywords.h	45;"	d
+__MAKE_KEYWORD_ENUM__	ueventd_keywords.h	13;"	d
+__MAKE_KEYWORD_ENUM__	ueventd_keywords.h	2;"	d
+__ifupdown	builtins.c	/^static int __ifupdown(const char *interface, int up)$/;"	f	file:
+__property_get	property_service.c	/^int __property_get(const char *name, char *value)$/;"	f
+_chmod	builtins.c	/^static int _chmod(const char *path, mode_t mode)$/;"	f	file:
+_chown	builtins.c	/^static int _chown(const char *path, unsigned int uid, unsigned int gid)$/;"	f	file:
+_open	builtins.c	/^static int _open(const char *path)$/;"	f	file:
+action	devices.c	/^    const char *action;$/;"	m	struct:uevent	file:
+action	init.h	/^struct action {$/;"	s
+action_add_queue_tail	init_parser.c	/^void action_add_queue_tail(struct action *act)$/;"	f
+action_for_each_trigger	init_parser.c	/^void action_for_each_trigger(const char *trigger,$/;"	f
+action_queue_empty	init_parser.c	/^int action_queue_empty()$/;"	f
+action_remove_queue_head	init_parser.c	/^struct action *action_remove_queue_head(void)$/;"	f
+add_dev_perms	devices.c	/^int add_dev_perms(const char *name, const char *attr,$/;"	f
+add_environment	init.c	/^int add_environment(const char *key, const char *val)$/;"	f
+add_platform_device	devices.c	/^static void add_platform_device(const char *path)$/;"	f	file:
+add_service_keycodes	keychords.c	/^void add_service_keycodes(struct service *svc)$/;"	f
+alist	init.h	/^    struct listnode alist;$/;"	m	struct:action	typeref:struct:action::listnode
+android_name_to_id	util.c	/^static unsigned int android_name_to_id(const char *name)$/;"	f	file:
+args	init.h	/^    char *args[1];$/;"	m	struct:command
+args	init.h	/^    char *args[1];$/;"	m	struct:service
+assemble_devpath	devices.c	/^static bool assemble_devpath(char *devpath, const char *dirname,$/;"	f	file:
+attr	devices.c	/^    char *attr;$/;"	m	struct:perms_	file:
+audit_callback	init.c	/^static int audit_callback(void *data, security_class_t cls __attribute__((unused)), char *buf, size_t len)$/;"	f	file:
+aw_boost_up_perf	boostup.c	/^int aw_boost_up_perf(const char *name, const char *value)$/;"	f
+aw_get_para	boostup.c	/^static int aw_get_para(const char *value, int *pid, unsigned int *index)$/;"	f	file:
+aw_init_boostup	boostup.c	/^int aw_init_boostup(int mode)$/;"	f
+aw_init_runmode	property_service.c	/^static int aw_init_runmode(void)$/;"	f	file:
+boost_up_cpus_fd	boostup.c	/^static int boost_up_cpus_fd = -1;$/;"	v	file:
+boost_up_dram_fd	boostup.c	/^static int boost_up_dram_fd = -1;$/;"	v	file:
+boost_up_gpu_fd	boostup.c	/^static int boost_up_gpu_fd = -1;$/;"	v	file:
+boost_up_task_fd	boostup.c	/^static int boost_up_task_fd = -1;$/;"	v	file:
+bootchart_count	init.c	/^static int   bootchart_count;$/;"	v	file:
+bootchart_finish	bootchart.c	/^void  bootchart_finish( void )$/;"	f
+bootchart_init	bootchart.c	/^int   bootchart_init( void )$/;"	f
+bootchart_init_action	init.c	/^static int bootchart_init_action(int nargs, char **args)$/;"	f	file:
+bootchart_step	bootchart.c	/^int  bootchart_step( void )$/;"	f
+bootmode	init.c	/^static char bootmode[32];$/;"	v	file:
+check_control_mac_perms	property_service.c	/^static int check_control_mac_perms(const char *name, char *sctx)$/;"	f	file:
+check_mac_perms	property_service.c	/^static int check_mac_perms(const char *name, char *sctx)$/;"	f	file:
+check_perms	property_service.c	/^static int check_perms(const char *name, char *sctx)$/;"	f	file:
+classname	init.h	/^    const char *classname;$/;"	m	struct:service
+clist	init.h	/^    struct listnode clist;$/;"	m	struct:command	typeref:struct:command::listnode
+close_on_exec	bootchart.c	/^close_on_exec(int  fd)$/;"	f	file:
+coldboot	devices.c	/^static void coldboot(const char *path)$/;"	f	file:
+coldboot_done	util.h	/^static const char *coldboot_done = "\/dev\/.coldboot_done";$/;"	v
+command	init.h	/^struct command$/;"	s
+command_queue	init.c	/^static struct listnode *command_queue = NULL;$/;"	v	typeref:struct:listnode	file:
+commands	init.h	/^    struct listnode commands;$/;"	m	struct:action	typeref:struct:action::listnode
+config_item	init_mem_opt.c	/^void config_item(char *buf)$/;"	f
+console	init.c	/^static char console[32];$/;"	v	file:
+console_init_action	init.c	/^static int console_init_action(int nargs, char **args)$/;"	f	file:
+console_name	init.c	/^static char console_name[PROP_VALUE_MAX] = "\/dev\/console";$/;"	v	file:
+context	parser.h	/^    void *context;$/;"	m	struct:parse_state
+count	bootchart.c	/^    int   count;$/;"	m	struct:__anon1	file:
+create_socket	util.c	/^int create_socket(const char *name, int type, mode_t perm, uid_t uid,$/;"	f
+cur_action	init.c	/^static struct action *cur_action = NULL;$/;"	v	typeref:struct:action	file:
+cur_command	init.c	/^static struct command *cur_command = NULL;$/;"	v	typeref:struct:command	file:
+current	init.h	/^    struct command *current;$/;"	m	struct:action	typeref:struct:action::command
+data	bootchart.c	/^    char  data[FILE_BUFF_SIZE];$/;"	m	struct:__anon1	file:
+decode_uid	util.c	/^unsigned int decode_uid(const char *s)$/;"	f
+device_fd	devices.c	/^static int device_fd = -1;$/;"	v	file:
+device_init	devices.c	/^void device_init(void)$/;"	f
+device_name	devices.c	/^    const char *device_name;$/;"	m	struct:uevent	file:
+devname_src	ueventd.h	/^    } devname_src;$/;"	m	struct:ueventd_subsystem	typeref:enum:ueventd_subsystem::__anon3
+dirname	ueventd.h	/^    const char *dirname;$/;"	m	struct:ueventd_subsystem
+do_chdir	builtins.c	/^int do_chdir(int nargs, char **args)$/;"	f
+do_chmod	builtins.c	/^int do_chmod(int nargs, char **args) {$/;"	f
+do_chown	builtins.c	/^int do_chown(int nargs, char **args) {$/;"	f
+do_chroot	builtins.c	/^int do_chroot(int nargs, char **args)$/;"	f
+do_class_reset	builtins.c	/^int do_class_reset(int nargs, char **args)$/;"	f
+do_class_start	builtins.c	/^int do_class_start(int nargs, char **args)$/;"	f
+do_class_stop	builtins.c	/^int do_class_stop(int nargs, char **args)$/;"	f
+do_coldboot	devices.c	/^static void do_coldboot(DIR *d)$/;"	f	file:
+do_copy	builtins.c	/^int do_copy(int nargs, char **args)$/;"	f
+do_domainname	builtins.c	/^int do_domainname(int nargs, char **args)$/;"	f
+do_enable	builtins.c	/^int do_enable(int nargs, char **args)$/;"	f
+do_exec	builtins.c	/^int do_exec(int nargs, char **args)$/;"	f
+do_export	builtins.c	/^int do_export(int nargs, char **args)$/;"	f
+do_format_userdata	builtins.c	/^int do_format_userdata(int nargs, char **args)$/;"	f
+do_hostname	builtins.c	/^int do_hostname(int nargs, char **args)$/;"	f
+do_ifup	builtins.c	/^int do_ifup(int nargs, char **args)$/;"	f
+do_insmod	builtins.c	/^int do_insmod(int nargs, char **args)$/;"	f
+do_insmod_inner	builtins.c	/^static int do_insmod_inner(int nargs, char **args, int opt_len)$/;"	f	file:
+do_load_all_props	builtins.c	/^int do_load_all_props(int nargs, char **args) {$/;"	f
+do_load_persist_props	builtins.c	/^int do_load_persist_props(int nargs, char **args) {$/;"	f
+do_log_file	bootchart.c	/^do_log_file(FileBuff  log, const char*  procfile)$/;"	f	file:
+do_log_ln	bootchart.c	/^do_log_ln(FileBuff  log)$/;"	f	file:
+do_log_procs	bootchart.c	/^do_log_procs(FileBuff  log)$/;"	f	file:
+do_log_uptime	bootchart.c	/^do_log_uptime(FileBuff  log)$/;"	f	file:
+do_loglevel	builtins.c	/^int do_loglevel(int nargs, char **args) {$/;"	f
+do_mkdir	builtins.c	/^int do_mkdir(int nargs, char **args)$/;"	f
+do_mount	builtins.c	/^int do_mount(int nargs, char **args)$/;"	f
+do_mount_all	builtins.c	/^int do_mount_all(int nargs, char **args)$/;"	f
+do_powerctl	builtins.c	/^int do_powerctl(int nargs, char **args)$/;"	f
+do_restart	builtins.c	/^int do_restart(int nargs, char **args)$/;"	f
+do_restorecon	builtins.c	/^int do_restorecon(int nargs, char **args) {$/;"	f
+do_restorecon_recursive	builtins.c	/^int do_restorecon_recursive(int nargs, char **args) {$/;"	f
+do_rm	builtins.c	/^int do_rm(int nargs, char **args)$/;"	f
+do_rmdir	builtins.c	/^int do_rmdir(int nargs, char **args)$/;"	f
+do_setcon	builtins.c	/^int do_setcon(int nargs, char **args) {$/;"	f
+do_setenforce	builtins.c	/^int do_setenforce(int nargs, char **args) {$/;"	f
+do_setkey	builtins.c	/^int do_setkey(int nargs, char **args)$/;"	f
+do_setprop	builtins.c	/^int do_setprop(int nargs, char **args)$/;"	f
+do_setrlimit	builtins.c	/^int do_setrlimit(int nargs, char **args)$/;"	f
+do_setsebool	builtins.c	/^int do_setsebool(int nargs, char **args) {$/;"	f
+do_start	builtins.c	/^int do_start(int nargs, char **args)$/;"	f
+do_stop	builtins.c	/^int do_stop(int nargs, char **args)$/;"	f
+do_swapon_all	builtins.c	/^int do_swapon_all(int nargs, char **args)$/;"	f
+do_symlink	builtins.c	/^int do_symlink(int nargs, char **args)$/;"	f
+do_sysclktz	builtins.c	/^int do_sysclktz(int nargs, char **args)$/;"	f
+do_trigger	builtins.c	/^int do_trigger(int nargs, char **args)$/;"	f
+do_wait	builtins.c	/^int do_wait(int nargs, char **args)$/;"	f
+do_write	builtins.c	/^int do_write(int nargs, char **args)$/;"	f
+dp	devices.c	/^    struct perms_ dp;$/;"	m	struct:perm_node	typeref:struct:perm_node::perms_	file:
+envvars	init.h	/^    struct svcenvinfo *envvars;$/;"	m	struct:service	typeref:struct:service::svcenvinfo
+execute_one_command	init.c	/^void execute_one_command(void)$/;"	f
+expand_props	init_parser.c	/^int expand_props(char *dst, const char *src, int dst_size)$/;"	f
+export_kernel_boot_props	init.c	/^static void export_kernel_boot_props(void)$/;"	f	file:
+fd	bootchart.c	/^    int   fd;$/;"	m	struct:__anon1	file:
+fd	property_service.c	/^    int fd;$/;"	m	struct:__anon5	file:
+file_buff_done	bootchart.c	/^file_buff_done( FileBuff  buff )$/;"	f	file:
+file_buff_open	bootchart.c	/^file_buff_open( FileBuff  buff, const char*  path )$/;"	f	file:
+file_buff_write	bootchart.c	/^file_buff_write( FileBuff  buff, const void*  src, int  len )$/;"	f	file:
+filename	init.h	/^    const char *filename;$/;"	m	struct:command
+filename	init_parser.c	/^    const char *filename;$/;"	m	struct:import	file:
+filename	parser.h	/^    const char *filename;$/;"	m	struct:parse_state
+find_mtd_partitions	util.c	/^static void find_mtd_partitions(void)$/;"	f	file:
+find_pci_device_prefix	devices.c	/^static int find_pci_device_prefix(const char *path, char *buf, ssize_t buf_sz)$/;"	f	file:
+find_platform_device	devices.c	/^static struct platform_node *find_platform_device(const char *path)$/;"	f	file:
+firmware	devices.c	/^    const char *firmware;$/;"	m	struct:uevent	file:
+fixup_sys_perms	devices.c	/^void fixup_sys_perms(const char *upath)$/;"	f
+flag	builtins.c	/^    unsigned flag;$/;"	m	struct:__anon9	file:
+flags	init.h	/^    unsigned flags;$/;"	m	struct:service
+flags	init_parser.c	/^    unsigned char flags;$/;"	m	struct:__anon4	file:
+flags	ueventd_parser.c	/^    unsigned char flags;$/;"	m	struct:__anon6	file:
+func	init.h	/^    int (*func)(int nargs, char **args);$/;"	m	struct:command
+func	init_parser.c	/^    int (*func)(int nargs, char **args);$/;"	m	struct:__anon4	file:
+g_total_mem	init_mem_opt.c	/^int g_total_mem = 0; \/* unit: MB *\/$/;"	v
+get_android_id	ueventd.c	/^static int get_android_id(const char *id)$/;"	f	file:
+get_block_device_symlinks	devices.c	/^static char **get_block_device_symlinks(struct uevent *uevent)$/;"	f	file:
+get_character_device_symlinks	devices.c	/^static char **get_character_device_symlinks(struct uevent *uevent)$/;"	f	file:
+get_chip_id	init.c	/^static int get_chip_id(char *buf, size_t size)$/;"	f	file:
+get_device_fd	devices.c	/^int get_device_fd()$/;"	f
+get_device_perm	devices.c	/^static mode_t get_device_perm(const char *path, const char **links,$/;"	f	file:
+get_dram_size	init_mem_opt.c	/^static int get_dram_size(void)$/;"	f	file:
+get_first_command	init.c	/^static struct command *get_first_command(struct action *act)$/;"	f	file:
+get_hardware_name	util.c	/^void get_hardware_name(char *hardware, unsigned int *revision)$/;"	f
+get_keychord_fd	keychords.c	/^int get_keychord_fd()$/;"	f
+get_lcd_resolution	init_mem_opt.c	/^static bool get_lcd_resolution(int *width, int *height)$/;"	f	file:
+get_mode	builtins.c	/^static mode_t get_mode(const char *s) {$/;"	f	file:
+get_next_command	init.c	/^static struct command *get_next_command(struct action *act, struct command *cmd)$/;"	f	file:
+get_property_set_fd	property_service.c	/^int get_property_set_fd()$/;"	f
+get_property_workspace	property_service.c	/^void get_property_workspace(int *fd, int *sz)$/;"	f
+get_signal_fd	signal_handler.c	/^int get_signal_fd()$/;"	f
+get_usecs	devices.c	/^static inline suseconds_t get_usecs(void)$/;"	f	file:
+get_usecs	devices.c	384;"	d	file:
+get_value_for_key	init_mem_opt.c	/^bool get_value_for_key(char *main_key, char *sub_key, char ret_value[], int len)$/;"	f
+gettime	util.c	/^time_t gettime(void)$/;"	f
+gid	devices.c	/^    unsigned int gid;$/;"	m	struct:perms_	file:
+gid	init.h	/^    gid_t gid;$/;"	m	struct:service
+gid	init.h	/^    gid_t gid;$/;"	m	struct:socketinfo
+handle_block_device_event	devices.c	/^static void handle_block_device_event(struct uevent *uevent)$/;"	f	file:
+handle_control_message	init.c	/^void handle_control_message(const char *msg, const char *arg)$/;"	f
+handle_device	devices.c	/^static void handle_device(const char *action, const char *devpath,$/;"	f	file:
+handle_device_event	devices.c	/^static void handle_device_event(struct uevent *uevent)$/;"	f	file:
+handle_device_fd	devices.c	/^void handle_device_fd()$/;"	f
+handle_firmware_event	devices.c	/^static void handle_firmware_event(struct uevent *uevent)$/;"	f	file:
+handle_generic_device_event	devices.c	/^static void handle_generic_device_event(struct uevent *uevent)$/;"	f	file:
+handle_keychord	keychords.c	/^void handle_keychord()$/;"	f
+handle_platform_device_event	devices.c	/^static void handle_platform_device_event(struct uevent *uevent)$/;"	f	file:
+handle_property_set_fd	property_service.c	/^void handle_property_set_fd()$/;"	f
+handle_signal	signal_handler.c	/^void handle_signal(void)$/;"	f
+hardware	init.c	/^static char hardware[32];$/;"	v	file:
+hardware	ueventd.c	/^static char hardware[32];$/;"	v	file:
+hash	init.h	/^    unsigned hash;$/;"	m	struct:action
+have_console	init.c	/^static int have_console;$/;"	v	file:
+import	init_parser.c	/^struct import {$/;"	s	file:
+import_kernel_cmdline	util.c	/^void import_kernel_cmdline(int in_qemu,$/;"	f
+import_kernel_nv	init.c	/^static void import_kernel_nv(char *name, int for_emulator)$/;"	f	file:
+import_kernel_nv	ueventd.c	/^static void import_kernel_nv(char *name, int in_qemu)$/;"	f	file:
+init_parse_config_file	init_parser.c	/^int init_parse_config_file(const char *fn)$/;"	f
+init_property_area	property_service.c	/^static int init_property_area(void)$/;"	f	file:
+init_workspace	property_service.c	/^static int init_workspace(workspace *w, size_t size)$/;"	f	file:
+insmod	builtins.c	/^static int insmod(const char *filename, char *options)$/;"	f	file:
+ioprio_class	init.h	/^    int ioprio_class;$/;"	m	struct:service
+ioprio_pri	init.h	/^    int ioprio_pri;$/;"	m	struct:service
+is_booting	devices.c	/^static int is_booting(void)$/;"	f	file:
+is_last_command	init.c	/^static int is_last_command(struct action *act, struct command *cmd)$/;"	f	file:
+is_legal_property_name	property_service.c	/^static bool is_legal_property_name(const char* name, size_t namelen)$/;"	f	file:
+kernel_logger	devices.c	/^static inline void __attribute__((__deprecated__)) kernel_logger()$/;"	f	file:
+keychord_fd	keychords.c	/^static int keychord_fd = -1;$/;"	v	file:
+keychord_id	init.h	/^    int keychord_id;$/;"	m	struct:service
+keychord_init	keychords.c	/^void keychord_init()$/;"	f
+keychord_init_action	init.c	/^static int keychord_init_action(int nargs, char **args)$/;"	f	file:
+keychords	keychords.c	/^static struct input_keychord *keychords = 0;$/;"	v	typeref:struct:input_keychord	file:
+keychords_count	keychords.c	/^static int keychords_count = 0;$/;"	v	file:
+keychords_length	keychords.c	/^static int keychords_length = 0;$/;"	v	file:
+keycodes	init.h	/^    int *keycodes;$/;"	m	struct:service
+keyword_info	init_parser.c	/^} keyword_info[KEYWORD_COUNT] = {$/;"	v	typeref:struct:__anon4	file:
+keyword_info	ueventd_parser.c	/^} keyword_info[KEYWORD_COUNT] = {$/;"	v	typeref:struct:__anon6	file:
+kw_func	init_parser.c	73;"	d	file:
+kw_is	init_parser.c	71;"	d	file:
+kw_is	ueventd_parser.c	53;"	d	file:
+kw_name	init_parser.c	72;"	d	file:
+kw_nargs	init_parser.c	74;"	d	file:
+kw_nargs	ueventd_parser.c	54;"	d	file:
+line	init.h	/^    int line;$/;"	m	struct:command
+line	parser.h	/^    int line;$/;"	m	struct:parse_state
+list	devices.c	/^    struct listnode list;$/;"	m	struct:platform_node	typeref:struct:platform_node::listnode	file:
+list	init_parser.c	/^    struct listnode list;$/;"	m	struct:import	typeref:struct:import::listnode	file:
+load_all_props	property_service.c	/^void load_all_props(void)$/;"	f
+load_firmware	devices.c	/^static int load_firmware(int fw_fd, int loading_fd, int data_fd)$/;"	f	file:
+load_override_properties	property_service.c	/^static void load_override_properties() {$/;"	f	file:
+load_persist_props	property_service.c	/^void load_persist_props(void)$/;"	f
+load_persistent_properties	property_service.c	/^static void load_persistent_properties()$/;"	f	file:
+load_properties	property_service.c	/^static void load_properties(char *data, const char *filter)$/;"	f	file:
+load_properties_from_file	property_service.c	/^static void load_properties_from_file(const char *fn, const char *filter)$/;"	f	file:
+log_callback	init.c	/^int log_callback(int type, const char *fmt, ...)$/;"	f
+log_disks	bootchart.c	/^static FileBuffRec  log_disks[1];$/;"	v	file:
+log_event_print	devices.c	379;"	d	file:
+log_event_print	devices.c	383;"	d	file:
+log_header	bootchart.c	/^log_header(void)$/;"	f	file:
+log_procs	bootchart.c	/^static FileBuffRec  log_procs[1];$/;"	v	file:
+log_stat	bootchart.c	/^static FileBuffRec  log_stat[1];$/;"	v	file:
+lookup_keyword	init_parser.c	/^static int lookup_keyword(const char *s)$/;"	f	file:
+lookup_keyword	ueventd_parser.c	/^static int lookup_keyword(const char *s)$/;"	f	file:
+main	init.c	/^int main(int argc, char **argv)$/;"	f
+major	devices.c	/^    int major;$/;"	m	struct:uevent	file:
+make_device	devices.c	/^static void make_device(const char *path,$/;"	f	file:
+make_dir	util.c	/^int make_dir(const char *path, mode_t mode)$/;"	f
+make_link	util.c	/^void make_link(const char *oldpath, const char *newpath)$/;"	f
+minor	devices.c	/^    int minor;$/;"	m	struct:uevent	file:
+mix_hwrng_into_linux_rng_action	init.c	/^static int mix_hwrng_into_linux_rng_action(int nargs, char **args)$/;"	f	file:
+mkdir_recursive	util.c	/^int mkdir_recursive(const char *pathname, mode_t mode)$/;"	f
+mkdir_recursive_for_devpath	devices.c	/^static void mkdir_recursive_for_devpath(const char *devpath)$/;"	f	file:
+mount_flags	builtins.c	/^} mount_flags[] = {$/;"	v	typeref:struct:__anon9	file:
+msg_restart	init.c	/^static void msg_restart(const char *name)$/;"	f	file:
+msg_start	init.c	/^static void msg_start(const char *name)$/;"	f	file:
+msg_stop	init.c	/^static void msg_stop(const char *name)$/;"	f	file:
+mtd_name_to_number	util.c	/^int mtd_name_to_number(const char *name)$/;"	f
+mtd_part_count	util.c	/^static int mtd_part_count = -1;$/;"	v	file:
+mtd_part_map	util.c	/^} mtd_part_map[MAX_MTD_PARTITIONS];$/;"	v	typeref:struct:__anon7	file:
+name	builtins.c	/^    const char *name;$/;"	m	struct:__anon9	file:
+name	devices.c	/^    char *name;$/;"	m	struct:perms_	file:
+name	devices.c	/^    char *name;$/;"	m	struct:platform_node	file:
+name	init.h	/^    const char *name;$/;"	m	struct:action
+name	init.h	/^    const char *name;$/;"	m	struct:service
+name	init.h	/^    const char *name;$/;"	m	struct:socketinfo
+name	init.h	/^    const char *name;$/;"	m	struct:svcenvinfo
+name	init_parser.c	/^    const char *name;$/;"	m	struct:__anon4	file:
+name	ueventd.h	/^    const char *name;$/;"	m	struct:ueventd_subsystem
+name	ueventd_parser.c	/^    const char *name;$/;"	m	struct:__anon6	file:
+name	util.c	/^    char name[16];$/;"	m	struct:__anon7	file:
+nargs	init.h	/^    int nargs;$/;"	m	struct:command
+nargs	init.h	/^    int nargs;$/;"	m	struct:service
+nargs	init_parser.c	/^    unsigned char nargs;$/;"	m	struct:__anon4	file:
+nargs	ueventd_parser.c	/^    unsigned char nargs;$/;"	m	struct:__anon6	file:
+next	init.h	/^    struct socketinfo *next;$/;"	m	struct:socketinfo	typeref:struct:socketinfo::socketinfo
+next	init.h	/^    struct svcenvinfo *next;$/;"	m	struct:svcenvinfo	typeref:struct:svcenvinfo::svcenvinfo
+next_token	parser.c	/^int next_token(struct parse_state *state)$/;"	f
+nexttoken	parser.h	/^    int nexttoken;$/;"	m	struct:parse_state
+nkeycodes	init.h	/^    int nkeycodes;$/;"	m	struct:service
+notify_service_state	init.c	/^void notify_service_state(const char *name, const char *state)$/;"	f
+nr_crashed	init.h	/^    int nr_crashed;         \/* number of times crashed within window *\/$/;"	m	struct:service
+nr_supp_gids	init.h	/^    size_t nr_supp_gids;$/;"	m	struct:service
+number	util.c	/^    int number;$/;"	m	struct:__anon7	file:
+onrestart	init.h	/^    struct action onrestart;  \/* Actions to execute on restart. *\/$/;"	m	struct:service	typeref:struct:service::action
+open_console	init.c	/^static void open_console()$/;"	f	file:
+open_devnull_stdio	util.c	/^void open_devnull_stdio(void)$/;"	f
+open_log_file	bootchart.c	/^open_log_file(int*  plogfd, const char*  logfile)$/;"	f	file:
+pa_workspace	property_service.c	/^static workspace pa_workspace;$/;"	v	file:
+parse_action	init_parser.c	/^static void *parse_action(struct parse_state *state, int nargs, char **args)$/;"	f	file:
+parse_config	init_parser.c	/^static void parse_config(const char *fn, char *s)$/;"	f	file:
+parse_config	ueventd_parser.c	/^static void parse_config(const char *fn, char *s)$/;"	f	file:
+parse_device_name	devices.c	/^static const char *parse_device_name(struct uevent *uevent, unsigned int len)$/;"	f	file:
+parse_error	parser.c	/^void parse_error(struct parse_state *state, const char *fmt, ...)$/;"	f
+parse_event	devices.c	/^static void parse_event(const char *msg, struct uevent *uevent)$/;"	f	file:
+parse_import	init_parser.c	/^static void parse_import(struct parse_state *state, int nargs, char **args)$/;"	f	file:
+parse_line	parser.h	/^    void (*parse_line)(struct parse_state *state, int nargs, char **args);$/;"	m	struct:parse_state
+parse_line	ueventd_parser.c	/^static void parse_line(struct parse_state *state, char **args, int nargs)$/;"	f	file:
+parse_line_action	init_parser.c	/^static void parse_line_action(struct parse_state* state, int nargs, char **args)$/;"	f	file:
+parse_line_device	ueventd_parser.c	/^static void parse_line_device(struct parse_state *state __attribute__((unused)),$/;"	f	file:
+parse_line_no_op	init_parser.c	/^static void parse_line_no_op(struct parse_state *state, int nargs, char **args)$/;"	f	file:
+parse_line_no_op	ueventd_parser.c	/^static void parse_line_no_op(struct parse_state *state __attribute__((unused)),$/;"	f	file:
+parse_line_service	init_parser.c	/^static void parse_line_service(struct parse_state *state, int nargs, char **args)$/;"	f	file:
+parse_line_subsystem	ueventd_parser.c	/^static void parse_line_subsystem(struct parse_state *state, int nargs,$/;"	f	file:
+parse_new_section	init_parser.c	/^static void parse_new_section(struct parse_state *state, int kw,$/;"	f	file:
+parse_new_section	ueventd_parser.c	/^static void parse_new_section(struct parse_state *state, int kw,$/;"	f	file:
+parse_service	init_parser.c	/^static void *parse_service(struct parse_state *state, int nargs, char **args)$/;"	f	file:
+parse_state	parser.h	/^struct parse_state$/;"	s
+parse_subsystem	ueventd_parser.c	/^static void *parse_subsystem(struct parse_state *state,$/;"	f	file:
+partition_name	devices.c	/^    const char *partition_name;$/;"	m	struct:uevent	file:
+partition_num	devices.c	/^    int partition_num;$/;"	m	struct:uevent	file:
+path	devices.c	/^    char *path;$/;"	m	struct:platform_node	file:
+path	devices.c	/^    const char *path;$/;"	m	struct:uevent	file:
+path_len	devices.c	/^    int path_len;$/;"	m	struct:platform_node	file:
+perm	devices.c	/^    mode_t perm;$/;"	m	struct:perms_	file:
+perm	init.h	/^    int perm;$/;"	m	struct:socketinfo
+perm_node	devices.c	/^struct perm_node {$/;"	s	file:
+perm_path_matches	devices.c	/^static bool perm_path_matches(const char *path, struct perms_ *dp)$/;"	f	file:
+perms_	devices.c	/^struct perms_ {$/;"	s	file:
+persistent_properties_loaded	property_service.c	/^static int persistent_properties_loaded = 0;$/;"	v	file:
+pid	init.h	/^    pid_t pid;$/;"	m	struct:service
+platform_node	devices.c	/^struct platform_node {$/;"	s	file:
+plist	devices.c	/^    struct listnode plist;$/;"	m	struct:perm_node	typeref:struct:perm_node::listnode	file:
+prefix	devices.c	/^    unsigned short prefix;$/;"	m	struct:perms_	file:
+priv	parser.h	/^    void *priv;$/;"	m	struct:parse_state
+proc_read	bootchart.c	/^proc_read(const char*  filename, char* buff, size_t  buffsize)$/;"	f	file:
+process_firmware_event	devices.c	/^static void process_firmware_event(struct uevent *uevent)$/;"	f	file:
+process_kernel_cmdline	init.c	/^static void process_kernel_cmdline(void)$/;"	f	file:
+process_needs_restart	init.c	/^static time_t process_needs_restart;$/;"	v	file:
+properties_inited	property_service.c	/^int properties_inited(void)$/;"	f
+property_area_inited	property_service.c	/^static int property_area_inited = 0;$/;"	v	file:
+property_changed	init.c	/^void property_changed(const char *name, const char *value)$/;"	f
+property_get	property_service.h	/^int property_get(const char *name, char *value)$/;"	f
+property_init	property_service.c	/^void property_init(void)$/;"	f
+property_load_boot_defaults	property_service.c	/^void property_load_boot_defaults(void)$/;"	f
+property_opt_for_mem	init_mem_opt.c	/^void property_opt_for_mem(void)$/;"	f
+property_service_init_action	init.c	/^static int property_service_init_action(int nargs, char **args)$/;"	f	file:
+property_set	property_service.c	/^int property_set(const char *name, const char *value)$/;"	f
+property_set_fd	property_service.c	/^static int property_set_fd = -1;$/;"	v	file:
+property_triggers_enabled	init.c	/^static int property_triggers_enabled = 0;$/;"	v	file:
+ptr	parser.h	/^    char *ptr;$/;"	m	struct:parse_state
+publish_socket	init.c	/^static void publish_socket(const char *name, int fd)$/;"	f	file:
+push_chars	init_parser.c	/^static int push_chars(char **dst, int *len, const char *chars, int cnt)$/;"	f	file:
+qemu	init.c	/^static char qemu[32];$/;"	v	file:
+qlist	init.h	/^    struct listnode qlist;$/;"	m	struct:action	typeref:struct:action::listnode
+queue_all_property_triggers	init_parser.c	/^void queue_all_property_triggers()$/;"	f
+queue_builtin_action	init_parser.c	/^void queue_builtin_action(int (*func)(int nargs, char **args), char *name)$/;"	f
+queue_property_triggers	init_parser.c	/^void queue_property_triggers(const char *name, const char *value)$/;"	f
+queue_property_triggers_action	init.c	/^static int queue_property_triggers_action(int nargs, char **args)$/;"	f	file:
+read_file	util.c	/^void *read_file(const char *fn, unsigned *_sz)$/;"	f
+remove_link	util.c	/^void remove_link(const char *oldpath, const char *newpath)$/;"	f
+remove_platform_device	devices.c	/^static void remove_platform_device(const char *path)$/;"	f	file:
+restart_processes	init.c	/^static void restart_processes()$/;"	f	file:
+restart_service_if_needed	init.c	/^static void restart_service_if_needed(struct service *svc)$/;"	f	file:
+restorecon	util.c	/^int restorecon(const char* pathname)$/;"	f
+restorecon_recursive	util.c	/^int restorecon_recursive(const char* pathname)$/;"	f
+revision	init.c	/^static unsigned revision = 0;$/;"	v	file:
+revision	ueventd.c	/^static unsigned revision = 0;$/;"	v	file:
+roomage_a15	boostup.c	/^const char *roomage_a15[] = {$/;"	v
+roomage_a7	boostup.c	/^const char *roomage_a7[] = {$/;"	v
+runmode	boostup.c	/^static int runmode = 0xa7;$/;"	v	file:
+runmode	property_service.c	/^static unsigned int runmode = 0xa7; \/* 0xa7: CPU0-A7, 0xa15: CPU0-A15 *\/$/;"	v	file:
+sanitize	util.c	/^void sanitize(char *s)$/;"	f
+seclabel	init.h	/^    char *seclabel;$/;"	m	struct:service
+sehandle	init.c	/^struct selabel_handle *sehandle;$/;"	v	typeref:struct:selabel_handle
+sehandle_prop	init.c	/^struct selabel_handle *sehandle_prop;$/;"	v	typeref:struct:selabel_handle
+selinux_android_prop_context_handle	init.c	/^struct selabel_handle* selinux_android_prop_context_handle(void)$/;"	f
+selinux_init_all_handles	init.c	/^void selinux_init_all_handles(void)$/;"	f
+selinux_initialize	init.c	/^static void selinux_initialize(void)$/;"	f	file:
+selinux_is_disabled	init.c	/^static bool selinux_is_disabled(void)$/;"	f	file:
+selinux_is_enforcing	init.c	/^static bool selinux_is_enforcing(void)$/;"	f	file:
+selinux_reload_policy	init.c	/^int selinux_reload_policy(void)$/;"	f
+seopts_prop	init.c	/^static const struct selinux_opt seopts_prop[] = {$/;"	v	typeref:struct:selinux_opt	file:
+service	init.h	/^struct service {$/;"	s
+service_find_by_keychord	init_parser.c	/^struct service *service_find_by_keychord(int keychord_id)$/;"	f
+service_find_by_name	init_parser.c	/^struct service *service_find_by_name(const char *name)$/;"	f
+service_find_by_pid	init_parser.c	/^struct service *service_find_by_pid(pid_t pid)$/;"	f
+service_for_each	init_parser.c	/^void service_for_each(void (*func)(struct service *svc))$/;"	f
+service_for_each_class	init_parser.c	/^void service_for_each_class(const char *classname,$/;"	f
+service_for_each_flags	init_parser.c	/^void service_for_each_flags(unsigned matchflags,$/;"	f
+service_reset	init.c	/^void service_reset(struct service *svc)$/;"	f
+service_restart	init.c	/^void service_restart(struct service *svc)$/;"	f
+service_start	init.c	/^void service_start(struct service *svc, const char *dynamic_args)$/;"	f
+service_start_if_not_disabled	builtins.c	/^static void service_start_if_not_disabled(struct service *svc)$/;"	f	file:
+service_stop	init.c	/^void service_stop(struct service *svc)$/;"	f
+service_stop_or_reset	init.c	/^static void service_stop_or_reset(struct service *svc, int how)$/;"	f	file:
+set_device_permission	ueventd.c	/^void set_device_permission(int nargs, char **args)$/;"	f
+setkey	builtins.c	/^static int setkey(struct kbentry *kbe)$/;"	f	file:
+sigchld_handler	signal_handler.c	/^static void sigchld_handler(int s)$/;"	f	file:
+signal_fd	signal_handler.c	/^static int signal_fd = -1;$/;"	v	file:
+signal_init	signal_handler.c	/^void signal_init(void)$/;"	f
+signal_init_action	init.c	/^static int signal_init_action(int nargs, char **args)$/;"	f	file:
+signal_recv_fd	signal_handler.c	/^static int signal_recv_fd = -1;$/;"	v	file:
+size	property_service.c	/^    size_t size;$/;"	m	struct:__anon5	file:
+slist	init.h	/^    struct listnode slist;$/;"	m	struct:service	typeref:struct:service::listnode
+slist	ueventd.h	/^    struct listnode slist;$/;"	m	struct:ueventd_subsystem	typeref:struct:ueventd_subsystem::listnode
+socketcon	init.h	/^    const char *socketcon;$/;"	m	struct:socketinfo
+socketinfo	init.h	/^struct socketinfo {$/;"	s
+sockets	init.h	/^    struct socketinfo *sockets;$/;"	m	struct:service	typeref:struct:service::socketinfo
+start_property_service	property_service.c	/^void start_property_service(void)$/;"	f
+subsystem	devices.c	/^    const char *subsystem;$/;"	m	struct:uevent	file:
+supp_gids	init.h	/^    gid_t supp_gids[NR_SVC_SUPP_GIDS];$/;"	m	struct:service
+svcenvinfo	init.h	/^struct svcenvinfo {$/;"	s
+text	parser.h	/^    char *text;$/;"	m	struct:parse_state
+time_crashed	init.h	/^    time_t time_crashed;    \/* first crash within inspection window *\/$/;"	m	struct:service
+time_started	init.h	/^    time_t time_started;    \/* time of last start *\/$/;"	m	struct:service
+tlist	init.h	/^    struct listnode tlist;$/;"	m	struct:action	typeref:struct:action::listnode
+trim	init_mem_opt.c	/^inline void trim(char *buf)$/;"	f
+type	init.h	/^    const char *type;$/;"	m	struct:socketinfo
+uevent	devices.c	/^struct uevent {$/;"	s	file:
+ueventd_main	ueventd.c	/^int ueventd_main(int argc, char **argv)$/;"	f
+ueventd_parse_config_file	ueventd_parser.c	/^int ueventd_parse_config_file(const char *fn)$/;"	f
+ueventd_subsystem	ueventd.h	/^struct ueventd_subsystem {$/;"	s
+ueventd_subsystem_find_by_name	ueventd_parser.c	/^struct ueventd_subsystem *ueventd_subsystem_find_by_name(const char *name)$/;"	f
+uid	devices.c	/^    unsigned int uid;$/;"	m	struct:perms_	file:
+uid	init.h	/^    uid_t uid;$/;"	m	struct:service
+uid	init.h	/^    uid_t uid;$/;"	m	struct:socketinfo
+unix_read	bootchart.c	/^unix_read(int  fd, void*  buff, int  len)$/;"	f	file:
+unix_write	bootchart.c	/^unix_write(int  fd, const void*  buff, int  len)$/;"	f	file:
+valid_name	init_parser.c	/^static int valid_name(const char *name)$/;"	f	file:
+valid_name	ueventd_parser.c	/^static int valid_name(const char *name)$/;"	f	file:
+value	init.h	/^    const char *value;$/;"	m	struct:svcenvinfo
+wait_for_coldboot_done_action	init.c	/^static int wait_for_coldboot_done_action(int nargs, char **args)$/;"	f	file:
+wait_for_file	util.c	/^int wait_for_file(const char *filename, int timeout)$/;"	f
+wait_for_one_process	signal_handler.c	/^static int wait_for_one_process(int block)$/;"	f	file:
+watchdogd_main	watchdogd.c	/^int watchdogd_main(int argc, char **argv)$/;"	f
+wildcard	devices.c	/^    unsigned short wildcard;$/;"	m	struct:perms_	file:
+wipe_data_via_recovery	builtins.c	/^static int wipe_data_via_recovery()$/;"	f	file:
+workspace	property_service.c	/^} workspace;$/;"	t	typeref:struct:__anon5	file:
+write_file	builtins.c	/^static int write_file(const char *path, const char *value)$/;"	f	file:
+write_persistent_property	property_service.c	/^static void write_persistent_property(const char *name, const char *value)$/;"	f	file:
+zap_stdio	init.c	/^static void zap_stdio(void)$/;"	f	file:
diff --git a/ueventd.c b/ueventd.c
new file mode 100644
index 0000000..833e4fd
--- /dev/null
+++ b/ueventd.c
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <poll.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <selinux/selinux.h>
+
+#include <private/android_filesystem_config.h>
+
+#include "ueventd.h"
+#include "log.h"
+#include "util.h"
+#include "devices.h"
+#include "ueventd_parser.h"
+
+static char hardware[32];
+static unsigned revision = 0;
+
+static void import_kernel_nv(char *name, int in_qemu)
+{
+    if (*name != '\0') {
+        char *value = strchr(name, '=');
+        if (value != NULL) {
+            *value++ = 0;
+            if (!strcmp(name,"androidboot.hardware"))
+            {
+                strlcpy(hardware, value, sizeof(hardware));
+            }
+        }
+    }
+}
+
+int ueventd_main(int argc, char **argv)
+{
+    struct pollfd ufd;
+    int nr;
+    char tmp[32];
+
+    /*
+     * init sets the umask to 077 for forked processes. We need to
+     * create files with exact permissions, without modification by
+     * the umask.
+     */
+    umask(000);
+
+    /* Prevent fire-and-forget children from becoming zombies.
+     * If we should need to wait() for some children in the future
+     * (as opposed to none right now), double-forking here instead
+     * of ignoring SIGCHLD may be the better solution.
+     */
+    signal(SIGCHLD, SIG_IGN);
+
+    open_devnull_stdio();
+    klog_init();
+#if LOG_UEVENTS
+    /* Ensure we're at a logging level that will show the events */
+    if (klog_get_level() < KLOG_INFO_LEVEL) {
+        klog_set_level(KLOG_INFO_LEVEL);
+    }
+#endif
+
+    union selinux_callback cb;
+    cb.func_log = log_callback;
+    selinux_set_callback(SELINUX_CB_LOG, cb);
+
+    INFO("starting ueventd\n");
+
+    /* Respect hardware passed in through the kernel cmd line. Here we will look
+     * for androidboot.hardware param in kernel cmdline, and save its value in
+     * hardware[]. */
+    import_kernel_cmdline(0, import_kernel_nv);
+
+    get_hardware_name(hardware, &revision);
+
+    ueventd_parse_config_file("/ueventd.rc");
+
+    snprintf(tmp, sizeof(tmp), "/ueventd.%s.rc", hardware);
+    ueventd_parse_config_file(tmp);
+
+    device_init();
+
+    ufd.events = POLLIN;
+    ufd.fd = get_device_fd();
+
+    while(1) {
+        ufd.revents = 0;
+        nr = poll(&ufd, 1, -1);
+        if (nr <= 0)
+            continue;
+        if (ufd.revents & POLLIN)
+               handle_device_fd();
+    }
+}
+
+static int get_android_id(const char *id)
+{
+    unsigned int i;
+    for (i = 0; i < ARRAY_SIZE(android_ids); i++)
+        if (!strcmp(id, android_ids[i].name))
+            return android_ids[i].aid;
+    return -1;
+}
+
+void set_device_permission(int nargs, char **args)
+{
+    char *name;
+    char *attr = 0;
+    mode_t perm;
+    uid_t uid;
+    gid_t gid;
+    int prefix = 0;
+    int wildcard = 0;
+    char *endptr;
+    int ret;
+    char *tmp = 0;
+
+    if (nargs == 0)
+        return;
+
+    if (args[0][0] == '#')
+        return;
+
+    name = args[0];
+
+    if (!strncmp(name,"/sys/", 5) && (nargs == 5)) {
+        INFO("/sys/ rule %s %s\n",args[0],args[1]);
+        attr = args[1];
+        args++;
+        nargs--;
+    }
+
+    if (nargs != 4) {
+        ERROR("invalid line ueventd.rc line for '%s'\n", args[0]);
+        return;
+    }
+
+    /* If path starts with mtd@ lookup the mount number. */
+    if (!strncmp(name, "mtd@", 4)) {
+        int n = mtd_name_to_number(name + 4);
+        if (n >= 0)
+            asprintf(&tmp, "/dev/mtd/mtd%d", n);
+        name = tmp;
+    } else {
+        int len = strlen(name);
+        char *wildcard_chr = strchr(name, '*');
+        if ((name[len - 1] == '*') &&
+            (wildcard_chr == (name + len - 1))) {
+            prefix = 1;
+            name[len - 1] = '\0';
+        } else if (wildcard_chr) {
+            wildcard = 1;
+        }
+    }
+
+    perm = strtol(args[1], &endptr, 8);
+    if (!endptr || *endptr != '\0') {
+        ERROR("invalid mode '%s'\n", args[1]);
+        free(tmp);
+        return;
+    }
+
+    ret = get_android_id(args[2]);
+    if (ret < 0) {
+        ERROR("invalid uid '%s'\n", args[2]);
+        free(tmp);
+        return;
+    }
+    uid = ret;
+
+    ret = get_android_id(args[3]);
+    if (ret < 0) {
+        ERROR("invalid gid '%s'\n", args[3]);
+        free(tmp);
+        return;
+    }
+    gid = ret;
+
+    add_dev_perms(name, attr, perm, uid, gid, prefix, wildcard);
+    free(tmp);
+}
diff --git a/ueventd.h b/ueventd.h
new file mode 100644
index 0000000..0a454c5
--- /dev/null
+++ b/ueventd.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_UEVENTD_H_
+#define _INIT_UEVENTD_H_
+
+#include <cutils/list.h>
+#include <sys/types.h>
+
+struct ueventd_subsystem {
+    struct listnode slist;
+
+    const char *name;
+    enum {
+        DEVNAME_UNKNOWN = 0,
+        DEVNAME_UEVENT_DEVNAME,
+        DEVNAME_UEVENT_DEVPATH,
+    } devname_src;
+    const char *dirname;
+};
+
+int ueventd_main(int argc, char **argv);
+
+#endif
diff --git a/ueventd_keywords.h b/ueventd_keywords.h
new file mode 100644
index 0000000..88e8f01
--- /dev/null
+++ b/ueventd_keywords.h
@@ -0,0 +1,15 @@
+#ifndef KEYWORD
+#define __MAKE_KEYWORD_ENUM__
+#define KEYWORD(symbol, flags, nargs) K_##symbol,
+enum {
+    K_UNKNOWN,
+#endif
+    KEYWORD(subsystem,      SECTION,    1)
+    KEYWORD(devname,        OPTION,     1)
+    KEYWORD(dirname,        OPTION,     1)
+#ifdef __MAKE_KEYWORD_ENUM__
+    KEYWORD_COUNT,
+};
+#undef __MAKE_KEYWORD_ENUM__
+#undef KEYWORD
+#endif
diff --git a/ueventd_parser.c b/ueventd_parser.c
new file mode 100644
index 0000000..e447006
--- /dev/null
+++ b/ueventd_parser.c
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ueventd.h"
+#include "ueventd_parser.h"
+#include "parser.h"
+#include "log.h"
+#include "util.h"
+
+static list_declare(subsystem_list);
+
+static void parse_line_device(struct parse_state *state, int nargs, char **args);
+
+#define SECTION 0x01
+#define OPTION  0x02
+
+#include "ueventd_keywords.h"
+
+#define KEYWORD(symbol, flags, nargs) \
+    [ K_##symbol ] = { #symbol, nargs + 1, flags, },
+
+static struct {
+    const char *name;
+    unsigned char nargs;
+    unsigned char flags;
+} keyword_info[KEYWORD_COUNT] = {
+    [ K_UNKNOWN ] = { "unknown", 0, 0 },
+#include "ueventd_keywords.h"
+};
+#undef KEYWORD
+
+#define kw_is(kw, type) (keyword_info[kw].flags & (type))
+#define kw_nargs(kw) (keyword_info[kw].nargs)
+
+static int lookup_keyword(const char *s)
+{
+    switch (*s++) {
+    case 'd':
+        if (!strcmp(s, "evname")) return K_devname;
+        if (!strcmp(s, "irname")) return K_dirname;
+        break;
+    case 's':
+        if (!strcmp(s, "ubsystem")) return K_subsystem;
+        break;
+    }
+    return K_UNKNOWN;
+}
+
+static void parse_line_no_op(struct parse_state *state __attribute__((unused)),
+        int nargs __attribute__((unused)), char **args  __attribute__((unused)))
+{
+}
+
+static int valid_name(const char *name)
+{
+    while (*name) {
+        if (!isalnum(*name) && (*name != '_') && (*name != '-')) {
+            return 0;
+        }
+        name++;
+    }
+    return 1;
+}
+
+struct ueventd_subsystem *ueventd_subsystem_find_by_name(const char *name)
+{
+    struct listnode *node;
+    struct ueventd_subsystem *s;
+
+    list_for_each(node, &subsystem_list) {
+        s = node_to_item(node, struct ueventd_subsystem, slist);
+        if (!strcmp(s->name, name)) {
+            return s;
+        }
+    }
+    return 0;
+}
+
+static void *parse_subsystem(struct parse_state *state,
+        int nargs __attribute__((unused)), char **args)
+{
+    struct ueventd_subsystem *s;
+
+    if (!valid_name(args[1])) {
+        parse_error(state, "invalid subsystem name '%s'\n", args[1]);
+        return 0;
+    }
+
+    s = ueventd_subsystem_find_by_name(args[1]);
+    if (s) {
+        parse_error(state, "ignored duplicate definition of subsystem '%s'\n",
+                args[1]);
+        return 0;
+    }
+
+    s = calloc(1, sizeof(*s));
+    if (!s) {
+        parse_error(state, "out of memory\n");
+        return 0;
+    }
+    s->name = args[1];
+    s->dirname = "/dev";
+    list_add_tail(&subsystem_list, &s->slist);
+    return s;
+}
+
+static void parse_line_subsystem(struct parse_state *state, int nargs,
+        char **args)
+{
+    struct ueventd_subsystem *s = state->context;
+    int kw;
+
+    if (nargs == 0) {
+        return;
+    }
+
+    kw = lookup_keyword(args[0]);
+    switch (kw) {
+    case K_devname:
+        if (!strcmp(args[1], "uevent_devname"))
+            s->devname_src = DEVNAME_UEVENT_DEVNAME;
+        else if (!strcmp(args[1], "uevent_devpath"))
+            s->devname_src = DEVNAME_UEVENT_DEVPATH;
+        else
+            parse_error(state, "invalid devname '%s'\n", args[1]);
+        break;
+
+    case K_dirname:
+        if (args[1][0] == '/')
+            s->dirname = args[1];
+        else
+            parse_error(state, "dirname '%s' does not start with '/'\n",
+                    args[1]);
+        break;
+
+    default:
+        parse_error(state, "invalid option '%s'\n", args[0]);
+    }
+}
+
+static void parse_new_section(struct parse_state *state, int kw,
+                       int nargs, char **args)
+{
+    printf("[ %s %s ]\n", args[0],
+           nargs > 1 ? args[1] : "");
+
+    switch(kw) {
+    case K_subsystem:
+        state->context = parse_subsystem(state, nargs, args);
+        if (state->context) {
+            state->parse_line = parse_line_subsystem;
+            return;
+        }
+        break;
+    }
+    state->parse_line = parse_line_no_op;
+}
+
+static void parse_line(struct parse_state *state, char **args, int nargs)
+{
+    int kw = lookup_keyword(args[0]);
+    int kw_nargs = kw_nargs(kw);
+
+    if (nargs < kw_nargs) {
+        parse_error(state, "%s requires %d %s\n", args[0], kw_nargs - 1,
+            kw_nargs > 2 ? "arguments" : "argument");
+        return;
+    }
+
+    if (kw_is(kw, SECTION)) {
+        parse_new_section(state, kw, nargs, args);
+    } else if (kw_is(kw, OPTION)) {
+        state->parse_line(state, nargs, args);
+    } else {
+        parse_line_device(state, nargs, args);
+    }
+}
+
+static void parse_config(const char *fn, char *s)
+{
+    struct parse_state state;
+    char *args[UEVENTD_PARSER_MAXARGS];
+    int nargs;
+    nargs = 0;
+    state.filename = fn;
+    state.line = 1;
+    state.ptr = s;
+    state.nexttoken = 0;
+    state.parse_line = parse_line_no_op;
+    for (;;) {
+        int token = next_token(&state);
+        switch (token) {
+        case T_EOF:
+            parse_line(&state, args, nargs);
+            return;
+        case T_NEWLINE:
+            if (nargs) {
+                parse_line(&state, args, nargs);
+                nargs = 0;
+            }
+            state.line++;
+            break;
+        case T_TEXT:
+            if (nargs < UEVENTD_PARSER_MAXARGS) {
+                args[nargs++] = state.text;
+            }
+            break;
+        }
+    }
+}
+
+int ueventd_parse_config_file(const char *fn)
+{
+    char *data;
+    data = read_file(fn, 0);
+    if (!data) return -1;
+
+    parse_config(fn, data);
+    DUMP();
+    return 0;
+}
+
+static void parse_line_device(struct parse_state *state __attribute__((unused)),
+        int nargs, char **args)
+{
+    set_device_permission(nargs, args);
+}
diff --git a/ueventd_parser.h b/ueventd_parser.h
new file mode 100644
index 0000000..907cc49
--- /dev/null
+++ b/ueventd_parser.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_UEVENTD_PARSER_H_
+#define _INIT_UEVENTD_PARSER_H_
+
+#include "ueventd.h"
+
+#define UEVENTD_PARSER_MAXARGS 5
+
+int ueventd_parse_config_file(const char *fn);
+void set_device_permission(int nargs, char **args);
+struct ueventd_subsystem *ueventd_subsystem_find_by_name(const char *name);
+
+#endif
diff --git a/util.c b/util.c
new file mode 100644
index 0000000..0f69e1c
--- /dev/null
+++ b/util.c
@@ -0,0 +1,536 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <errno.h>
+#include <time.h>
+#include <ftw.h>
+
+#include <selinux/label.h>
+#include <selinux/android.h>
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+/* for ANDROID_SOCKET_* */
+#include <cutils/sockets.h>
+
+#include <private/android_filesystem_config.h>
+
+#include "init.h"
+#include "log.h"
+#include "util.h"
+
+/*
+ * android_name_to_id - returns the integer uid/gid associated with the given
+ * name, or -1U on error.
+ */
+static unsigned int android_name_to_id(const char *name)
+{
+    const struct android_id_info *info = android_ids;
+    unsigned int n;
+
+    for (n = 0; n < android_id_count; n++) {
+        if (!strcmp(info[n].name, name))
+            return info[n].aid;
+    }
+
+    return -1U;
+}
+
+/*
+ * decode_uid - decodes and returns the given string, which can be either the
+ * numeric or name representation, into the integer uid or gid. Returns -1U on
+ * error.
+ */
+unsigned int decode_uid(const char *s)
+{
+    unsigned int v;
+
+    if (!s || *s == '\0')
+        return -1U;
+    if (isalpha(s[0]))
+        return android_name_to_id(s);
+
+    errno = 0;
+    v = (unsigned int) strtoul(s, 0, 0);
+    if (errno)
+        return -1U;
+    return v;
+}
+
+/*
+ * create_socket - creates a Unix domain socket in ANDROID_SOCKET_DIR
+ * ("/dev/socket") as dictated in init.rc. This socket is inherited by the
+ * daemon. We communicate the file descriptor's value via the environment
+ * variable ANDROID_SOCKET_ENV_PREFIX<name> ("ANDROID_SOCKET_foo").
+ */
+int create_socket(const char *name, int type, mode_t perm, uid_t uid,
+                  gid_t gid, const char *socketcon)
+{
+    struct sockaddr_un addr;
+    int fd, ret;
+    char *filecon;
+
+    if (socketcon)
+        setsockcreatecon(socketcon);
+
+    fd = socket(PF_UNIX, type, 0);
+    if (fd < 0) {
+        ERROR("Failed to open socket '%s': %s\n", name, strerror(errno));
+        return -1;
+    }
+
+    if (socketcon)
+        setsockcreatecon(NULL);
+
+    memset(&addr, 0 , sizeof(addr));
+    addr.sun_family = AF_UNIX;
+    snprintf(addr.sun_path, sizeof(addr.sun_path), ANDROID_SOCKET_DIR"/%s",
+             name);
+
+    ret = unlink(addr.sun_path);
+    if (ret != 0 && errno != ENOENT) {
+        ERROR("Failed to unlink old socket '%s': %s\n", name, strerror(errno));
+        goto out_close;
+    }
+
+    filecon = NULL;
+    if (sehandle) {
+        ret = selabel_lookup(sehandle, &filecon, addr.sun_path, S_IFSOCK);
+        if (ret == 0)
+            setfscreatecon(filecon);
+    }
+
+    ret = bind(fd, (struct sockaddr *) &addr, sizeof (addr));
+    if (ret) {
+        ERROR("Failed to bind socket '%s': %s\n", name, strerror(errno));
+        goto out_unlink;
+    }
+
+    setfscreatecon(NULL);
+    freecon(filecon);
+
+    chown(addr.sun_path, uid, gid);
+    chmod(addr.sun_path, perm);
+
+    INFO("Created socket '%s' with mode '%o', user '%d', group '%d'\n",
+         addr.sun_path, perm, uid, gid);
+
+    return fd;
+
+out_unlink:
+    unlink(addr.sun_path);
+out_close:
+    close(fd);
+    return -1;
+}
+
+/* reads a file, making sure it is terminated with \n \0 */
+void *read_file(const char *fn, unsigned *_sz)
+{
+    char *data;
+    int sz;
+    int fd;
+    struct stat sb;
+
+    data = 0;
+    fd = open(fn, O_RDONLY);
+    if(fd < 0) return 0;
+
+    // for security reasons, disallow world-writable
+    // or group-writable files
+    if (fstat(fd, &sb) < 0) {
+        ERROR("fstat failed for '%s'\n", fn);
+        goto oops;
+    }
+    if ((sb.st_mode & (S_IWGRP | S_IWOTH)) != 0) {
+        ERROR("skipping insecure file '%s'\n", fn);
+        goto oops;
+    }
+
+    sz = lseek(fd, 0, SEEK_END);
+    if(sz < 0) goto oops;
+
+    if(lseek(fd, 0, SEEK_SET) != 0) goto oops;
+
+    data = (char*) malloc(sz + 2);
+    if(data == 0) goto oops;
+
+    if(read(fd, data, sz) != sz) goto oops;
+    close(fd);
+    data[sz] = '\n';
+    data[sz+1] = 0;
+    if(_sz) *_sz = sz;
+    return data;
+
+oops:
+    close(fd);
+    if(data != 0) free(data);
+    return 0;
+}
+
+#define MAX_MTD_PARTITIONS 16
+
+static struct {
+    char name[16];
+    int number;
+} mtd_part_map[MAX_MTD_PARTITIONS];
+
+static int mtd_part_count = -1;
+
+static void find_mtd_partitions(void)
+{
+    int fd;
+    char buf[1024];
+    char *pmtdbufp;
+    ssize_t pmtdsize;
+    int r;
+
+    fd = open("/proc/mtd", O_RDONLY);
+    if (fd < 0)
+        return;
+
+    buf[sizeof(buf) - 1] = '\0';
+    pmtdsize = read(fd, buf, sizeof(buf) - 1);
+    pmtdbufp = buf;
+    while (pmtdsize > 0) {
+        int mtdnum, mtdsize, mtderasesize;
+        char mtdname[16];
+        mtdname[0] = '\0';
+        mtdnum = -1;
+        r = sscanf(pmtdbufp, "mtd%d: %x %x %15s",
+                   &mtdnum, &mtdsize, &mtderasesize, mtdname);
+        if ((r == 4) && (mtdname[0] == '"')) {
+            char *x = strchr(mtdname + 1, '"');
+            if (x) {
+                *x = 0;
+            }
+            INFO("mtd partition %d, %s\n", mtdnum, mtdname + 1);
+            if (mtd_part_count < MAX_MTD_PARTITIONS) {
+                strcpy(mtd_part_map[mtd_part_count].name, mtdname + 1);
+                mtd_part_map[mtd_part_count].number = mtdnum;
+                mtd_part_count++;
+            } else {
+                ERROR("too many mtd partitions\n");
+            }
+        }
+        while (pmtdsize > 0 && *pmtdbufp != '\n') {
+            pmtdbufp++;
+            pmtdsize--;
+        }
+        if (pmtdsize > 0) {
+            pmtdbufp++;
+            pmtdsize--;
+        }
+    }
+    close(fd);
+}
+
+int mtd_name_to_number(const char *name)
+{
+    int n;
+    if (mtd_part_count < 0) {
+        mtd_part_count = 0;
+        find_mtd_partitions();
+    }
+    for (n = 0; n < mtd_part_count; n++) {
+        if (!strcmp(name, mtd_part_map[n].name)) {
+            return mtd_part_map[n].number;
+        }
+    }
+    return -1;
+}
+
+/*
+ * gettime() - returns the time in seconds of the system's monotonic clock or
+ * zero on error.
+ */
+time_t gettime(void)
+{
+    struct timespec ts;
+    int ret;
+
+    ret = clock_gettime(CLOCK_MONOTONIC, &ts);
+    if (ret < 0) {
+        ERROR("clock_gettime(CLOCK_MONOTONIC) failed: %s\n", strerror(errno));
+        return 0;
+    }
+
+    return ts.tv_sec;
+}
+
+int mkdir_recursive(const char *pathname, mode_t mode)
+{
+    char buf[128];
+    const char *slash;
+    const char *p = pathname;
+    int width;
+    int ret;
+    struct stat info;
+
+    while ((slash = strchr(p, '/')) != NULL) {
+        width = slash - pathname;
+        p = slash + 1;
+        if (width < 0)
+            break;
+        if (width == 0)
+            continue;
+        if ((unsigned int)width > sizeof(buf) - 1) {
+            ERROR("path too long for mkdir_recursive\n");
+            return -1;
+        }
+        memcpy(buf, pathname, width);
+        buf[width] = 0;
+        if (stat(buf, &info) != 0) {
+            ret = make_dir(buf, mode);
+            if (ret && errno != EEXIST)
+                return ret;
+        }
+    }
+    ret = make_dir(pathname, mode);
+    if (ret && errno != EEXIST)
+        return ret;
+    return 0;
+}
+
+/*
+ * replaces any unacceptable characters with '_', the
+ * length of the resulting string is equal to the input string
+ */
+void sanitize(char *s)
+{
+    const char* accept =
+            "abcdefghijklmnopqrstuvwxyz"
+            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+            "0123456789"
+            "_-.";
+
+    if (!s)
+        return;
+
+    for (; *s; s++) {
+        s += strspn(s, accept);
+        if (*s) *s = '_';
+    }
+}
+
+void make_link(const char *oldpath, const char *newpath)
+{
+    int ret;
+    char buf[256];
+    char *slash;
+    int width;
+
+    slash = strrchr(newpath, '/');
+    if (!slash)
+        return;
+    width = slash - newpath;
+    if (width <= 0 || width > (int)sizeof(buf) - 1)
+        return;
+    memcpy(buf, newpath, width);
+    buf[width] = 0;
+    ret = mkdir_recursive(buf, 0755);
+    if (ret)
+        ERROR("Failed to create directory %s: %s (%d)\n", buf, strerror(errno), errno);
+
+    ret = symlink(oldpath, newpath);
+    if (ret && errno != EEXIST)
+        ERROR("Failed to symlink %s to %s: %s (%d)\n", oldpath, newpath, strerror(errno), errno);
+}
+
+void remove_link(const char *oldpath, const char *newpath)
+{
+    char path[256];
+    ssize_t ret;
+    ret = readlink(newpath, path, sizeof(path) - 1);
+    if (ret <= 0)
+        return;
+    path[ret] = 0;
+    if (!strcmp(path, oldpath))
+        unlink(newpath);
+}
+
+int wait_for_file(const char *filename, int timeout)
+{
+    struct stat info;
+    time_t timeout_time = gettime() + timeout;
+    int ret = -1;
+
+    while (gettime() < timeout_time && ((ret = stat(filename, &info)) < 0))
+        usleep(10000);
+
+    return ret;
+}
+
+void open_devnull_stdio(void)
+{
+    int fd;
+    static const char *name = "/dev/__null__";
+    if (mknod(name, S_IFCHR | 0600, (1 << 8) | 3) == 0) {
+        fd = open(name, O_RDWR);
+        unlink(name);
+        if (fd >= 0) {
+            dup2(fd, 0);
+            dup2(fd, 1);
+            dup2(fd, 2);
+            if (fd > 2) {
+                close(fd);
+            }
+            return;
+        }
+    }
+
+    exit(1);
+}
+
+void get_hardware_name(char *hardware, unsigned int *revision)
+{
+    const char *cpuinfo = "/proc/cpuinfo";
+    char *data = NULL;
+    size_t len = 0, limit = 1024;
+    int fd, n;
+    char *x, *hw, *rev;
+
+    /* Hardware string was provided on kernel command line */
+    if (hardware[0])
+        return;
+
+    fd = open(cpuinfo, O_RDONLY);
+    if (fd < 0) return;
+
+    for (;;) {
+        x = realloc(data, limit);
+        if (!x) {
+            ERROR("Failed to allocate memory to read %s\n", cpuinfo);
+            goto done;
+        }
+        data = x;
+
+        n = read(fd, data + len, limit - len);
+        if (n < 0) {
+            ERROR("Failed reading %s: %s (%d)\n", cpuinfo, strerror(errno), errno);
+            goto done;
+        }
+        len += n;
+
+        if (len < limit)
+            break;
+
+        /* We filled the buffer, so increase size and loop to read more */
+        limit *= 2;
+    }
+
+    data[len] = 0;
+    hw = strstr(data, "\nHardware");
+    rev = strstr(data, "\nRevision");
+
+    if (hw) {
+        x = strstr(hw, ": ");
+        if (x) {
+            x += 2;
+            n = 0;
+            while (*x && *x != '\n') {
+                if (!isspace(*x))
+                    hardware[n++] = tolower(*x);
+                x++;
+                if (n == 31) break;
+            }
+            hardware[n] = 0;
+        }
+    }
+
+    if (rev) {
+        x = strstr(rev, ": ");
+        if (x) {
+            *revision = strtoul(x + 2, 0, 16);
+        }
+    }
+
+done:
+    close(fd);
+    free(data);
+}
+
+void import_kernel_cmdline(int in_qemu,
+                           void (*import_kernel_nv)(char *name, int in_qemu))
+{
+    char cmdline[2048];
+    char *ptr;
+    int fd;
+
+    fd = open("/proc/cmdline", O_RDONLY);
+    if (fd >= 0) {
+        int n = read(fd, cmdline, sizeof(cmdline) - 1);
+        if (n < 0) n = 0;
+
+        /* get rid of trailing newline, it happens */
+        if (n > 0 && cmdline[n-1] == '\n') n--;
+
+        cmdline[n] = 0;
+        close(fd);
+    } else {
+        cmdline[0] = 0;
+    }
+
+    ptr = cmdline;
+    while (ptr && *ptr) {
+        char *x = strchr(ptr, ' ');
+        if (x != 0) *x++ = 0;
+        import_kernel_nv(ptr, in_qemu);
+        ptr = x;
+    }
+}
+
+int make_dir(const char *path, mode_t mode)
+{
+    int rc;
+
+    char *secontext = NULL;
+
+    if (sehandle) {
+        selabel_lookup(sehandle, &secontext, path, mode);
+        setfscreatecon(secontext);
+    }
+
+    rc = mkdir(path, mode);
+
+    if (secontext) {
+        int save_errno = errno;
+        freecon(secontext);
+        setfscreatecon(NULL);
+        errno = save_errno;
+    }
+
+    return rc;
+}
+
+int restorecon(const char* pathname)
+{
+    return selinux_android_restorecon(pathname, 0);
+}
+
+int restorecon_recursive(const char* pathname)
+{
+    return selinux_android_restorecon(pathname, SELINUX_ANDROID_RESTORECON_RECURSE);
+}
diff --git a/util.h b/util.h
new file mode 100644
index 0000000..04b8129
--- /dev/null
+++ b/util.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_UTIL_H_
+#define _INIT_UTIL_H_
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
+
+static const char *coldboot_done = "/dev/.coldboot_done";
+
+int mtd_name_to_number(const char *name);
+int create_socket(const char *name, int type, mode_t perm,
+                  uid_t uid, gid_t gid, const char *socketcon);
+void *read_file(const char *fn, unsigned *_sz);
+time_t gettime(void);
+unsigned int decode_uid(const char *s);
+
+int mkdir_recursive(const char *pathname, mode_t mode);
+void sanitize(char *p);
+void make_link(const char *oldpath, const char *newpath);
+void remove_link(const char *oldpath, const char *newpath);
+int wait_for_file(const char *filename, int timeout);
+void open_devnull_stdio(void);
+void get_hardware_name(char *hardware, unsigned int *revision);
+void import_kernel_cmdline(int in_qemu, void (*import_kernel_nv)(char *name, int in_qemu));
+int make_dir(const char *path, mode_t mode);
+int restorecon(const char *pathname);
+int restorecon_recursive(const char *pathname);
+#endif
diff --git a/watchdogd.c b/watchdogd.c
new file mode 100644
index 0000000..fb53836
--- /dev/null
+++ b/watchdogd.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <linux/watchdog.h>
+
+#include "log.h"
+#include "util.h"
+
+#define DEV_NAME "/dev/watchdog"
+
+int watchdogd_main(int argc, char **argv)
+{
+    int fd;
+    int ret;
+    int interval = 10;
+    int margin = 10;
+    int timeout;
+
+    open_devnull_stdio();
+    klog_init();
+
+    INFO("Starting watchdogd\n");
+
+    if (argc >= 2)
+        interval = atoi(argv[1]);
+
+    if (argc >= 3)
+        margin = atoi(argv[2]);
+
+    timeout = interval + margin;
+
+    fd = open(DEV_NAME, O_RDWR);
+    if (fd < 0) {
+        ERROR("watchdogd: Failed to open %s: %s\n", DEV_NAME, strerror(errno));
+        return 1;
+    }
+
+    ret = ioctl(fd, WDIOC_SETTIMEOUT, &timeout);
+    if (ret) {
+        ERROR("watchdogd: Failed to set timeout to %d: %s\n", timeout, strerror(errno));
+        ret = ioctl(fd, WDIOC_GETTIMEOUT, &timeout);
+        if (ret) {
+            ERROR("watchdogd: Failed to get timeout: %s\n", strerror(errno));
+        } else {
+            if (timeout > margin)
+                interval = timeout - margin;
+            else
+                interval = 1;
+            ERROR("watchdogd: Adjusted interval to timeout returned by driver: timeout %d, interval %d, margin %d\n",
+                  timeout, interval, margin);
+        }
+    }
+
+    while(1) {
+        write(fd, "", 1);
+        sleep(interval);
+    }
+}
+
diff --git a/watchdogd.h b/watchdogd.h
new file mode 100644
index 0000000..8b48ab8
--- /dev/null
+++ b/watchdogd.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_WATCHDOGD_H_
+#define _INIT_WATCHDOGD_H_
+
+int watchdogd_main(int argc, char **argv);
+
+#endif
-- 
1.9.1

